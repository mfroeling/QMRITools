(* ::Package:: *)

(* ::Title:: *)
(*QMRITools SimulationTools*)


(* ::Subtitle:: *)
(*Written by: Martijn Froeling, PhD*)
(*m.froeling@gmail.com*)


(* ::Section:: *)
(*Begin Package*)


BeginPackage["QMRITools`SimulationTools`", Join[{"Developer`"}, Complement[QMRITools`$Contexts, {"QMRITools`SimulationTools`"}]]];


(* ::Section:: *)
(*Usage Notes*)


(* ::Subsection::Closed:: *)
(*Functions*)


AddNoise::usage = 
"AddNoise[data, noise] ads rician noise to the data with a given sigma or SNR value."

Tensor::usage = 
"Tensor[{l1, l2, l3}] creates a diffuison tensor with vectors {{0,0,1},{0,1,0},{1,0,0}} and eigenvalues {l1, l2, l3}.
Tensor[{l1, l2, l3}, {e1, e2, e3}] creates a diffuison tensor with vectors {e1, e2, e3} and eigenvalues {l1, l2, l3}.
Tensor[{l1, l2, l3}, \"Random\"] creates a diffuison tensor with random orthogonal eigenvectors {e1, e2, e2} and eigenvalues {l1, l2, l3}.
Tensor[{l1, l2, l3}, \"RandomZ\"] creates a diffuison tensor with random orthogonal eigenvectors {{1,0,0}, e2, e3} with random eigenvectors and eigenvalues {l1, l2, l3}.
Tensor[{l1, l2, l3}, \"OrtRandom\"] creates a diffuison tensor with random orthogonal eigenvectors {{1,0,0},{0,1,0},{0,0,1}} and eigenvalues {l1, l2, l3}.
Tensor[] is based on DOI: 10.1002/nbm.2959."

Signal::usage = 
"Signal[par, TR, TE] calculates the MRI signal at a given TR and TE. Par is defineds as {pd, T1, T2}."

CreateDiffData::usage = 
"CreateDiffData[sig, eig, bvec, gradients, dim] creates a DTI datasets of dimensions dim with sig as unweighted signal S0 and bvec and gradients. 
eig can be {l1, l2, l3}, {{l1, l2, l3}, {e1, e2, e3}}, {{l1, l2, l3}, \"Random\"}, {{l1, l2, l3}, \"RandomZ\"} or {{l1, l2, l3}, \"OrtRandom\"}. 
Uses Tensor internally.

CreateDiffData[] is based on DOI: 10.1002/nbm.2959."

BlochSeries::usage = 
"BlochSeries[vectorIn, deltat, freqRange, B1] performs a Bloch simulation of an RF pulse."

Pulses::usage = 
"Pulses[name] gives the pulse shape of some predefinec Philips pulse shapes."

GetPulseProfile::usage = 
"GetPulseProfile[excitation, refocus] gives the pusl angle profiles for the exitation and refocussing pulses.
a pulse is defined as {\"name\", flipangle, {G_strnth, Dur, BW}}.
GetPulseProfile[{\"name\", flipangle, {G_strnth, Dur, BW}}] gives detaile slice profile information of one pulse.

output is {ex_angle_profiel, ref_angel_profile, {plots}}.
output for single pulse is {{distance, Mt, Mz, Mx, My, ang, phase}, plots}."

SimulateSliceEPG::usage = 
"SimulateSliceEPG[exitation, refocus, {{T1, T2}, {Necho, echoSp}, b1}] gives a simulated slice profile and EPG singnal plot.
exitation and refocus are generated by GetPulseProfiel."

CalculateGfactor::usage = 
"CalculateGfactor[factors, sensitivity, Wmat] calculates a gfactor for given sensitivity maps and noise corraltion W. given the sense factors which is a list of three integers."

GfactorSimulation::usage = 
"GfactorSimulation[sensitivity, cov, {dir,sense}] calculates the gfactormaps for given sensitivity maps and noise corraltion cov in one direction. 
The sensefactors are a list of integers in a given direction: \"LR\", \"FH\", or \"AP\".
GfactorSimulation[sensitivity, cov, {dir1,sense1}, {dir2,sense2}] calculates the gfactormaps for given sensitivity maps and noise corraltion W in two directions."

SimParameters::usage = 
"SimParameters[tens] caculates the diffusion parameters for tens. The output can be used in PlotSimulationHist and PlotSimulation."

PlotSimulationHist::usage = 
"PlotSimulationHist[pars, label, xdata, tr] plots the pars (output form Parameters). 
Using label as plotlabel and xdata as x axis label. tr are the true parameter values."

PlotSimulation::usage = 
"PlotSimulation[pars, xval, true, label, color] plots the pars (output form Parameters). Using label as PlotLabel and xval as x axis Thics.
tr are the true parameter values. color are the color used for the plot."

SimAngleParameters::usage = 
"SimAngleParameters[tens,vec] caculates the diffusion eigenvectors for tens compared to the true values vec. 
The output can be used in PlotSimulationAngleHist and PlotSimulationAngle."

PlotSimulationAngleHist::usage = 
"PlotSimulationAngleHist[pars, label, xdata] plots pars (output from Anlge Parameters)."

PlotSimulationAngle::usage = 
"PlotSimulationAngle[par, xdata, label, col] plots pars (output from Anlge Parameters)."

PlotSimulationVec::usage =
"PlotSimulationVec[tens, xdata, label] plots the eigenvectors from simulated tensors."

GESignal::usage = 
"GESignal[ang, {tr, t1}] calculates the gradient echo signal for flipangles ang using tr and t1. 
GESignal[ang_?ListQ, {{tr1_, tr2_}, t1_}] calculates the dual tr gradient echo signal for flipangles ang using tr1, tr2 and t1."

SimulateDualTR::usage =
"SimulateDualTR[] simulates the signal of a Dual TR T1 map."


(* ::Subsection::Closed:: *)
(*Options*)


NoiseSize::usage = 
"NoiseSize is an option for AddNoise. Values can be \"Sigma\", then the noise sigma is given or \"SNR\", then the SNR is given."

NoiseType::usage = 
"NoiseType is an option for AddNoise. Values can be \"Absolute\" or \"Complex\", and will add either Rician absolute noise or complex noise to the data."

TensOutput::usage = 
"TensOutput is an option for Tensor. Values can be \"Vector\" or \"Matrix\"."

SortVecs::usage = 
"SortVecs is an option for PlotSimulationVec."

MagnetizationVector::usage =
"MagnetizationVector is an option for GetPulseProfile. It defines the start magnetization vector for the bloch simulation."

SliceRange::usage =
"SliceRange is an option for GetPulseProfile. It specifies over which range the slice profile is generated (in mm). the total profile is 2xSliceRange."

SliceRangeSamples::usage =
"SliceRangeSamples is an option for GetPulseProfile. defines how many samples are used to generate half a puls profile."

GRegularization::usage = 
"GRegularization is an option for CalculateGfactor and GfactorSimulation."

GOutput::usage = 
"GOutput is an option for GfactorSimulation. can be \"Grid\" or \"List\"."

ReportFits::usage = 
"ReportFits is an option for SimulateSliceEPG. If True it also reports the fit values."

FatFieldStrength::usage = 
"FatFieldStrength is an option for GetPulseProfile. If the value >0 it will calculate the shift of the fat refocussing pulse compared to the fat exitation pulse.
The shift is in SliceRangeSamples steps."



(* ::Subsection::Closed:: *)
(*Error Messages*)


Tensor::vec = "Eigenvectors must be a 3x3 matrix, \"Random\", \"RandomZ\", \"OrtRandom\", not: `1`"

Tensor::val = "Eigenvalues mus be a vector of size 3 or a number, not:`1`"

CreateDiffData::eig = "eigen system must be 3 eigenvalues {l1,l2,l2} in which cases fixed vectors wil be used 
	or eigenvalues with geven vectors {{l1,l2,l3},{e1,e2,e3}} 
	other possibility is 3 eigenvalues with a random, randomz or random ortogonal (fixed vectors with random sign)
		{{l1,l2,l3},Random}
		{{l1,l2,l3},RandomZ}
		{{l1,l2,l3},OrtRandom}
	not : `1`"

AddNoise::opt = "AddNoise"


(* ::Section:: *)
(*Functions*)


Begin["`Private`"]


(* ::Subsection::Closed:: *)
(*AddNoise*)


Options[AddNoise] = {NoiseSize->"Sigma",NoiseType->"Absolute"};

SyntaxInformation[AddNoise] = {"ArgumentsPattern" -> {_, _, OptionsPattern[]}};

AddNoise[dat_,noise_,OptionsPattern[]]:=Block[{sig,data,mdat,fdat},
	data=dat//N;
	sig=Switch[OptionValue[NoiseSize],
		"SNR",
		mdat=Switch[ArrayDepth[data],
			1,
			data[[1]],
			2,
			fdat=data[[1,All]];
			Mean[Pick[fdat,Unitize[fdat],1]],
			3,
			fdat=Flatten[data[[1,All,All]]];
			Mean[Pick[fdat,Unitize[fdat],1]],
			4,
			fdat=Flatten[data[[All,1,All,All]]];
			Mean[Pick[fdat,Unitize[fdat],1]],
			_,
			Message[AddNoise::dat];Return[]
		];
		mdat/noise
		,
		"Sigma",
		noise,
		_,
		Message[AddNoise::opt];Return[]
		];
	Switch[OptionValue[NoiseType],
		"Absolute", RicianDistribution[data,sig],
		"Complex", CompledDistribution[data,sig]
	]
	]


RicianDistribution = Compile[{{Mu, _Real, 0}, {Sigma, _Real, 0}},
	Sqrt[RandomReal[NormalDistribution[Mu, Sigma]]^2 + RandomReal[NormalDistribution[0, Sigma]]^2],
	RuntimeAttributes -> {Listable}, RuntimeOptions -> "Speed"]

CompledDistribution = Compile[{{Mu, _Complex, 0}, {Sigma, _Complex, 0}},
	RandomReal[NormalDistribution[Re@Mu, Sigma]] + I RandomReal[NormalDistribution[Im@Mu, Sigma]],
	RuntimeAttributes -> {Listable}, RuntimeOptions -> "Speed"]

(* ::Subsection:: *)
(*Tensor*)


(* ::Subsubsection::Closed:: *)
(*Tensor*)


Options[Tensor]={TensOutput->"Vector"}

SyntaxInformation[Tensor] = {"ArgumentsPattern" -> {_, _., OptionsPattern[]}};

Tensor[l_,ops:OptionsPattern[]]:=Tensor[l,{{0,0,1},{0,1,0},{1,0,0}},ops]

Tensor[l_,vec_,OptionsPattern[]]:= Block[{e,tens},
	e = Switch[vec,
		"Random",
		RandomMat[],
		"RandomZ",
		RandomMatZ[],
		"OrtRandom",
		RandomSample[{{0,0,1},{0,1,0},{1,0,0}}],
		_,
		If[MatrixQ[vec]&&ArrayDepth[vec]==2,
			vec,
			Return[Message[Tensor::vec,vec]]
			]
		];
		
	tens = If[NumberQ[l],
		Transpose[e].{{l,0,0},{0,l,0},{0,0,l}}.e,
		If[VectorQ[l]&&Length[l]==3,
			Transpose[e].{{l[[1]],0,0},{0,l[[2]],0},{0,0,l[[3]]}}.e,
			Return[Message[Tensor::val,l]]
			]
		];
	Chop[Switch[OptionValue[TensOutput],"Vector",TensVec[tens],"Matrix",tens]]
	]


(* ::Subsubsection::Closed:: *)
(*Tensor functions*)


RandomMatZ[]:= Block[{l1,l2,l3},
	l1={1,0,0};
	l2=Normalize[{0,1,1}*RandomVec[]];
	l3=Cross[l1,l2];
	{l1,l2,l3}
	];


RandomMat[]:= Block[{l1,l2,l3},
	l1={1,0,0};
	l2=Normalize[{0,1,1}*RandomVec[]];
	l3=Cross[l1,l2];
	{l1,l2,l3}.RotationMatrix[{{1,0,0},RandomVec[]}]
	];


RandomVec[]:=Normalize[RandomReal[NormalDistribution[],3]]


(* ::Subsection::Closed:: *)
(*Signal*)


SyntaxInformation[Signal] = {"ArgumentsPattern" -> {_, _, _}};

Signal[par_,TR_,TE_]:=par[[1]](1-Exp[-TR/par[[2]]])Exp[-TE/par[[3]]]


(* ::Subsection:: *)
(*CreateDiffData*)


(* ::Subsubsection::Closed:: *)
(*CreateDiffData*)


SyntaxInformation[CreateDiffData] = {"ArgumentsPattern" -> {_, _, _, _, _.}};

CreateDiffData[S0_,eig_,bval_?NumberQ,grad_,dim_]:= CreateDiffData[S0,eig,Prepend[ConstantArray[bval,Length[grad]],0],Prepend[grad,{0,0,0}],dim]

CreateDiffData[S0_,eig_,bvec:{_?NumberQ..},grad_,dim_]:= CreateDiffData[S0,eig,Bmatrix[bvec,grad],dim]

CreateDiffData[S0_,eig_,bmat_?ArrayQ,dim_]:= Block[{diff},
	
	diff=If[Dimensions[eig]=={3},
		ConstantArray[SignalTensor[S0,bmat,Tensor[eig]],dim],
		If[Dimensions[eig]=={2,3}&&Dimensions[eig[[2]]]=={3,3},
			ConstantArray[SignalTensor[S0,bmat,Tensor[eig[[1]],eig[[2]]]],dim],
			If[eig[[2]]==="Random"||eig[[2]]==="RandomZ"||eig[[2]]==="OrtRandom",
			Array[SignalTensor[S0,bmat,Tensor[eig[[1]],eig[[2]]]]&,dim],
			Return[Message[CreateDiffData::eig,eig]]]
			]
		];
	
	Switch[Length[dim],
		1,Transpose[diff],
		2,Transpose[diff,{2,3,1}],
		3,Transpose[diff,{1,3,4,2}]
		]
	]


(* ::Subsubsection::Closed:: *)
(*SignalTensor*)


SignalTensor[S0_, bmat_, D_] := Module[{Dv},
	Dv=Append[If[Dimensions[D]=={3,3},TensVec[D],D],Log[S0]];
	Exp[bmat.Dv]
	]


(* ::Subsection:: *)
(*Bloch Simulation*)


(* ::Subsubsection::Closed:: *)
(*BlochSeries*)


BlochSeries[Mi_, dt_, w_, p_, gyro_ : "1H"] := BlochSeriesi[Mi, dt, w, p N[2 Pi GyromagneticRatio[gyro] 10^6]]

BlochSeriesi = Compile[{{Mi, _Real, 1}, {dt, _Real, 0}, {w, _Real, 0}, {p, _Real, 1}}, Block[{M = Mi, Mt, Mz, Mx, My},
	(M = MatrixExp[dt {{0, w, 0}, {-w, 0, #}, {0, -#, 0}}].M) & /@ p;
	(*calculate tranverse longitudinal and xy magnetization*)
	{Mx, My, Mz} = M;
	Mt = Norm[{Mx, My}];
	(*give output {w,MT,Mz,Mx,My,ang,phase}*)
	{w, Mt, Mz, Mx, My, ArcTan[Mz, Mt]/Degree, ArcTan[Mx, My]}]
,RuntimeAttributes -> {Listable}, RuntimeOptions -> "Speed"];


(* ::Subsubsection::Closed:: *)
(*Pulses*)


Pulses[name_] := Switch[name,
	"sg_100_100_0",
	{0., 0.0126, 0.02622, 0.0408, 0.05637, 0.07291, 0.0904, 0.10889, 0.1283, 0.14863, 0.16984, 0.1919, 0.21479, 0.23847, 0.26286, 0.28794, 
	0.31364, 0.33992, 0.36668, 0.39387, 0.42143, 0.44926, 0.47731, 0.50548, 0.53368, 0.56182, 0.58983, 0.6176, 0.64504, 0.67211, 
	0.69863, 0.72457, 0.74984, 0.77432, 0.79794, 0.82061, 0.84225, 0.86279, 0.88214, 0.9002, 0.91696, 0.93231, 0.94623, 0.95862, 
	0.96948, 0.97873, 0.98636, 0.99231, 0.99658, 0.99915, 1., 0.99915, 0.99658, 0.99231, 0.98636, 0.97873, 0.96948, 0.95862, 0.94623, 
	0.93231, 0.91696, 0.9002, 0.88214, 0.86279, 0.84225, 0.82061, 0.79794, 0.77432, 0.74984, 0.72457, 0.69863, 0.67211, 0.64504, 
	0.6176, 0.58983, 0.56182, 0.53368, 0.50548, 0.47731, 0.44926, 0.42143, 0.39387, 0.36668, 0.33992, 0.31364, 0.28794, 0.26286, 
	0.23847, 0.21479, 0.1919, 0.16984, 0.14863, 0.1283, 0.10889, 0.0904, 0.07291, 0.05637, 0.0408, 0.02622, 0.0126, 0.},
	"sg_150_100_167",
	{0.00201, -0.00421, -0.01096, -0.01816, -0.02579, -0.03378, -0.04205, -0.0506, -0.0593, -0.06806, -0.07682, -0.08545, -0.09387,
	-0.10196, -0.10962, -0.1167, -0.12311, -0.1287, -0.13337, -0.13697, -0.13938, -0.14045, -0.14011, -0.13825, -0.13471, -0.1294,
	-0.12229, -0.11322, -0.10218, -0.08905, -0.07389, -0.05655, -0.03711, -0.01556, 0.00812, 0.03388, 0.06162, 0.09128, 0.12281,
	0.15607, 0.19092, 0.22724, 0.26484, 0.30357, 0.34324, 0.38365, 0.42454, 0.46577, 0.50703, 0.54811, 0.58879, 0.6288, 0.6679, 
	0.70586,0.74239, 0.77734, 0.81039, 0.8414, 0.87011, 0.89636, 0.91995,  0.94076, 0.95859, 0.97336, 0.98495, 0.99329, 0.99832, 1., 0.99832,
	0.99329, 0.98495, 0.97336, 0.95859, 0.94076, 0.91995, 0.89636, 0.87011, 0.8414, 0.81039, 0.77734, 0.74239, 0.70586, 0.6679, 0.6288,
	0.58879, 0.54811, 0.50703, 0.46577, 0.42454, 0.38365, 0.34324, 0.30357, 0.26484, 0.22724, 0.19092, 0.15607, 0.12281, 0.09128, 0.06162, 0.03388, 0.00812},
	"sg_200_100_0",
	{0., -0.0126, -0.026, -0.04007, -0.0546, -0.06934, -0.08405, -0.09851, -0.11243, -0.12546, -0.13739, -0.14786, -0.15659, -0.16324, 
	-0.16755, -0.16926, -0.16807, -0.16376, -0.15613, -0.14499, -0.13022, -0.11173, -0.08945, -0.06336, -0.03351, 0., 0.03705, 0.07739, 
	0.12088, 0.16715, 0.21589, 0.26673, 0.31925, 0.37303, 0.42756, 0.48235, 0.53688, 0.59062, 0.64306, 0.69362, 0.74184, 0.78719, 
	0.82919, 0.8674, 0.90139, 0.93081, 0.95535, 0.97473, 0.98871, 0.99716, 1., 0.99716, 0.98871, 0.97473, 0.95535, 0.93081, 0.90139, 
	0.8674, 0.82919, 0.78719, 0.74184, 0.69362, 0.64306, 0.59062, 0.53688, 0.48235, 0.42756, 0.37303, 0.31925, 0.26673, 0.21589, 
	0.16715, 0.12088, 0.07739, 0.03705, 0., -0.03351, -0.06336, -0.08945, -0.11173, -0.13022, -0.14499, -0.15613, -0.16376, -0.16807, -0.16926, 
	-0.16755, -0.16324, -0.15659, -0.14786, -0.13739, -0.12546, -0.11243, -0.09851, -0.08405, -0.06934, -0.0546, -0.04007, -0.026, -0.0126, 0.},
	"sinc_centre",
	{0., 0.03705, 0.07739, 0.12088, 0.16715, 0.21589, 0.26673, 0.31925,  0.37303, 0.42756, 0.48235, 0.53688, 0.59062, 0.64306, 0.69362,
	0.74184, 0.78719, 0.82919, 0.8674, 0.90139, 0.93081, 0.95535,0.9747, 0.98871, 0.99716, 1., 0.99716, 0.98871, 0.9747, 0.95535,
	0.93081, 0.90139, 0.8674, 0.82919, 0.78719, 0.74184, 0.69362, 0.64306, 0.59062, 0.53688, 0.48235, 0.42756, 0.37303, 0.31925,
	0.26673, 0.21589, 0.16715, 0.12088, 0.07739, 0.03705, 0.},
	"echo_2",
	{0.03504, 0.04898, 0.05676, 0.06095, 0.06317, 0.06442, 0.06494, 0.06464, 0.0633, 0.06088, 0.05734, 0.05246, 0.04566, 0.03619,
	0.02332, 0.00647, -0.01395, -0.03665, -0.05982, -0.08158, -0.10092, -0.11682, -0.12967, -0.14029, -0.1496, -0.15787,
	-0.16453, -0.16807, -0.16654, -0.1583, -0.14222, -0.11808, -0.0864, -0.04813, -0.004, 0.0455, 0.10034, 0.16056, 0.22782,
	0.30219, 0.38118, 0.46327, 0.54674, 0.62972, 0.71041, 0.78671,  0.85607, 0.91522, 0.96103, 0.99002, 1., 0.99002, 0.96103,
	0.91522, 0.85607, 0.78671, 0.71044, 0.62972, 0.54674, 0.4633,  0.38118, 0.30216, 0.22782, 0.16056, 0.10034, 0.0455, -0.00397,
	-0.04813, -0.08637, -0.11805, -0.14219, -0.1583, -0.16651, -0.16803, -0.16453, -0.15787, -0.1496, -0.14029, -0.12964,
	-0.11679, -0.10086, -0.08155, -0.05982, -0.03665, -0.01395,  0.00647, 0.02332, 0.03623, 0.04569, 0.05249, 0.05737, 0.06091,
	0.0633, 0.06464, 0.06494, 0.06446, 0.0632, 0.06095, 0.05679, 0.04901, 0.03507},
	"sg_175_100_0",
	{-0.07801, -0.0896, -0.10089, -0.1117, -0.12183, -0.13108, -0.13923, -0.14609, -0.15149, -0.15519, -0.15702, -0.1568, -0.15433, -0.14948, 
	-0.14209, -0.13208, -0.11933, -0.10373, -0.08524, -0.06388, -0.03961, -0.01248, 0.01743, 0.05005, 0.08524, 0.12287, 0.16269, 0.20454, 
	0.24815, 0.29328, 0.33961, 0.38682, 0.43461, 0.48262, 0.53047, 0.57784, 0.62432, 0.66958, 0.71322, 0.75491, 0.79427, 0.83102, 
	0.8648, 0.89532, 0.92236, 0.94565, 0.96496, 0.98019, 0.99118, 0.99777, 1., 0.99777, 0.99118, 0.98019, 0.96496, 0.94565, 0.92236, 
	0.89532, 0.8648, 0.83102, 0.79427, 0.75491, 0.71322, 0.66958, 0.62432, 0.57784, 0.53047, 0.48262, 0.43461, 0.38682, 0.33961, 
	0.29328, 0.24815, 0.20454, 0.16269, 0.12287, 0.08524, 0.05005, 0.01743, -0.01248, -0.03961, -0.06388, -0.08524, -0.10373, -0.11933, 
	-0.13208, -0.14209, -0.14948, -0.15433, -0.1568, -0.15702, -0.15519, -0.15149, -0.14609, -0.13923, -0.13108, -0.12183, -0.1117, -0.10089, -0.0896, -0.07801}
  ]


(* ::Subsubsection::Closed:: *)
(*GetPulseProfile*)


Options[GetPulseProfile] = {MagnetizationVector -> {0, 0, 1}, SliceRange -> 12, SliceRangeSamples -> 25, FatFieldStrength -> 0};

SyntaxInformation[GetPulseProfile] = {"ArgumentsPattern" -> {_, _., OptionsPattern[]}};

GetPulseProfile[ex_?ListQ, ref_?ListQ, opts : OptionsPattern[]] := 
 Module[{exOut, pl1, refOut, pl2, samps},
  samps = OptionValue[SliceRangeSamples];
  {exOut, pl1, sl1} = GetPulseProfile[ex, opts];
  {refOut, pl2, sl2} = GetPulseProfile[ref, opts];
  If[OptionValue[FatFieldStrength] > 0,
  	(*calculate the fat slice shift in mm*)
  	shift = 3.4 OptionValue[FatFieldStrength] 42.5775 (sl1/ex[[3,3]] - sl2/ex[[3,3]]);
  	step = OptionValue[SliceRange]/OptionValue[SliceRangeSamples]/2.;
  	fatShift = Abs[shift/step];
  	{exOut[[6, samps + 1 ;;]], refOut[[6, samps + 1 ;;]], fatShift, {pl1, pl2}}
  	,
  	{exOut[[6, samps + 1 ;;]], refOut[[6, samps + 1 ;;]], {pl1, pl2}} 
  ]
  ]

GetPulseProfile[{name_, flipAnglei_, {gradStrengthi_, durationi_, bandwithi_}}, OptionsPattern[]] := Block[{
	gamma, gradStrength, duration, bandwith, sliceRange, sliceSamp, maxFreq, flipAngle, pos,time,maxt,
	thickness, inM, pulse, pulseSamp, freqRange, deltat, power, output, info, out, slice, opts, plot
	},
	
	(*fixed parameters*)
	gamma = 2 Pi 42.5775 10^6;
	
	(*converrt the inputs *)
	gradStrength = gradStrengthi 10^-3;(*input in mT/m convert to T/m*)
	duration = durationi 10^-3;(*input in ms convert to s*)
	bandwith = N@2 Pi bandwithi;(*is in Hz convert to rad/s*)
	flipAngle = flipAnglei;(*in degree*)
	
	(*get options*)
	inM = OptionValue[MagnetizationVector];
	sliceRange = N@OptionValue[SliceRange]/2 10^-3;(*in mm contert to m, only need to simulate half a slice*)
	sliceSamp = (2*OptionValue[SliceRangeSamples]);(*number of slice samples assume symetry*)
	pos = Range[-sliceRange/2, sliceRange/2, sliceRange/(2*sliceSamp)];
	
	(*Define frequencies*)
	pulse = Pulses[name];
	pulseSamp = Length[pulse] - 1;
  
	(*calculate dependant parameters*)
	thickness = bandwith/(gamma gradStrength);(*in m*)
	slice = 1000 thickness/2;(*in mm*)
	deltat = duration/pulseSamp;
	pos = Position[pulse, Max[pulse]][[1, 1]]-1;
	time = deltat (Range[0, pulseSamp] - pos) 10^3;
	maxt = 1.1 Max[Abs[time]];
	
	(*power optimization to get flip angle*)
 	power = 10.^-6;(*Tesla*)
	power = power flipAngle/BlochSeries[{0, 0, 1}, deltat, 0, power pulse][[6]];
 	
	(*sweep over frequency range, {{feq [kHz],Mt,Mz,Mx,My,ang,phase}}*)
 	maxFreq = gamma gradStrength (sliceRange);
	freqRange = Range[-maxFreq, maxFreq, 2 maxFreq/sliceSamp];
	output = BlochSeries[inM, deltat, freqRange, power pulse];
  
	(*generate info label*)
	info = Grid[{
	    Style[#, Bold] & /@ {"G [mT/m]", "D [ms]", "T [mm]", "\[Gamma]GDT", "power [uT]", "BW [Hz]"},
	    Style[#, Bold] & /@ Round[{1000 gradStrength, 1000 duration, 2 slice, bandwith/2 Pi  thickness, 1000000 power, bandwithi}, .01],
	    {}
	    }, Spacings -> {2, 0.5}];
  
	(*define plot values*)
	out = output;
	out[[All, 1]] = 1000 thickness out[[All, 1]]/bandwith;
	slice = 1000 thickness/2;

	(*make plot grid*)
	opts = {Frame -> True, AxesOrigin -> {0, 0}, FrameStyle -> Thick, Mesh -> False, PlotTheme -> "Monochrome"};
	plot = GraphicsGrid[Transpose@{
		{
			ListLinePlot[Transpose@{time, power pulse 10^6}, PlotRange -> {{-maxt,maxt},({-0.2,.2} + MinMax[pulse]) power 10^6}, PlotLabel -> "RF pulse", Sequence @@ opts],
			ListLinePlot[out[[All, {1, 6}]], PlotRange -> {-25, 190}, GridLines -> {{-slice, slice}, {flipAngle}}, PlotLabel -> "FlipAngle", Sequence @@ opts]
		},{
			ListLinePlot[out[[All, {1, 2}]], PlotRange -> {-.2, 1.1}, GridLines -> {{-slice, slice}, {-1, 1}}, PlotLabel -> "Mt", Sequence @@ opts],
			ListLinePlot[out[[All, {1, 7}]], PlotRange -> {- Pi, Pi}, GridLines -> {{-slice, slice}, {-Pi, Pi}}, PlotLabel -> "Phase", Sequence @@ opts]
		},{
			ListLinePlot[out[[All, {1, 3}]], PlotRange -> {-1.1, 1.1}, GridLines -> {{-slice, slice}, {-1, 0, 1}}, PlotLabel -> "Mz", Sequence @@ opts],
			ListLinePlot[{out[[All, {1, 4}]], out[[All, {1, 5}]]}, PlotRange -> {-1.1, 1.1}, GridLines -> {{-slice, slice}, {-1, 1}}, PlotLabel -> "Mx / My", Sequence @@ opts]
		}
     }, ImageSize -> 800, PlotLabel -> info, LabelStyle -> Black];
     
     (*give full output and plot*)
     {Transpose@output, plot, 2 slice}
  ]


(* ::Subsection::Closed:: *)
(*SimulateSliceEPG*)


Options[SimulateSliceEPG]={ReportFits->False}

SyntaxInformation[SimulateSliceEPG] = {"ArgumentsPattern" -> {_, _,_, OptionsPattern[]}};

SimulateSliceEPG[exitation_, refocus_, {{T1_, T2_}, {Necho_, echoSp_}, b1_}, OptionsPattern[]] := Module[{
   sig, sigTrue, sigT, sigAll, sigInd, len, max, vv, vp, va, sigo, prof,
   info, fit, fitT2, fitT2T, epgT2, epgT2T, lines, plots, te, t2, maxSig
   },
  
  (*define the signals for plotting*)
  sig = EPGSignal[{Necho, echoSp}, {T1, T2}, #, b1] & /@ Transpose[{exitation, refocus}];
  sig = Join[Reverse[sig[[2 ;;]]], sig];
  maxSig = Max[Flatten[sig]];
  sig = sig/maxSig;
  sigT = Mean[sig]/Max[Mean[sig]];
  
  sigTrue = EPGSignal[{Necho, echoSp}, {T1, T2}, {First@exitation, First@refocus}, b1]/maxSig;
  
  sigo = {sigTrue, sigT, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}};
  sigAll = Join[sigo, sig];
  
  sigInd = MapIndexed[Flatten@{#2, #1} &, sigAll, {2}];
  sigInd[[1, All, 1]] = sigInd[[1, All, 1]] /. 1 -> 2;
  len = Length[sigInd];
  max = Max@sigAll;
  
  (*make info tble*)
  info = Grid[{Style[#, Bold] & /@ {"T2 [ms]", "B1 [%]", "echos" , "\[CapitalDelta]TE [ms] "},
     Style[#, Bold] & /@ Round[{T2, 100 b1, Necho, echoSp}, .1]
     }, Spacings -> {2, 0.5}];
  
  fit = If[OptionValue[ReportFits],
	  (*find fits of true and EPG signal*)
	  fitT2 = t2 /. FindFit[Transpose[{echoSp Range[Necho], sigTrue}][[3 ;;]], Exp[-te/t2], {t2}, te];
	  fitT2T = t2 /. FindFit[Transpose[{echoSp Range[Necho], sigT}][[3 ;;]], Exp[-te/t2], {t2}, te];
	  
	  epgT2 = NonLinearEPGFit[{{{Necho, echoSp}, {1400, 365, 135}, {90, 180}}, {5, 80, 0.3}}, sigTrue][[1 ;; 4]];
	  epgT2[[3 ;; 4]] = epgT2[[3 ;; 4]]/Total[epgT2[[3 ;; 4]]];
	  
	  epgT2T = NonLinearEPGFit[{{{Necho, echoSp}, {1400, 365, 135}, {exitation, refocus}}, {5, 80, 0.3}}, sigT][[1 ;; 4]];
	  epgT2T[[3 ;; 4]] = epgT2T[[3 ;; 4]]/Total[epgT2T[[3 ;; 4]]];
	  
	  (*make fit table*)
	  fit = Grid[{Style[#, Bold] & /@ {"lin T2 nor", "lin T2 slice", "{EPG T2 nor, b1, watFr}", "{EPG T2 slice, b1, watFr}"},
	     Style[#, Bold] & /@ Round[{fitT2, fitT2T, {1, 100, 100} epgT2[[1 ;; 3]], {1, 100, 100} epgT2T[[1 ;; 3]]}, .1]
	     }];
	 {" ",fit}    
     ,
     Nothing
  ];
  
  (*make plot*)
  lines = Graphics3D[{Lighter@Gray, Line[{{2, 1, #}, {2, Necho, #}}]} & /@ Range[0, 1.1, .1]];
  prof = Graphics3D[{Lighter@Gray, Thick, Line[sigInd[[Length[sigo];;,1]]]}];
  plots = Table[
  	ParametricPlot3D[sigInd[[m, Round[#]]] &[n], {n, 1, Necho}, 
  	ColorFunction -> "DarkRainbow", ColorFunctionScaling -> False, PlotRange -> Full, PerformanceGoal -> "Speed",PlotPoints->Necho]
  , {m, 2, len, 1}];
  PrependTo[plots, ParametricPlot3D[sigInd[[1, Round[#]]] &[n], {n, 1, Necho}, PlotStyle -> Directive[{Dashed, Darker@Gray}, PlotRange -> Full]]];
  text=Graphics3D[Text[Style["Mean signal (colored line)\nMid slice signal (gray line)", Bold, Black], {0, 0.5 Necho, 1.3 max}]];
  vv = {0.24, 0.19, 0.95};
  vp = {2.57, 1.90, 1.08};
  va = 35 Degree;
  (*Column[Flatten@{
    "  ", info, fit,*)
    Show[plots, lines, prof, (*text,*) BoxRatios -> 1, PlotRange -> {{0, len}, {0, Necho}, {-0., 1.1 max}}, 
     BoxStyle -> Directive[{Thick, Black}], SphericalRegion -> True, ViewVertical -> vv, ViewPoint -> vp, 
     ViewAngle -> va, ImageSize -> 400,FrameLabel->{}, 
     Axes -> True, (*AxesLabel -> {"Slice Profile", "Nr. echos", "Normalized\nSignal"},*) 
     AxesEdge -> {{1, -1}, {1, -1}, {1, -1}},
     Ticks -> False, LabelStyle -> Directive[{Bold, Black}]]
    (*}, Alignment -> Center, Spacings -> 0]*)
  ]


(* ::Subsection::Closed:: *)
(*GfactorSimulation*)


Options[GfactorSimulation] = {GRegularization -> 0., GOutput -> "Grid"};

SyntaxInformation[GfactorSimulation] = {"ArgumentsPattern" -> {_, _, _, _., _., OptionsPattern[]}};

GfactorSimulation[sensitivity_, W_, {dir1_, sensea_?ListQ}, opts : OptionsPattern[]] := GfactorSimulation[sensitivity, W, 0, {dir1, sensea}, {"", {0}}, opts]

GfactorSimulation[sensitivity_, W_, {dir1_, sensea_?ListQ}, {dir2_, senseb_?ListQ}, opts:OptionsPattern[]]:= GfactorSimulation[sensitivity, W, 0, {dir1, sensea}, {dir2, senseb}, opts]

GfactorSimulation[sensitivity_, W_, mask_, {dir1_, sensea_?ListQ}, opts : OptionsPattern[]] := GfactorSimulation[sensitivity, W, mask, {dir1, sensea}, {"", {0}}, opts]

GfactorSimulation[sensitivity_, W_, mask_, {dir1_, sensea_?ListQ}, {dir2_, senseb_?ListQ}, OptionsPattern[]] := Block[{
   dir, dim, factors, gfactorsAX, gfactorsCOR, gfactorsSAG, lambda, sense1, sense2, sense3, nn, gfactors, reg},
  
  (*get the sense factor and directions*)
  dir = {{dir1, sensea}, {dir2, senseb}};
  {sense1, sense2} = dir[[All, 2]];
  dir = dir[[All, 1]];
  reg = OptionValue[GRegularization];
  
  (*generate all the sense factor lists*)
  factors = Switch[dir,
  	(*one directions*)
    {"FH",""}, Table[{i, 1, 1}, {i, sense2}],
    {"AP",""}, Table[{1, i, 1}, {i, sense2}],
    {"LR",""}, Table[{1, 1, i}, {i, sense2}],
    
    {"FH", "LR"}, Flatten[Table[{i, 1, j}, {i, sense1}, {j, sense2}], 1],
    {"LR", "FH"}, Flatten[Table[{i, 1, j}, {j, sense2}, {i, sense1}], 1],
    
    {"AP", "LR"}, Flatten[Table[{1, i, j}, {i, sense1}, {j, sense2}], 1],
    {"LR", "AP"}, Flatten[Table[{1, i, j}, {j, sense2}, {i, sense1}], 1],
    
    {"AP", "FH"}, Flatten[Table[{j, i, 1}, {i, sense1}, {j, sense2}], 1],
    {"FH", "AP"}, Flatten[Table[{j, i, 1}, {j, sense2}, {i, sense1}], 1]
    ];
  
  (*perform the gfactor calculations*)
  gfactors = CalculateGfactori[factors, sensitivity, W, mask, GRegularization -> reg];
  
  (*output the gfactor*)
  If[OptionValue[GOutput] === "Grid", GridData3D[gfactors,Length[sense2]], {gfactors, factors}]
  ]


(* ::Subsection::Closed:: *)
(*CalculateGfactor*)


Options[CalculateGfactor] = {GRegularization -> 0.};

SyntaxInformation[CalculateGfactor] = {"ArgumentsPattern" -> {_, _, _, _., OptionsPattern[]}}

CalculateGfactor[factors_, sensitivity_, Wmat_, opts:OptionsPattern[]] := CalculateGfactori[factors, sensitivity, Wmat, 0, opts]

CalculateGfactor[factors_, sensitivity_, Wmat_, mask_, opts:OptionsPattern[]] := CalculateGfactori[factors, sensitivity, Wmat, mask, opts]


Options[CalculateGfactori] = Options[CalculateGfactor];

CalculateGfactori[factorsi_, sensitivity_, Wmat_, maski_, OptionsPattern[]] := Block[{
	dim,lambda,listQ,factors,ii,sens,Wmati,gfactors,factor,Rmat,usVal,
	FOVux,FOVuy,FOVuz, fcorx, fcory,fcorz, usf, FOVu,shft,FOVf,R,FOV,
	fcors,corsG,Smat,mat,pmat,gfac,gfactor,mask,gmask
	},
	
	(*get parameters*)
	dim = Drop[Dimensions[sensitivity], 1];
	lambda = OptionValue[GRegularization];
	listQ = VectorQ[factorsi];
	(*DistributeDefinitions[lambda, dim, sensitivity, Wmat];*)
	factors = If[listQ, {factorsi}, factorsi];
	ii = 0;
	
	mask = If[maski=!=0, maski, Mask[Total@Abs@sensitivity, .001]];
	
	(*define the sensitivity and regularization mat*)
	sens = RotateDimensionsLeft[sensitivity];
	Wmati = Inverse[Wmat];
	
	DistributeDefinitions[factors, UsFactor, dim, lambda, Wmat];

	(*loop over all the factors*)
	gfactors = Monitor[
		Table[(
			factor = factors[[f]];
			Rmat = lambda^2 IdentityMatrix[Times @@ factor];
			(*get the undersample factors*)
			usVal = Transpose[UsFactor[dim, factor]];
			{FOVux, FOVuy, FOVuz} = usVal[[All, 2]];
			(*get all the indexes for x y and z*)
			{fcorx, fcory, fcorz} = Table[
				{usf, FOVu, shft, FOVf, R} = usVal[[c]];
				FOV = dim[[c]];
				(*get the folded x,y and z indexes*)
				Table[Ceiling[If[! (FOV < # <= FOVf), If[# > FOV, # - FOVf, #], FOV] & /@ (cor + FOVu*Range[0, R - 1] + shft)], {cor, FOVu}]
			, {c, 1, 3}];
			(*map the indexes to coordinates*)
			fcors = Flatten[Table[Flatten[Table[{i, j, k}, {i, fcorx[[x]]}, {j, fcory[[y]]}, {k, fcorz[[z]]}], 2], {x, FOVux}, {y, FOVuy}, {z, FOVuz}], 2];
			(*Calculate the gfactors*)
			corsG = Map[(
		        Smat = Transpose[Extract[sens, #]];
		        mat = ConjugateTranspose[Smat].Wmati.Smat;
		        pmat = PseudoInverse[mat + Rmat];
		        gfac = Abs[Sqrt[Diagonal[pmat] Diagonal[mat]]]
		    ) &, fcors];
		    (*map the gfactors to 3D volume*)
		    gfactor = ConstantArray[-1, dim];
		    MapThread[(gfactor[[#1[[1]], #1[[2]], #1[[3]]]] = #2) &, {fcors, corsG}, 2];
		    
		    (*calculate 1/g and clip between 0 and 1 and apply mask*)
		    gfactor = Clip[DevideNoZero[1,gfactor], {0,1}];
		    ToPackedArray[N[(mask gfactor) - (1.-mask)/10]]
		    
		), {f,1,Length[factors]}], 
	Row[{Dynamic[factor],ProgressIndicator[f,{0,Length[factors]}]}]];
		
	If[listQ, gfactors[[1]], gfactors]
]


UsFactor[dim_, R_] := Block[{usdim, Rus, shift},
  usdim = Ceiling[dim/R];
  Rus = N[dim/usdim];
  shift = (dim/2) - dim/(2 Rus);
  {Rus, usdim, shift, R*usdim, R}
  ]


(* ::Subsection::Closed:: *)
(*SimParameters*)


Options[SimParameters]={Reject->False}

SyntaxInformation[SimParameters] = {"ArgumentsPattern" -> {_, OptionsPattern[]}};

SimParameters[tens_,OptionsPattern[]]:=
Module[{eig,ADC,FA,dataAll,rangy,bins,wbins,sol,fit,x,Omega,Xi,Alpha},
	(
		Off[NonlinearModelFit::"cvmit"];
		Off[NonlinearModelFit::"sszero"];
		eig=1000 EigenvalCalc[#,Reject->OptionValue[Reject],MonitorCalc->False];
		ADC=ADCCalc[eig];
		FA=FACalc[eig];
		dataAll=DeleteCases[DeleteCases[Flatten[#],0],0.]&/@{eig[[All,All,1]],eig[[All,All,2]],eig[[All,All,3]],ADC,FA};
		rangy={{0,3},{0,3},{0,3},{0,3},{0,1}};
		bins=MapThread[{Range[#2[[1]]+.5(#2[[2]]/50),#2[[2]],#2[[2]]/50],BinCounts[#1,{#2[[1]],#2[[2]],#2[[2]]/50}]}&,{dataAll,rangy}];
		wbins=Transpose/@MapThread[{#1[[1]],(#1[[2]]/Length[#3])/(#2[[2]]/100)}&,{bins,rangy,dataAll}];
		sol=NonlinearModelFit[FitData[#],SkewNorm[x,Omega,Xi,Alpha],{Omega,Xi,Alpha},x,Gradient->"FiniteDifference"]&/@dataAll;
		fit=Append[ParameterFit[#]&/@dataAll,{Length[dataAll[[1]]]}];
		{dataAll,wbins,sol,fit}
		)&/@tens
	]


(* ::Subsection::Closed:: *)
(*AngleParameters*)


SyntaxInformation[SimAngleParameters] = {"ArgumentsPattern" -> {_, _}};

SimAngleParameters[tens_,veci_]:=
Module[{bins,surface,wbins,fit,par,vec,ang,x,Theta},
	surface=N[Table[( Cos[(x-1) Degree]- Cos[x Degree]),{x,1,90,1}]];
	(
		vec=EigenvecCalc[#,MonitorCalc->False];
		ang=AngleCalc[vec[[All,All,#]],veci[[#]],Distribution->"0-90"]&/@{1,2,3};
		bins=Map[BinCounts[DeleteCases[Flatten[#],0.],{0,90,1}]&,ang];
		wbins=Map[{#/Total[#],#/surface/Total[#/surface]}&,bins];
		fit=Map[NonlinearModelFit[#[[2]],HalfNorm[x,Theta],{Theta},x,Gradient->"FiniteDifference"]&,wbins];
		par=Map[({Theta}/.#["BestFitParameters"])[[1]]&,fit];
		{ang,wbins,fit,par}
		)&/@tens
	]


(* ::Subsection:: *)
(*Plot Simulation*)


(* ::Subsubsection::Closed:: *)
(*Definitions*)


sizes={200,300,400,500,750,1000,1500,2000,2500,3000};
files={".pdf",".jpg",".gif",".tif",".png"};

labStyle = Directive[Bold,FontFamily->"Helvetica",14,Black];
unit = " [\!\(\*SuperscriptBox[\(10\), \(-3\)]\) \!\(\*SuperscriptBox[\(mm\), \(2\)]\)/s]";
lambda[x_] :="\!\(\*SubscriptBox[\"\[Lambda]\", \"" <> ToString[x] <> "\"]\)";
epsilon[x_] := "\!\(\*SubscriptBox[\(\[CurlyEpsilon]\), \"" <> ToString[x] <> "\"]\)"

Phi[x_]:=1/(E^(x^2/2)*Sqrt[2*Pi]);
CapitalPhi[x_]:=.5(1+Erf[(x)/Sqrt[2]]);
SkewNorm[x_,Omega_,Xi_,Alpha_]:=(2/Omega)Phi[(x-Xi)/Omega]CapitalPhi[Alpha (x-Xi)/Omega];

HalfNorm[x_,Theta_]:=PDF[HalfNormalDistribution[Theta],x]


(* ::Subsubsection::Closed:: *)
(*PlotSimulationHist*)


SyntaxInformation[PlotSimulationHist] = {"ArgumentsPattern" -> {_, _, _, _}};

PlotSimulationHist[pars_,label_,xdata_,tr_]:=
DynamicModule[{rangy,xlabel,exp},
	rangy={{0,3},{0,3},{0,3},{0,3},{0,1}};
	xlabel={lambda[1]<>unit, lambda[2]<>unit, lambda[3]<>unit, "MD"<>unit, "FA [-]"};
	Manipulate[
		If[!ListQ[pars]||!ListQ[rangy],
			Return[],
			exp=GraphicsRow[(Show[
				Histogram[Flatten[pars[[y,1,#]]],{rangy[[#,2]]/50},"ProbabilityDensity",PlotRange->{rangy[[#]],{0,1.1Max[pars[[y,2,#,All,2]]]}},
				PerformanceGoal->"Speed",AxesOrigin->{0,0},LabelStyle->labStyle,
				FrameLabel->{xlabel[[#]],"Probability density"},Axes->False,FrameStyle->Thick,Frame->{True,True,False,False},ChartBaseStyle->EdgeForm[{Thin,White}],ChartStyle->Gray],
				ListPlot[pars[[y,2,#]],Joined->True,PlotStyle->{Thick,Black},PlotRange->{rangy[[#]],{0,1.1Max[pars[[y,2,#,All,2]]]}}],
				Plot[pars[[y,3,#]][x],{x,rangy[[#,1]],rangy[[#,2]]},PlotStyle->{Thick,Red},PlotRange->{rangy[[#]],{0,1.1Max[pars[[y,2,#,All,2]]]}}],
				ListLinePlot[{{tr[[#]],0},{tr[[#]],1.1Max[pars[[y,2,#,All,2]]]}},PlotStyle->Directive[Thick,Black,Dashed]]
				]&/@{1,2,3,4,5})[[xx]],ImageSize->Length[xx]*400,PlotLabel->Style[label<>"  -  "<>ToString[xdata[[y]]],16],LabelStyle->labStyle]
			]
		,
			{{xx,{1,2,3},"Parameter"},{{1,2,3}->"eigenvalues",{4,5}->"MD\\FA"}},
			{{y,1,"Simulation Value"},1,Length[pars],1},
			Button["Export Plot To File",FileSave[Dynamic[exp],"jpg",2000],Method->"Queued"],
			{{size, 500, "Export Size"}, sizes}, 
			{{file, ".jpg","File Type"}, files},
		SaveDefinitions->True
		]
	]


(* ::Subsubsection::Closed:: *)
(*PlotSimulation*)


Options[PlotSimulation]={PlotRange->{{0,3},{0,3},{0,3},{0,3},{0,1}}};

SyntaxInformation[PlotSimulation] = {"ArgumentsPattern" -> {_, _, _, _, _, OptionsPattern[]}};

PlotSimulation[pars_,xval_,tr_,label_,color_,OptionsPattern[]]:=
Module[{pl,dat,err,rangx,rangy,ylabel,truey,off},

	off=0.025(Max[xval]-Min[xval]);
	rangx={Min[xval]-off,Max[xval]+off};
	rangy=OptionValue[PlotRange];
	ylabel={lambda[1]<>unit, lambda[2]<>unit, lambda[3]<>unit, "MD"<>unit, "FA [-]"};
	pl=(
	truey=ConstantArray[tr[[#]],{Length[xval]}];
	dat=pars[[All,4,#,1]];
	err=If[Length[pars[[1,4,#]]]==2,pars[[All,4,#,2]],0];
	ListLinePlot[
		{Transpose[{xval,truey}],Transpose[{xval,dat}],Transpose[{xval,dat-err}],Transpose[{xval,dat+err}]},
		Filling->{3->{4}},FillingStyle->Directive[Opacity[0.1],color],FrameTicks->{xval,Automatic},PlotMarkers->{"",{"\[FilledSmallCircle]",15},{"\[UpPointer]",15},{"\[DownPointer]",15}},
		PlotStyle->{Directive[Gray,Thick,Dashing[Medium]],Directive[color,Thick],Directive[color,Thin,Dashing[Medium]],Directive[color,Thin,Dashing[Medium]]},
		PlotRange->{rangx,rangy[[#]]},
		LabelStyle->labStyle,FrameLabel->{label,ylabel[[#]]},Axes->False,FrameStyle->Thick,Frame->{True,True,False,False}
		]
	)&/@{1,2,3,4,5};
	GraphicsGrid[Partition[pl, 3, 3, 1, {}], ImageSize -> 1200]
	]


(* ::Subsubsection::Closed:: *)
(*PlotSimulationAngleHist*)


SyntaxInformation[PlotSimulationAngleHist] = {"ArgumentsPattern" -> {_, _, _}};

PlotSimulationAngleHist[pars_,label_,xdata_]:=
Module[{exp},
	Manipulate[
		If[!ListQ[pars],
			Return[],
			exp=GraphicsRow[
				Show[
					Histogram[Flatten[pars[[y,1,#]]],{1},"ProbabilityDensity",PlotRange->{{0,90},{0,1.1Max[pars[[y,2,#]]]}},PerformanceGoal->"Speed",LabelStyle->labStyle,
					FrameLabel->{"Error "<>epsilon[#]<>" [\[Degree]]","Probability density"},
					Axes->False,FrameStyle->Thick,Frame->{True,True,False,False},ChartBaseStyle->EdgeForm[{Thin,White}],ChartStyle->Gray],
					ListPlot[pars[[y,2,#,1]],Joined->True,PlotStyle->{Thick,Darker[Gray]},PlotRange->{{0,90},{0,1.1Max[pars[[y,2,#]]]}}],
					ListPlot[pars[[y,2,#,2]],Joined->True,PlotStyle->{Thick,Black},PlotRange->{{0,90},{0,1.1Max[pars[[y,2,#]]]}}],
					Plot[pars[[y,3,#]][x],{x,1,90},PlotStyle->{Thick,Red},PlotRange->{{0,90},{0,1.1Max[pars[[y,2,#]]]}}]
					]&/@{1,2,3}
				,ImageSize->1200,LabelStyle->labStyle,PlotLabel->Style[label<>" - "<>ToString[xdata[[y]]],16]]
			]
		,{{y,1,"Simulation Value"},1,Length[pars],1},
		Button["Export Plot To File",FileSave[Dynamic[exp],"jpg",2000],Method->"Queued"],
		{{size, 500, "Export Size"}, sizes}, {{file, ".jpg","File Type"}, files},
		SaveDefinitions->True
		]
	]


(* ::Subsubsection::Closed:: *)
(*PlotSimulationAngle*)


Options[PlotSimulationAngle]={PlotRange->{0,90}}

SyntaxInformation[PlotSimulationAngleHist] = {"ArgumentsPattern" -> {_, _, _, _, _., OptionsPattern[]}};

PlotSimulationAngle[par_, xdata_, label_, col_, OptionsPattern[]]:=
PlotSimulationAngle[par, xdata, label, col, {.25,.5,.95}, PlotRange->OptionValue[PlotRange]]

PlotSimulationAngle[par_, xdata_, label_, col_, quantinp_, OptionsPattern[]] := 
Module[{quant,pars=Transpose[par[[All,4]]],e,pdat,xrange,off},
	off=0.025(Max[xdata]-Min[xdata]);
	xrange = {Min[xdata]-off,Max[xdata]+off};
	GraphicsRow[(
    e = #;
    pdat = (
        quant = #;
        Transpose[{xdata, 
          Quantile[HalfNormalDistribution[#], quant] & /@ pars[[e]]}]
        ) & /@ quantinp;
    ListLinePlot[pdat,
     PlotStyle -> {Directive[col, Thick], 
       Directive[col, Thick, Dashing[Large]], 
       Directive[col, Thick, Dashing[Medium]], 
       Directive[col, Thick, Dashing[Small]], 
       Directive[col, Thick, Dashing[Tiny]]},
     FrameTicks->{xdata,Automatic},
     LabelStyle -> labStyle,
     PlotMarkers -> {"\[FilledSmallCircle]", 14},
     PlotRange -> {xrange,OptionValue[PlotRange]},
     FrameLabel -> {label, "Error "<>epsilon[#]<>" [\[Degree]]"}, Axes -> False,
     FrameStyle -> Thick,
     FrameTicks -> {Automatic, {0, 15, 30, 45, 60, 75, 90}},
     Frame -> {True, True, False, False}]
    ) & /@ {1, 2, 3}
 , ImageSize -> 1000, Spacings -> 0]
]


(* ::Subsubsection::Closed:: *)
(*PlotSimulationVec*)


Options[PlotSimulationVec]={SortVecs->True}

SyntaxInformation[PlotSimulationVec] = {"ArgumentsPattern" -> {_, _, _, OptionsPattern[]}};

PlotSimulationVec[tens_, xdata_, label_, OptionsPattern[]] := Module[
  {eigvm, eigvcm, arrows1, arrows2, arrows3, vp1, vp2, vp3, 
   va1, va2, va3, vv1, vv2, vv3, data, exp, xd},
  
  eigvm = Flatten[EigenvecCalc[#,MonitorCalc->False], 1] & /@ tens;
  
  eigvcm =If[OptionValue[SortVecs],
  Map[(
      {
       RandomReal[NormalDistribution[1.025, .025]] If[
         Negative[#[[1, 3]]], {1, -1, -1}, {1, -1, 1}]*#[[1]],
       RandomReal[NormalDistribution[1.025, .025]] If[
         Negative[#[[2, 2]]], {1, 1, 1}, {1, -1, 1}]*#[[2]],
       RandomReal[NormalDistribution[1.025, .025]] If[
         Negative[#[[3, 1]]], {-1, -1, 1}, {1, -1, 1}]*#[[3]]
       }
      ) &, eigvm, {2}]
  ,
  eigvm
  ];
  
  arrows1 = Graphics3D[
    {{Darker[Blue], Arrowheads[0.05], 
      Arrow[Tube[{{-1, 1, 0.5}, {-1, 1, 1}}, 0.025]]},
     {Darker[Red], Arrowheads[0.05], 
      Arrow[Tube[{{-1, 1, 0.5}, {-1, .5, 0.5}}, 0.025]]},
     {Darker[Green], Arrowheads[0.05], 
      Arrow[Tube[{{-1, 1, 0.5}, {-.5, 1, 0.5}}, 0.025]]
      }}];
  arrows2 = Graphics3D[{
     {Darker[Blue], Arrowheads[0.05], 
      Arrow[Tube[{{-1, -.5, -1}, {-1, -.5, -.5}}, 0.025]]},
     {Darker[Red], Arrowheads[0.05], 
      Arrow[Tube[{{-1, -.5, -1}, {-1, -1, -1}}, 0.025]]},
     {Darker[Green], Arrowheads[0.05], 
      Arrow[Tube[{{-1, -.5, -1}, {-.5, -.5, -1}}, 0.025]]
      }}];
  arrows3 = Graphics3D[{
     {Darker[Blue], Arrowheads[0.05], 
      Arrow[Tube[{{.5, 1, -1}, {.5, 1, -.5}}, 0.025]]},
     {Darker[Red], Arrowheads[0.05], 
      Arrow[Tube[{{.5, 1, -1}, {.5, .5, -1}}, 0.025]]},
     {Darker[Green], Arrowheads[0.05], 
      Arrow[Tube[{{.5, 1, -1}, {1, 1, -1}}, 0.025]]
      }}];
    
  vp1 = {0.426945, -0.474858, 3.32298}; 
  vv1 = {0.0421748, -0.881393, 0.470498}; va1 = 25 Degree;
  (*{Dynamic[vp1],Dynamic[vv1],Dynamic[va1]}*)
  vp2 = {0.429321, -3.30821, 0.56695}; 
  vv2 = {0.058434, -0.443718, 0.894259}; va2 = 25 Degree;
  (*{Dynamic[vp2],Dynamic[vv2],Dynamic[va2]}*)
  vp3 = {3.1877, 0.899157, 0.692886}; 
  vv3 = {0.416537, 0.112532, 0.902127}; va3 = 25 Degree;
  (*{Dynamic[vp3],Dynamic[vv3],Dynamic[va3]}*)

  Manipulate[
  	If[!ListQ[eigvcm],Return[],
	   data = eigvcm[[set]] // Transpose;
	   xd = xdata[[set]];
	      
	   exp = GraphicsRow[{
	      EigPlot[data, vp1, vv1, va1, arrows1, 1], 
	      EigPlot[data, vp2, vv2, va2, arrows2, 2], 
	      EigPlot[data, vp3, vv3, va3, arrows3, 3]
	      }, 
	      ImageSize -> {1000}, Spacings -> 0,
	      PlotLabel-> Style[label <> " - " <>ToString[xdata[[set]]],18],
	      LabelStyle -> labStyle
      ]
  	]
   ,
   {{set, 1, "Simulation Value"}, 1, Length[xdata], 1},
   Button["Export Plot To File", FileSave[exp, "jpg", 2000], Method -> "Queued"],
   {{size, 500, "Export Size"}, sizes}, {{file, ".jpg","File Type"}, files},
   SaveDefinitions->True
   ]
  ]


(* ::Subsubsection::Closed:: *)
(*EigPlot*)


EigPlot[data_, vp_, vv_, va_, arrows_, val_] := Module[{sphere,line},
	 sphere = SphericalPlot3D[.975, {Theta, 0, Pi}, {Phi, 0, 2 Pi}, Lighting -> "Neutral"];
	 line = ParametricPlot3D[{{Sin[u], 0, Cos[u]}, -{0, Sin[u], Cos[u]}}, {u, -Pi, Pi},
	 	PlotStyle -> {Directive[Dashed, Thickness[.0125], Darker[Green]], Directive[Dashed, Thickness[.0125], Darker[Red]]}
	 	];
	 	Show[
	 		ListPointPlot3D[data, 
	 			ViewPoint -> vp, ViewVertical -> vv, ViewAngle -> va,
	 			PlotLabel -> {"First", "Second", "Third"}[[val]]<>" eigenvector",
	 			PlotRange -> {{-1.1, 1.1}, {-1.1, 1.1}, {-1.1, 1.1}}, 
			   BoxRatios -> 1, PlotStyle -> {Darker[Blue], Darker[Red], Darker[Green]}, 
			   Lighting -> "Neutral", Axes -> False, Boxed -> False, 
			   SphericalRegion -> True, 
			   LabelStyle -> labStyle
	 			], arrows, sphere, line
	 			]
    		];


(* ::Subsubsection::Closed:: *)
(*GESignal*)


GESignal[ang_?ListQ, {tr_, t1_}] := Transpose[GESignal[#, {tr, t1}] & /@ ang]
GESignal[ang_?NumberQ, {tr_, t1_}] := Block[{e1, a},
	a = ang Degree;
	e1 = Exp[-tr/t1];
	Sin[a] (1 - e1)/(1 - Cos[a] e1)
];


GESignal[ang_?ListQ, {{tr1_, tr2_}, t1_}] := Transpose[GESignal[#, {{tr1, tr2}, t1}] & /@ ang]
GESignal[ang_?NumberQ, {{tr1_, tr2_}, t1_}] := Block[{a, e1, e2, s1, s2},
	a = N[ang Degree];
	e1 = Exp[-tr1/t1];
	e2 = Exp[-tr2/t1];
	s1 = Sin[a] (1 - e2 + (1 - e1) e2 Cos[a])/(1 - e1 e2 (Cos[a])^2);
	s2 = Sin[a] (1 - e1 + (1 - e2) e1 Cos[a])/(1 - e1 e2 (Cos[a])^2);
	{s1, s2}
]




(* ::Subsubsection::Closed:: *)
(*SimulateDualTR*)


SimulateDualTR[T1_ : 6000] := Manipulate[
	{s1, s2} = GESignal[ang, {{tr1, n tr1}, T1}]/0.35;
	s2a = Abs[s2];
	p1=s1[[Round[fa]]];
	p2=s2a[[Round[fa]]];
	Column[{
		Row[{
			ListLinePlot[{s1, s2a}, PlotRange -> If[! r, Full, {-0, 1}], ImageSize -> 350, PlotStyle -> (Directive[{Thick, #}] & /@ {Black, Red}),
				AxesStyle -> Directive[{Thick, Black}], LabelStyle -> Directive[Bold, 14, Black], PlotLabel -> "Signal as function of flipangle",
				GridLines -> {{fa}, {p1, p2}},
				Epilog -> {PointSize[Large], Black, Point[{fa, p1}], Red, Point[{fa, p2}]}],
			ListLinePlot[s2a/s1, PlotRange -> {0, 1.1}, ImageSize -> 350, PlotStyle -> Directive[{Black, Thick}], 
				AxesStyle -> Directive[{Thick, Black}], LabelStyle -> Directive[Bold, 14, Black], PlotLabel -> "Signal ratio as function of flipangle",
				GridLines -> {{fa}, {p2/p1}},
				Epilog -> {PointSize[Large], Black, Point[{fa, p2/p1}]}]
			}, "         "],"",
		Style["TR1: " <> ToString[tr1] <> " ms  -  TR2: " <> ToString[n tr1] <>" ms  -  Total time: " <> ToString[tr1 + n tr1] <> " ms", Bold, 14, Black, FontFamily -> "Helvetica"], "",
		Style["max. sig: " <> ToString[Round[Max[s1], .01]] <> "  -  sig per unit time: " <> ToString[Round[1000 Max[s1]/(tr1 + n tr1), .01]], Bold, 14, Black, FontFamily -> "Helvetica"], "",
		Style["sig per unit time at FA  - s1: " <> ToString[Round[1000 p1/(tr1 + n tr1), .01]]<>"  -  s2: "<>ToString[Round[1000 p2/(tr1 + n tr1), .01]], Bold, 14, Black, FontFamily -> "Helvetica"]
	}, Alignment -> Center]
	, {{tr1, 50, "first TR"}, 10, 100, 10, ControlType -> Manipulator}
	, {{n, 19, "TR ratio"}, 2, 20, 1, ControlType -> Manipulator}
	, {{fa, 60, "flip angle"}, ang, ControlType -> Manipulator}
	, {{r, True, "fix scale"}, {True, False}}
	, {ang, ControlType -> None}
	, {s1, ControlType -> None}
	, {s2, ControlType -> None}
	, {s2a, ControlType -> None}
	, {p1, ControlType -> None}
	, {p2, ControlType -> None}
	, Initialization :> (ang = Range[1, 180])
]


(* ::Section:: *)
(*End Package*)


End[]

EndPackage[]
