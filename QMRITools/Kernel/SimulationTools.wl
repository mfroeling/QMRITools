(* ::Package:: *)

(* ::Title:: *)
(*QMRITools SimulationTools*)


(* ::Subtitle:: *)
(*Written by: Martijn Froeling, PhD*)
(*m.froeling@gmail.com*)


(* ::Section:: *)
(*Begin Package*)


BeginPackage["QMRITools`SimulationTools`", Join[{"Developer`"}, Complement[QMRITools`$Contexts, {"QMRITools`SimulationTools`"}]]];


(* ::Section:: *)
(*Usage Notes*)


(* ::Subsection::Closed:: *)
(*Functions*)


AddNoise::usage = 
"AddNoise[data, noise] ads rician noise to the data with a given sigma or SNR value."

Tensor::usage = 
"Tensor[{l1, l2, l3}] creates a diffusion tensor with vectors {{0,0,1},{0,1,0},{1,0,0}} and eigenvalues {l1, l2, l3}.
Tensor[{l1, l2, l3}, {e1, e2, e3}] creates a diffusion tensor with vectors {e1, e2, e3} and eigenvalues {l1, l2, l3}.
Tensor[{l1, l2, l3}, \"Random\"] creates a diffusion tensor with random orthogonal eigenvectors {e1, e2, e2} and eigenvalues {l1, l2, l3}.
Tensor[{l1, l2, l3}, \"RandomZ\"] creates a diffusion tensor with random orthogonal eigenvectors {{1,0,0}, e2, e3} with random eigenvectors and eigenvalues {l1, l2, l3}.
Tensor[{l1, l2, l3}, \"OrtRandom\"] creates a diffusion tensor with random orthogonal eigenvectors {{1,0,0},{0,1,0},{0,0,1}} and eigenvalues {l1, l2, l3}.
Tensor[] is based on DOI: 10.1002/nbm.2959."

Signal::usage = 
"Signal[par, tr, te] calculates the MRI signal at a given tr and te. Par is defineds as {pd, t1, t2}."

CreateDiffData::usage = 
"CreateDiffData[sig, eig, bvec, gradients, dim] creates a DTI datasets of dimensions dim with sig as unweighted signal s0 and bvec and gradients. 
eig can be {l1, l2, l3}, {{l1, l2, l3}, {e1, e2, e3}}, {{l1, l2, l3}, \"Random\"}, {{l1, l2, l3}, \"RandomZ\"} or {{l1, l2, l3}, \"OrtRandom\"}. 
Uses Tensor internally.

CreateDiffData[] is based on DOI: 10.1002/nbm.2959."

BlochSeries::usage = 
"BlochSeries[vectorIn, deltat, freqRange, B1] performs a Bloch simulation of an RF pulse."

Pulses::usage = 
"Pulses[name] gives the pulse shape of some predefinec Philips pulse shapes."

GetPulseProfile::usage = 
"GetPulseProfile[excitation, refocus] gives the pusl angle profiles for the exitation and refocusing pulses.
a pulse is defined as {\"name\", flipangle, {G_strnth, Dur, BW}}.
GetPulseProfile[{\"name\", flipangle, {G_strnth, Dur, BW}}] gives detaile slice profile information of one pulse.

output is {ex_angle_profiel, ref_angel_profile, {plots}}.
output for single pulse is {{distance, Mt, Mz, Mx, My, ang, phase}, plots}."

SimulateSliceEPG::usage = 
"SimulateSliceEPG[exitation, refocus, {{t1, t2}, {nEcho, echoSp}, b1}] gives a simulated slice profile and EPG singnal plot.
exitation and refocus are generated by GetPulseProfiel."

CalculateGfactor::usage = 
"CalculateGfactor[factors, sensitivity, wMat] calculates a gfactor for given sensitivity maps and noise corraltion w. given the sense factors which is a list of three integers."

GfactorSimulation::usage = 
"GfactorSimulation[sensitivity, cov, {dir,sense}] calculates the gfactormaps for given sensitivity maps and noise corraltion cov in one direction. 
The sensefactors are a list of integers in a given direction: \"LR\", \"FH\", or \"AP\".
GfactorSimulation[sensitivity, cov, {dir1,sense1}, {dir2,sense2}] calculates the gfactormaps for given sensitivity maps and noise corraltion w in two directions."

SimParameters::usage = 
"SimParameters[tens] calculates the diffusion parameters for tens. The output can be used in PlotSimulationHist and PlotSimulation."

PlotSimulationHist::usage = 
"PlotSimulationHist[pars, label, xdata, tr] plots the pars (output form Parameters). 
Using label as plotlabel and xdata as x axis label. tr are the true parameter values."

PlotSimulation::usage = 
"PlotSimulation[pars, xval, true, label, color] plots the pars (output form Parameters). Using label as PlotLabel and xval as x axis Thics.
tr are the true parameter values. color are the color used for the plot."

SimAngleParameters::usage = 
"SimAngleParameters[tens,vec] calculates the diffusion eigenvectors for tens compared to the true values vec. 
The output can be used in PlotSimulationAngleHist and PlotSimulationAngle."

PlotSimulationAngleHist::usage = 
"PlotSimulationAngleHist[pars, label, xdata] plots pars (output from Anlge Parameters)."

PlotSimulationAngle::usage = 
"PlotSimulationAngle[par, xdata, label, col] plots pars (output from Anlge Parameters)."

PlotSimulationVec::usage =
"PlotSimulationVec[tens, xdata, label] plots the eigenvectors from simulated tensors."

GESignal::usage = 
"GESignal[ang, {tr, t1}] calculates the gradient echo signal for flipangles ang using tr and t1. 
GESignal[ang_?ListQ, {{tr1_, tr2_}, t1_}] calculates the dual tr gradient echo signal for flipangles ang using tr1, tr2 and t1."

SimulateDualTR::usage =
"SimulateDualTR[] simulates the signal of a Dual tr t1 map."

ErnstAngle::usage = 
"ErnstAngle[] shows Ernst angle plot for t1 = 1400ms and tr = 15 ms.
ErnstAngle[t1] shows Ernst angle plot for t1 and tr = 15 ms.
ErnstAngle[t1, tr] shows Ernst angle plot for t1 and tr." 


(* ::Subsection::Closed:: *)
(*Options*)


NoiseSize::usage = 
"NoiseSize is an option for AddNoise. Values can be \"Sigma\", then the noise sigma is given or \"SNR\", then the SNR is given."

NoiseType::usage = 
"NoiseType is an option for AddNoise. Values can be \"Absolute\" or \"Complex\", and will add either Rician absolute noise or complex noise to the data."

TensOutput::usage = 
"TensOutput is an option for Tensor. Values can be \"Vector\" or \"Matrix\"."

SortVecs::usage = 
"SortVecs is an option for PlotSimulationVec."

MagnetizationVector::usage =
"MagnetizationVector is an option for GetPulseProfile. It defines the start magnetization vector for the bloch simulation."

SliceRange::usage =
"SliceRange is an option for GetPulseProfile. It specifies over which range the slice profile is generated (in mm). the total profile is 2xSliceRange."

SliceRangeSamples::usage =
"SliceRangeSamples is an option for GetPulseProfile. defines how many samples are used to generate half a puls profile."

GRegularization::usage = 
"GRegularization is an option for CalculateGfactor and GfactorSimulation."

GOutput::usage = 
"GOutput is an option for GfactorSimulation. can be \"Grid\" or \"List\"."

ReportFits::usage = 
"ReportFits is an option for SimulateSliceEPG. If True it also reports the fit values."

FatFieldStrength::usage = 
"FatFieldStrength is an option for GetPulseProfile. If the value >0 it will calculate the shift of the fat refocusing pulse compared to the fat exitation pulse.
The shift is in SliceRangeSamples steps."


(* ::Subsection::Closed:: *)
(*Error Messages*)


Tensor::vec = "Eigenvectors must be a 3x3 matrix, \"Random\", \"RandomZ\", \"OrtRandom\", not: `1`"

Tensor::val = "Eigenvalues mus be a vector of size 3 or a number, not:`1`"

CreateDiffData::eig = "eigen system must be 3 eigenvalues {l1,l2,l2} in which cases fixed vectors wil be used 
	or eigenvalues with geven vectors {{l1,l2,l3},{e1,e2,e3}} 
	other possibility is 3 eigenvalues with a random, randomz or random ortogonal (fixed vectors with random sign)
		{{l1,l2,l3},Random}
		{{l1,l2,l3},RandomZ}
		{{l1,l2,l3},OrtRandom}
	not : `1`"

AddNoise::opt = "AddNoise"


(* ::Section:: *)
(*Functions*)


Begin["`Private`"]


(* ::Subsection::Closed:: *)
(*AddNoise*)


Options[AddNoise] = {NoiseSize->"Sigma",NoiseType->"Absolute"};

SyntaxInformation[AddNoise] = {"ArgumentsPattern" -> {_, _, OptionsPattern[]}};

AddNoise[dat_,noise_,OptionsPattern[]]:=Block[{sig,data,mdat,fdat},
	data=dat//N;
	sig=Switch[OptionValue[NoiseSize],
		"SNR",
		mdat=Switch[ArrayDepth[data],
			1,
			data[[1]],
			2,
			fdat=data[[1,All]];
			Mean[Pick[fdat,Unitize[fdat],1]],
			3,
			fdat=Flatten[data[[1,All,All]]];
			Mean[Pick[fdat,Unitize[fdat],1]],
			4,
			fdat=Flatten[data[[All,1,All,All]]];
			Mean[Pick[fdat,Unitize[fdat],1]],
			_,
			Message[AddNoise::dat];Return[]
		];
		mdat/noise
		,
		"Sigma",
		noise,
		_,
		Message[AddNoise::opt];Return[]
		];
	Switch[OptionValue[NoiseType],
		"Absolute", RicianDistribution[data,sig],
		"Complex", ComplexDistribution[data,sig]
	]
	]


RicianDistribution = Compile[{{Mu, _Real, 0}, {Sigma, _Real, 0}},
	Sqrt[RandomReal[NormalDistribution[Mu, Sigma]]^2 + RandomReal[NormalDistribution[0, Sigma]]^2],
	RuntimeAttributes -> {Listable}, RuntimeOptions -> "Speed"]

ComplexDistribution = Compile[{{Mu, _Complex, 0}, {Sigma, _Complex, 0}},
	RandomReal[NormalDistribution[Re@Mu, Sigma]] + I RandomReal[NormalDistribution[Im@Mu, Sigma]],
	RuntimeAttributes -> {Listable}, RuntimeOptions -> "Speed"]

(* ::Subsection:: *)
(*Tensor*)


(* ::Subsubsection::Closed:: *)
(*Tensor*)


Options[Tensor]={TensOutput->"Vector"}

SyntaxInformation[Tensor] = {"ArgumentsPattern" -> {_, _., OptionsPattern[]}};

Tensor[l_, ops:OptionsPattern[]]:=Tensor[l,{{0,0,1},{0,1,0},{1,0,0}}, ops]

Tensor[l_, vec_, OptionsPattern[]]:= Block[{e,tens},
	e = Switch[vec,
		"Random",
		RandomMat[],
		"RandomZ",
		RandomMatZ[],
		"OrtRandom",
		RandomSample[{{0,0,1},{0,1,0},{1,0,0}}],
		_,
		If[MatrixQ[vec]&&ArrayDepth[vec]==2,
			vec,
			Return[Message[Tensor::vec,vec]]
			]
		];
		
	tens = N@If[NumberQ[l],
		Transpose[e].{{l,0,0},{0,l,0},{0,0,l}}.e,
		If[VectorQ[l]&&Length[l]==3,
			Transpose[e].{{l[[1]],0,0},{0,l[[2]],0},{0,0,l[[3]]}}.e,
			Return[Message[Tensor::val,l]]
		]
	];
	Chop[Switch[OptionValue[TensOutput],"Vector",TensVec[tens],"Matrix",tens]]
]


(* ::Subsubsection::Closed:: *)
(*Tensor functions*)


RandomMatZ[]:= Block[{l1,l2,l3},
	l1 = {1,0,0};
	l2 = Normalize[{0,1,1}*RandomVec[]];
	l3 = Cross[l1,l2];
	{l1,l2,l3}
];


RandomMat[]:= Block[{l1,l2,l3},
	l1 = {1,0,0};
	l2 = Normalize[{0,1,1}*RandomVec[]];
	l3 = Cross[l1,l2];
	{l1, l2, l3 }. RotationMatrix[{{1,0,0}, RandomVec[]}]
];


RandomVec[]:= Normalize[RandomReal[NormalDistribution[], 3]]


(* ::Subsection::Closed:: *)
(*Signal*)


SyntaxInformation[Signal] = {"ArgumentsPattern" -> {_, _, _}};

Signal[par_,tr_,te_]:=par[[1]](1-Exp[-tr/par[[2]]])Exp[-te/par[[3]]]


(* ::Subsection:: *)
(*CreateDiffData*)


(* ::Subsubsection::Closed:: *)
(*CreateDiffData*)


SyntaxInformation[CreateDiffData] = {"ArgumentsPattern" -> {_, _, _, _., _.}};

CreateDiffData[s0_, eig_, bval_?NumberQ, grad_?MatrixQ, dim_]:= CreateDiffData[s0,eig,Prepend[ConstantArray[bval,Length[grad]],0],Prepend[grad,{0,0,0}],dim]

CreateDiffData[s0_, eig_, bvec:{_?NumberQ..},grad_?MatrixQ, dim_]:= CreateDiffData[s0,eig,Bmatrix[bvec,grad],dim]

CreateDiffData[s0_, eig_, bmat_?MatrixQ, dim_]:= Block[{diff},
	
	diff=Which[
		Dimensions[eig]=={3},
		ConstantArray[SignalTensor[s0,bmat,Tensor[eig]],dim],
		
		Dimensions[eig]=={2,3}&&Dimensions[eig[[2]]]=={3,3},
		ConstantArray[SignalTensor[s0,bmat,Tensor[eig[[1]],eig[[2]]]],dim],
		
		eig[[2]]==="Random"||eig[[2]]==="RandomZ"||eig[[2]]==="OrtRandom",
		Array[SignalTensor[s0,bmat,Tensor[eig[[1]],eig[[2]]]]&,dim],

		True,
		Return[Message[CreateDiffData::eig,eig]]
	];
	
	Switch[Length[dim],
		1,Transpose[diff],
		2,Transpose[diff,{2,3,1}],
		3,Transpose[diff,{1,3,4,2}]
		]
	]

CreateDiffData[s0_, eig_, bmat_?ArrayQ]:= Block[{diff, tens},
	tens = Which[
		Dimensions[eig]=={3}, Tensor[eig],
		Dimensions[eig]=={2,3}&&Dimensions[eig[[2]]]=={3,3}, Tensor[eig[[1]],eig[[2]]]
	];

	diff = Map[SignalTensor[s0, #, tens]&, bmat, {ArrayDepth[bmat]-2}];

	Switch[ArrayDepth[diff],
		2,Transpose[diff],
		3,Transpose[diff,{2,3,1}],
		4,Transpose[diff,{1,3,4,2}]
	]
]

(* ::Subsubsection::Closed:: *)
(*SignalTensor*)


SignalTensor[s0_, bmat_, tens_] := Module[{dv},
	dv=Append[If[Dimensions[tens]=={3,3},TensVec[tens],tens],Log[s0]];
	Exp[bmat.dv]
]


(* ::Subsection:: *)
(*Bloch Simulation*)


(* ::Subsubsection::Closed:: *)
(*BlochSeries*)


BlochSeries[mi_, dt_, w_, p_, gyro_:"1H"] := BlochSeriesi[mi, dt, w, p N[2 Pi GyromagneticRatio[gyro] 10^6]]

BlochSeriesi = Compile[{{mi, _Real, 1}, {dt, _Real, 0}, {w, _Real, 0}, {p, _Real, 1}}, Block[{M = mi, Mt, Mz, Mx, My},
	(M = MatrixExp[dt {{0, w, 0}, {-w, 0, #}, {0, -#, 0}}].M) & /@ p;
	(*calculate transverse longitudinal and xy magnetization*)
	{Mx, My, Mz} = M;
	Mt = Norm[{Mx, My}];
	(*give output {w,MT,Mz,Mx,My,ang,phase}*)
	{w, Mt, Mz, Mx, My, ArcTan[Mz, Mt]/Degree, Arg[Mx+ My I]}]
,RuntimeAttributes -> {Listable}, RuntimeOptions -> "Speed"];


(* ::Subsubsection::Closed:: *)
(*Pulses*)


Pulses[name_] := Switch[name,
	"sg_100_100_0",
	{0., 0.0126, 0.02622, 0.0408, 0.05637, 0.07291, 0.0904, 0.10889, 0.1283, 0.14863, 0.16984, 0.1919, 0.21479, 0.23847, 0.26286, 0.28794, 
	0.31364, 0.33992, 0.36668, 0.39387, 0.42143, 0.44926, 0.47731, 0.50548, 0.53368, 0.56182, 0.58983, 0.6176, 0.64504, 0.67211, 
	0.69863, 0.72457, 0.74984, 0.77432, 0.79794, 0.82061, 0.84225, 0.86279, 0.88214, 0.9002, 0.91696, 0.93231, 0.94623, 0.95862, 
	0.96948, 0.97873, 0.98636, 0.99231, 0.99658, 0.99915, 1., 0.99915, 0.99658, 0.99231, 0.98636, 0.97873, 0.96948, 0.95862, 0.94623, 
	0.93231, 0.91696, 0.9002, 0.88214, 0.86279, 0.84225, 0.82061, 0.79794, 0.77432, 0.74984, 0.72457, 0.69863, 0.67211, 0.64504, 
	0.6176, 0.58983, 0.56182, 0.53368, 0.50548, 0.47731, 0.44926, 0.42143, 0.39387, 0.36668, 0.33992, 0.31364, 0.28794, 0.26286, 
	0.23847, 0.21479, 0.1919, 0.16984, 0.14863, 0.1283, 0.10889, 0.0904, 0.07291, 0.05637, 0.0408, 0.02622, 0.0126, 0.},
	"sg_150_100_167",
	{0.00201, -0.00421, -0.01096, -0.01816, -0.02579, -0.03378, -0.04205, -0.0506, -0.0593, -0.06806, -0.07682, -0.08545, -0.09387,
	-0.10196, -0.10962, -0.1167, -0.12311, -0.1287, -0.13337, -0.13697, -0.13938, -0.14045, -0.14011, -0.13825, -0.13471, -0.1294,
	-0.12229, -0.11322, -0.10218, -0.08905, -0.07389, -0.05655, -0.03711, -0.01556, 0.00812, 0.03388, 0.06162, 0.09128, 0.12281,
	0.15607, 0.19092, 0.22724, 0.26484, 0.30357, 0.34324, 0.38365, 0.42454, 0.46577, 0.50703, 0.54811, 0.58879, 0.6288, 0.6679, 
	0.70586,0.74239, 0.77734, 0.81039, 0.8414, 0.87011, 0.89636, 0.91995,  0.94076, 0.95859, 0.97336, 0.98495, 0.99329, 0.99832, 1., 0.99832,
	0.99329, 0.98495, 0.97336, 0.95859, 0.94076, 0.91995, 0.89636, 0.87011, 0.8414, 0.81039, 0.77734, 0.74239, 0.70586, 0.6679, 0.6288,
	0.58879, 0.54811, 0.50703, 0.46577, 0.42454, 0.38365, 0.34324, 0.30357, 0.26484, 0.22724, 0.19092, 0.15607, 0.12281, 0.09128, 0.06162, 0.03388, 0.00812},
	"sg_200_100_0",
	{0., -0.0126, -0.026, -0.04007, -0.0546, -0.06934, -0.08405, -0.09851, -0.11243, -0.12546, -0.13739, -0.14786, -0.15659, -0.16324, 
	-0.16755, -0.16926, -0.16807, -0.16376, -0.15613, -0.14499, -0.13022, -0.11173, -0.08945, -0.06336, -0.03351, 0., 0.03705, 0.07739, 
	0.12088, 0.16715, 0.21589, 0.26673, 0.31925, 0.37303, 0.42756, 0.48235, 0.53688, 0.59062, 0.64306, 0.69362, 0.74184, 0.78719, 
	0.82919, 0.8674, 0.90139, 0.93081, 0.95535, 0.97473, 0.98871, 0.99716, 1., 0.99716, 0.98871, 0.97473, 0.95535, 0.93081, 0.90139, 
	0.8674, 0.82919, 0.78719, 0.74184, 0.69362, 0.64306, 0.59062, 0.53688, 0.48235, 0.42756, 0.37303, 0.31925, 0.26673, 0.21589, 
	0.16715, 0.12088, 0.07739, 0.03705, 0., -0.03351, -0.06336, -0.08945, -0.11173, -0.13022, -0.14499, -0.15613, -0.16376, -0.16807, -0.16926, 
	-0.16755, -0.16324, -0.15659, -0.14786, -0.13739, -0.12546, -0.11243, -0.09851, -0.08405, -0.06934, -0.0546, -0.04007, -0.026, -0.0126, 0.},
	"sg_300_100_0", 
	{0., 0.0125431, 0.0256661, 0.0388806, 0.0516984, 0.0636006, 0.0740684, 0.0825526, 0.0885952, 0.0917081, 0.091586, 0.0879238, 0.0805994, 0.0694906, 
	0.0547807, 0.0366527, 0.0155339, -0.00811792, -0.0336009, -0.0601215, -0.0868252, -0.112705, -0.136753, -0.157903, -0.175085, -0.187262, -0.193518, 
	-0.192938, -0.18482, -0.168615, -0.143925, -0.110599, -0.0686972, -0.0184942, 0.039491, 0.104495, 0.175542, 0.251473, 0.330973, 0.412519, 0.494552, 
	0.575426, 0.653432, 0.72692, 0.794305, 0.854122, 0.904996, 0.94586, 0.975707, 0.993896, 1., 0.993896, 0.975707, 0.94586, 0.904996, 
	0.854122, 0.794305, 0.72692, 0.653432, 0.575426, 0.494552, 0.412519, 0.330973, 0.251473, 0.175542, 0.104495, 0.039491, -0.0184942, 
	-0.0686972, -0.110599, -0.143925, -0.168615, -0.18482, -0.192938, -0.193518, -0.187262, -0.175085, -0.157903, -0.136753, -0.112705, -0.0868252, 
	-0.0601215, -0.0336009, -0.00811792, 0.0155339, 0.0366527, 0.0547807, 0.0694906, 0.0805994, 0.0879238, 0.091586, 0.0917081, 0.0885952, 
	0.0825526, 0.0740684, 0.0636006, 0.0516984, 0.0388806, 0.0256661, 0.0125431, 0.},
	"sinc_centre",
	{0., 0.03705, 0.07739, 0.12088, 0.16715, 0.21589, 0.26673, 0.31925,  0.37303, 0.42756, 0.48235, 0.53688, 0.59062, 0.64306, 0.69362,
	0.74184, 0.78719, 0.82919, 0.8674, 0.90139, 0.93081, 0.95535,0.9747, 0.98871, 0.99716, 1., 0.99716, 0.98871, 0.9747, 0.95535,
	0.93081, 0.90139, 0.8674, 0.82919, 0.78719, 0.74184, 0.69362, 0.64306, 0.59062, 0.53688, 0.48235, 0.42756, 0.37303, 0.31925,
	0.26673, 0.21589, 0.16715, 0.12088, 0.07739, 0.03705, 0.},
	"echo_1", 
	{0.101718, 0.0917692, 0.0768151, 0.0616779, 0.0490432, 0.0399792, 0.0343638, 0.0317698, 0.0314646, 0.0326853, 0.0342418, 0.0344859, 
	0.0309763, 0.0219123, 0.0061037, -0.0159307, -0.0420545, -0.0686972, -0.0921354, -0.111515, -0.124485, -0.13184, -0.135929, -0.139592, 
	-0.144749, -0.151769, -0.159093, -0.163854, -0.162877, -0.154027, -0.136143, -0.109928, -0.0770287, -0.0390332, 0.00274667, 0.0483108, 
	0.0981475, 0.152776, 0.22013, 0.295511, 0.375347, 0.457656, 0.540422, 0.622028, 0.701407, 0.777459, 0.847713, 0.909177, 0.957671, 0.988983, 
	1., 0.989013, 0.957671, 0.909177, 0.847713, 0.777459, 0.701468, 0.622059, 0.540483, 0.457747, 0.375408, 0.295572, 0.220222, 0.152806, 
	0.0982391, 0.0484329, 0.00292978, -0.0389111, -0.0768761, -0.109806, -0.13596, -0.153813, -0.162725, -0.163671, -0.158879, -0.151585, 
	-0.144536, -0.139378, -0.135716, -0.131626, -0.124302, -0.111362, -0.0919523, -0.0684835, -0.0418409, -0.0157476, 0.00625629, 0.0220649, 
	0.0310984, 0.0345775, 0.0343638, 0.0327769, 0.0315561, 0.0318613, 0.0344554, 0.0400708, 0.0491043, 0.0617084, 0.0768456, 0.0917997, 0.101749},
	"echo_2",
	{0.03504, 0.04898, 0.05676, 0.06095, 0.06317, 0.06442, 0.06494, 0.06464, 0.0633, 0.06088, 0.05734, 0.05246, 0.04566, 0.03619,
	0.02332, 0.00647, -0.01395, -0.03665, -0.05982, -0.08158, -0.10092, -0.11682, -0.12967, -0.14029, -0.1496, -0.15787,
	-0.16453, -0.16807, -0.16654, -0.1583, -0.14222, -0.11808, -0.0864, -0.04813, -0.004, 0.0455, 0.10034, 0.16056, 0.22782,
	0.30219, 0.38118, 0.46327, 0.54674, 0.62972, 0.71041, 0.78671,  0.85607, 0.91522, 0.96103, 0.99002, 1., 0.99002, 0.96103,
	0.91522, 0.85607, 0.78671, 0.71044, 0.62972, 0.54674, 0.4633,  0.38118, 0.30216, 0.22782, 0.16056, 0.10034, 0.0455, -0.00397,
	-0.04813, -0.08637, -0.11805, -0.14219, -0.1583, -0.16651, -0.16803, -0.16453, -0.15787, -0.1496, -0.14029, -0.12964,
	-0.11679, -0.10086, -0.08155, -0.05982, -0.03665, -0.01395,  0.00647, 0.02332, 0.03623, 0.04569, 0.05249, 0.05737, 0.06091,
	0.0633, 0.06464, 0.06494, 0.06446, 0.0632, 0.06095, 0.05679, 0.04901, 0.03507},
	"sg_175_100_0",
	{-0.07801, -0.0896, -0.10089, -0.1117, -0.12183, -0.13108, -0.13923, -0.14609, -0.15149, -0.15519, -0.15702, -0.1568, -0.15433, -0.14948, 
	-0.14209, -0.13208, -0.11933, -0.10373, -0.08524, -0.06388, -0.03961, -0.01248, 0.01743, 0.05005, 0.08524, 0.12287, 0.16269, 0.20454, 
	0.24815, 0.29328, 0.33961, 0.38682, 0.43461, 0.48262, 0.53047, 0.57784, 0.62432, 0.66958, 0.71322, 0.75491, 0.79427, 0.83102, 
	0.8648, 0.89532, 0.92236, 0.94565, 0.96496, 0.98019, 0.99118, 0.99777, 1., 0.99777, 0.99118, 0.98019, 0.96496, 0.94565, 0.92236, 
	0.89532, 0.8648, 0.83102, 0.79427, 0.75491, 0.71322, 0.66958, 0.62432, 0.57784, 0.53047, 0.48262, 0.43461, 0.38682, 0.33961, 
	0.29328, 0.24815, 0.20454, 0.16269, 0.12287, 0.08524, 0.05005, 0.01743, -0.01248, -0.03961, -0.06388, -0.08524, -0.10373, -0.11933, 
	-0.13208, -0.14209, -0.14948, -0.15433, -0.1568, -0.15702, -0.15519, -0.15149, -0.14609, -0.13923, -0.13108, -0.12183, -0.1117, -0.10089, -0.0896, -0.07801},
	"SE2560A90",
	{-0.0341103, -0.0742295, -0.090445, -0.0897989, -0.0793331, -0.0660901, -0.0569444, -0.0542176, -0.0552574, -0.0582366, -0.0625524, -0.0675464, -0.072427, -0.0767019, 
	-0.0802542, -0.0831137, -0.0854668, -0.0875283, -0.0895358, -0.0916576, -0.0939665, -0.0964615, -0.0990486, -0.101612, -0.104015, -0.106149, -0.107954, -0.109407, 
	-0.110542, -0.111404, -0.112056, -0.112544, -0.112884, -0.113071, -0.113062, -0.112805, -0.11224, -0.111317, -0.110003, -0.108285, -0.106173, -0.103684, -0.100842, -0.0976643, 
	-0.0941548, -0.0903058, -0.086092, -0.0814845, -0.0764505, -0.0709629, -0.0650067, -0.0585754, -0.0516773, -0.044324, -0.0365308, -0.0283098, -0.0196645, -0.010593, 
	-0.00108366, 0.0088768, 0.0193023, 0.0302033, 0.0415813, 0.053433, 0.0657451, 0.0785024, 0.0916877, 0.105285, 0.119285, 0.133679, 0.148466, 0.163646, 0.179215, 0.195169, 
	0.211499, 0.228188, 0.245217, 0.262563, 0.280202, 0.29811, 0.31627, 0.334662, 0.353273, 0.372088, 0.391092, 0.410266, 0.42959, 0.449038, 0.468581, 0.488189, 0.507831, 0.527478, 
	0.5471, 0.566671, 0.586167, 0.605562, 0.624831, 0.643947, 0.662882, 0.681604, 0.700079, 0.718273, 0.736151, 0.753682, 0.770832, 0.787572, 0.803874, 0.81971, 0.835053, 0.849877, 
	0.864153, 0.877853, 0.890949, 0.90341, 0.915211, 0.926325, 0.936727, 0.946397, 0.955315, 0.963463, 0.970826, 0.97739, 0.983142, 0.988068, 0.992158, 0.995401, 0.997789, 0.999314, 
	0.999971, 0.999759, 0.998679, 0.996733, 0.993928, 0.990271, 0.985772, 0.980442, 0.974293, 0.967338, 0.95959, 0.951065, 0.941779, 0.931749, 0.920997, 0.909546, 0.89742, 0.884646, 
	0.871252, 0.857268, 0.842721, 0.827641, 0.812054, 0.795988, 0.779469, 0.762525, 0.745186, 0.727482, 0.709445, 0.69111, 0.672511, 0.653682, 0.634654, 0.61546, 0.596126, 0.576679, 
	0.557144, 0.537544, 0.517907, 0.498259, 0.478629, 0.459049, 0.439548, 0.420158, 0.400904, 0.38181, 0.362897, 0.344179, 0.325673, 0.307392, 0.289352, 0.271573, 0.254074, 0.23688, 
	0.220013, 0.203497, 0.187348, 0.171581, 0.156201, 0.141213, 0.126617, 0.112414, 0.0986094, 0.0852112, 0.0722323, 0.0596898, 0.0476002, 0.0359782, 0.0248325, 0.0141638, 0.00396666, 
	-0.00577229, -0.0150667, -0.0239296, -0.0323684, -0.0403818, -0.0479626, -0.0550959, -0.0617678, -0.067968, -0.0736942, -0.0789585, -0.0837806, -0.0881923, -0.0922249, -0.0959061, 
	-0.099254, -0.102269, -0.104942, -0.10725, -0.109172, -0.110694, -0.111814, -0.112558, -0.112965, -0.113094, -0.113002, -0.112736, -0.112326, -0.111761, -0.111014, -0.110026, 
	-0.108741, -0.107119, -0.105147, -0.102873, -0.100375, -0.0977831, -0.0952281, -0.0928146, -0.0906045, -0.0885501, -0.0865453, -0.0843711, -0.0817959, -0.0786185, -0.0747038, 
	-0.0701104, -0.0650785, -0.0603178, -0.0565846, -0.0544511, -0.0548979, -0.0605101, -0.0724455, -0.0852153, -0.0917765, -0.0850869},
	"siemensRef",
	{0., -0.00542922, -0.0135451, -0.0214127, -0.02978, -0.0387479, 
	-0.0480541, -0.0582064, -0.0686702, -0.0792269, -0.0903648, 
	-0.102142, -0.113265, -0.122425, -0.130626, -0.137225, -0.141963, 
	-0.144501, -0.144511, -0.141855, -0.135422, -0.124633, -0.110175, 
	-0.0925689, -0.071066, -0.0455161, -0.0160745, 0.0174281, 0.0541419, 
	0.0948268, 0.142425, 0.195415, 0.248524, 0.301139, 0.355668, 
	0.411675, 0.468697, 0.525719, 0.581628, 0.637399, 0.695314, 0.751342, 
	0.800089, 0.843076, 0.882064, 0.916244, 0.945178, 0.968359, 0.985282, 
	0.996442, 1., 0.997966, 0.987989, 0.97225, 0.950254, 0.922504, 
	0.88934, 0.851192, 0.809025, 0.761169, 0.705738, 0.648402, 0.593143, 
	0.537225, 0.480203, 0.423181, 0.366836, 0.312147, 0.259015, 0.205369, 
	0.151779, 0.103625, 0.0620872, 0.0245347, -0.00964467, -0.0399323, 
	-0.0663283, -0.0883247, -0.106774, -0.122188, -0.133699, -0.14085, 
	-0.144172, -0.144839, -0.14264, -0.13824, -0.13198, -0.124474, 
	-0.115121, -0.104302, -0.0927337, -0.0814157, -0.0708699, -0.0604061, 
	-0.0502538, -0.0407783, -0.0314721, -0.0231048, -0.0150691, 
	-0.00712126, 0.},
	"siemensEx",
	{0., -0.00646081, -0.019922, -0.0321029, -0.0434417, -0.0540776, 
	-0.0645443, -0.0747202, -0.0840238, -0.0933275, -0.101444, -0.109227, 
	-0.115687, -0.121515, -0.125167, -0.126763, -0.125873, -0.122397, 
	-0.116005, -0.106702, -0.093909, -0.0773368, -0.057582, -0.0340315, 
	-0.00693866, 0.0259213, 0.0640998, 0.105412, 0.147648, 0.192052, 
	0.23986, 0.289286, 0.341038, 0.393662, 0.447739, 0.500716, 0.554178, 
	0.610835, 0.670412, 0.72611, 0.772159, 0.813115, 0.850705, 0.884431, 
	0.914377, 0.939671, 0.960605, 0.977056, 0.989264, 0.997039, 1., 
	0.998156, 0.991335, 0.979975, 0.964384, 0.944323, 0.91961, 0.890827, 
	0.857683, 0.820708, 0.780304, 0.735496, 0.684214, 0.629861, 0.575977, 
	0.522796, 0.469545, 0.415467, 0.362262, 0.309929, 0.259631, 0.211246, 
	0.165401, 0.121997, 0.0792182, 0.0397223, -0.00527241, -0.0235819, 
	-0.0482783, -0.0697776, -0.0875127, -0.101759, -0.112807, -0.120064, 
	-0.124967, -0.126763, -0.125968, -0.122572, -0.116816, -0.110607, 
	-0.10316, -0.095072, -0.086059, -0.0764646, -0.0665794, -0.0564035, 
	-0.0457676, -0.0344288, -0.0222957, -0.00890382, 0.},
	"sinc1", SincPulse[1, "None"],
	"sinc2", SincPulse[2, "None"],
	"sinc3", SincPulse[3, "None"],
	"sinc1H", SincPulse[1],
	"sinc2H", SincPulse[2],
	"sinc3H", SincPulse[3]
]


(* ::Subsubsection::Closed:: *)
(*SincPulse*)


SincPulse[n_ : 1, window_ : "Hamming"] := Block[{nsamp, x, y, win},
	nsamp = 101;
	x = Subdivide[-n, n, nsamp - 1] /. 0 -> 10.^-15;
	y = Table[If[xi == 0, 1, Sin[Pi xi]/(Pi xi)], {xi, x}];

	win = Switch[window,
			"Hamming", Table[0.54 - 0.46 Cos[2 Pi i/(nsamp - 1)],  {i, 0, nsamp - 1}],
			"Hann", Table[0.5 - 0.5 Cos[2 Pi i/(nsamp - 1)], {i, 0, nsamp - 1}],
			"Blackman", Table[0.42 - 0.5 Cos[2 Pi i/(nsamp - 1)] + 0.08 Cos[4 Pi i/(nsamp - 1)], {i, 0, nsamp - 1}],
			_, ConstantArray[1, nsamp]
		];
	y*win
]


(* ::Subsubsection::Closed:: *)
(*GetPulseProfile*)


Options[GetPulseProfile] = Options[GetPulseProfileI] = {
	MagnetizationVector -> {0, 0, 1}, 
	SliceRange -> 12, 
	SliceRangeSamples -> 25, 
	FatFieldStrength -> 0
};

SyntaxInformation[GetPulseProfile] = {"ArgumentsPattern" -> {_, _., OptionsPattern[]}};

GetPulseProfile[ex_?ListQ, ref_?ListQ, opts : OptionsPattern[]] := Module[{
		exOut, pl1, refOut, pl2, samps, sl1, sl2, shift, step, fatShift
	},

	samps = OptionValue[SliceRangeSamples];
	{exOut, pl1, sl1} = GetPulseProfile[ex, opts];
	{refOut, pl2, sl2} = GetPulseProfile[ref, opts];

	If[OptionValue[FatFieldStrength] > 0,
		(*calculate the fat slice shift in mm*)
		shift = 3.4 OptionValue[FatFieldStrength] 42.5775 (sl1/ex[[3,3]] - sl2/ex[[3,3]]);
		step = OptionValue[SliceRange]/OptionValue[SliceRangeSamples]/2.;
		fatShift = Abs[shift/step];
		{exOut[[6, samps + 1 ;;]], refOut[[6, samps + 1 ;;]], fatShift, {pl1, pl2}}
		,
		{exOut[[6, samps + 1 ;;]], refOut[[6, samps + 1 ;;]], {pl1, pl2}}
	]
]


GetPulseProfile[{name_, flipAnglei_, {gradStrengthi_, durationi_, bandwidthi_}}, ops:OptionsPattern[]] := 
GetPulseProfileI[{name, flipAnglei, {gradStrengthi, durationi, bandwidthi}}, ops]

GetPulseProfileI[{name_, flipAnglei_, {gradStrengthi_, durationi_, bandwidthi_}}, ops:OptionsPattern[]] := 
GetPulseProfileI[{name, flipAnglei, {gradStrengthi, durationi, bandwidthi}}, ops] = Block[{
		gamma, gradStrength, duration, bandwidth, sliceRange, sliceSamp, maxFreq, flipAngle, pos,time,maxt,
		thickness, inM, pulse, pulseSamp, freqRange, deltat, power, output, info, out, slice, opts, plot
	},
	
	(*fixed parameters*)
	gamma = 2 Pi 42.5775 10^6;
	
	(*converrt the inputs *)
	gradStrength = gradStrengthi 10^-3;(*input in mT/m convert to T/m*)
	duration = durationi 10^-3;(*input in ms convert to s*)
	bandwidth = N@2 Pi bandwidthi;(*is in Hz convert to rad/s*)
	flipAngle = flipAnglei;(*in degree*)
	
	(*get options*)
	inM = OptionValue[MagnetizationVector];
	sliceRange = N@OptionValue[SliceRange]/2 10^-3;(*in mm contert to m, only need to simulate half a slice*)
	sliceSamp = (2*OptionValue[SliceRangeSamples]);(*number of slice samples assume symetry*)
	pos = Range[-sliceRange/2, sliceRange/2, sliceRange/(2*sliceSamp)];
	
	(*Define frequencies*)
	pulse = Pulses[name];
	pulseSamp = Length[pulse] - 1;

	(*calculate dependant parameters*)
	thickness = bandwidth/(gamma gradStrength);(*in m*)
	slice = 1000 thickness/2;(*in mm*)
	deltat = duration/pulseSamp;
	pos = Position[pulse, Max[pulse]][[1, 1]]-1;
	time = deltat (Range[0, pulseSamp] - pos) 10^3;
	maxt = 1.1 Max[Abs[time]];
	
	(*power optimization to get flip angle*)
	power = 10.^-6;(*Tesla*)
	power = power flipAngle/BlochSeries[{0, 0, 1}, deltat, 0, power pulse][[6]];

	(*sweep over frequency range, {{feq [kHz],Mt,Mz,Mx,My,ang,phase}}*)
	maxFreq = gamma gradStrength (sliceRange);
	freqRange = Range[-maxFreq, maxFreq, 2 maxFreq/sliceSamp];
	output = BlochSeries[inM, deltat, freqRange, power pulse];

	(*generate info label*)
	info = Grid[{
		Style[#, Bold] & /@ {"G [mT/m]", "D [ms]", "T [mm]", "\[Gamma]GDT", "power [uT]", "BW [Hz]"},
		Style[#, Bold] & /@ Round[{1000 gradStrength, 1000 duration, 2 slice, bandwidth/2 Pi  thickness, 1000000 power, bandwidthi}, .01],
		{}
		}, Spacings -> {2, 0.5}];

	(*define plot values*)
	out = output;
	out[[All, 1]] = 1000 thickness out[[All, 1]]/bandwidth;
	slice = 1000 thickness/2;

	(*make plot grid*)
	opts = {Frame -> True, AxesOrigin -> {0, 0}, FrameStyle -> Thick, PlotMarkers -> None, Mesh -> False, PlotTheme -> "Monochrome"};
	plot = GraphicsGrid[Transpose@{
		{
			ListLinePlot[Transpose@{time, power pulse 10^6}, PlotRange -> {{-maxt,maxt},({-0.2,.2} + MinMax[pulse]) power 10^6}, PlotLabel -> "RF pulse", opts],
			ListLinePlot[out[[All, {1, 6}]], PlotRange -> {-25, 190}, GridLines -> {{-slice, slice}, {flipAngle}}, PlotLabel -> "FlipAngle", opts]
		},{
			ListLinePlot[out[[All, {1, 2}]], PlotRange -> {-.2, 1.1}, GridLines -> {{-slice, slice}, {-1, 1}}, PlotLabel -> "Mt", opts],
			ListLinePlot[out[[All, {1, 7}]], PlotRange -> {- Pi, Pi}, GridLines -> {{-slice, slice}, {-Pi, Pi}}, PlotLabel -> "Phase", opts]
		},{
			ListLinePlot[out[[All, {1, 3}]], PlotRange -> {-1.1, 1.1}, GridLines -> {{-slice, slice}, {-1, 0, 1}}, PlotLabel -> "Mz", opts],
			ListLinePlot[{out[[All, {1, 4}]], out[[All, {1, 5}]]}, PlotRange -> {-1.1, 1.1}, GridLines -> {{-slice, slice}, {-1, 1}}, PlotLabel -> "Mx / My", opts]
		}
	}, ImageSize -> 800, PlotLabel -> info, LabelStyle -> Black];
	
	(*give full output and plot*)
	{Transpose@output, plot, 2 slice}
]


(* ::Subsection::Closed:: *)
(*SimulateSliceEPG*)


Options[SimulateSliceEPG]={ReportFits->False}

SyntaxInformation[SimulateSliceEPG] = {"ArgumentsPattern" -> {_, _,_, OptionsPattern[]}};

SimulateSliceEPG[exitation_, refocus_, {{t1_, t2_}, {nEcho_, echoSp_}, b1_}, OptionsPattern[]] := Module[{
		sig, sigTrue, sigT, sigAll, sigInd, len, max, vv, vp, va, sigo, prof,
		info, fit, fitT2, fitT2T, epgT2, epgT2T, lines, plots, te, t2f, maxSig
	},

	(*define the signals for plotting*)
	sig = EPGSignal[{nEcho, echoSp}, {t1, t2}, #, b1] & /@ Transpose[{exitation, refocus}];
	sig = Join[Reverse[sig[[2 ;;]]], sig];
	maxSig = Max[Flatten[sig]];
	sig = sig/maxSig;
	sigT = Mean[sig]/Max[Mean[sig]];

	sigTrue = EPGSignal[{nEcho, echoSp}, {t1, t2}, {First@exitation, First@refocus}, b1]/maxSig;

	sigo = {sigTrue, sigT, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}};
	sigAll = Join[sigo, sig];

	sigInd = MapIndexed[Flatten@{#2, #1} &, sigAll, {2}];
	sigInd[[1, All, 1]] = sigInd[[1, All, 1]] /. 1 -> 2;
	len = Length[sigInd];
	max = Max@sigAll;

	(*make info tble*)
	info = Grid[{Style[#, Bold] & /@ {"T2 [ms]", "B1 [%]", "echos" , "\[CapitalDelta]te [ms] "},
		Style[#, Bold] & /@ Round[{t2, 100 b1, nEcho, echoSp}, .1]
		}, Spacings -> {2, 0.5}];

	fit = If[OptionValue[ReportFits],
		(*find fits of true and EPG signal*)
		fitT2 = t2f /. FindFit[Transpose[{echoSp Range[nEcho], sigTrue}][[3 ;;]], Exp[-te/t2f], {t2f}, te];
		fitT2T = t2f /. FindFit[Transpose[{echoSp Range[nEcho], sigT}][[3 ;;]], Exp[-te/t2f], {t2f}, te];
		
		epgT2 = NonLinearEPGFit[{{{nEcho, echoSp}, {1400, 365, 135}, {90, 180}}, {5, 80, 0.3}}, sigTrue][[1 ;; 4]];
		epgT2[[3 ;; 4]] = epgT2[[3 ;; 4]]/Total[epgT2[[3 ;; 4]]];
		
		epgT2T = NonLinearEPGFit[{{{nEcho, echoSp}, {1400, 365, 135}, {exitation, refocus}}, {5, 80, 0.3}}, sigT][[1 ;; 4]];
		epgT2T[[3 ;; 4]] = epgT2T[[3 ;; 4]]/Total[epgT2T[[3 ;; 4]]];
		
		(*make fit table*)
		fit = Grid[{Style[#, Bold] & /@ {"lin t2 nor", "lin t2 slice", "{EPG t2 nor, b1, watFr}", "{EPG t2 slice, b1, watFr}"},
			Style[#, Bold] & /@ Round[{fitT2, fitT2T, {1, 100, 100} epgT2[[1 ;; 3]], {1, 100, 100} epgT2T[[1 ;; 3]]}, .1]
			}];
		{" ",fit}    
		,
		Nothing
	];

	(*make plot*)
	lines = Graphics3D[{Lighter@Gray, Line[{{2, 1, #}, {2, nEcho, #}}]} & /@ Range[0, 1.1, .1]];
	prof = Graphics3D[{Lighter@Gray, Thick, Line[sigInd[[Length[sigo];;,1]]]}];
	plots = Table[
		ParametricPlot3D[sigInd[[m, Round[#]]] &[n], {n, 1, nEcho}, 
		ColorFunction -> "DarkRainbow", ColorFunctionScaling -> False, PlotRange -> Full, PerformanceGoal -> "Speed",PlotPoints->nEcho]
	, {m, 2, len, 1}];
	
	PrependTo[plots, ParametricPlot3D[sigInd[[1, Round[#]]] &[n], {n, 1, nEcho}, PlotStyle -> Directive[{Dashed, Darker@Gray}, PlotRange -> Full]]];
	text = Graphics3D[Text[Style["Mean signal (colored line)\nMid slice signal (gray line)", Bold, Black], {0, 0.5 nEcho, 1.3 max}]];
	vv = {0.24, 0.19, 0.95};
	vp = {2.57, 1.90, 1.08};
	va = 35 Degree;

	(*Column[Flatten@{
	"  ", info, fit,*)
	Show[plots, lines, prof, (*text,*) BoxRatios -> 1, PlotRange -> {{0, len}, {0, nEcho}, {-0., 1.1 max}}, 
		BoxStyle -> Directive[{Thick, Black}], SphericalRegion -> True, ViewVertical -> vv, ViewPoint -> vp, 
		ViewAngle -> va, ImageSize -> 400,FrameLabel->{}, 
		Axes -> True, (*AxesLabel -> {"Slice Profile", "Nr. echos", "Normalized\nSignal"},*) 
		AxesEdge -> {{1, -1}, {1, -1}, {1, -1}},
		Ticks -> False, LabelStyle -> Directive[{Bold, Black}]
	]
	(*}, Alignment -> Center, Spacings -> 0]*)
]


(* ::Subsection::Closed:: *)
(*GfactorSimulation*)


Options[GfactorSimulation] = {GRegularization -> 0., GOutput -> "Grid"};

SyntaxInformation[GfactorSimulation] = {"ArgumentsPattern" -> {_, _, _, _., _., OptionsPattern[]}};

GfactorSimulation[sensitivity_, w_, {dir1_, sensea_?ListQ}, opts : OptionsPattern[]] := GfactorSimulation[sensitivity, w, 0, {dir1, sensea}, {"", {0}}, opts]

GfactorSimulation[sensitivity_, w_, {dir1_, sensea_?ListQ}, {dir2_, senseb_?ListQ}, opts:OptionsPattern[]]:= GfactorSimulation[sensitivity, w, 0, {dir1, sensea}, {dir2, senseb}, opts]

GfactorSimulation[sensitivity_, w_, mask_, {dir1_, sensea_?ListQ}, opts : OptionsPattern[]] := GfactorSimulation[sensitivity, w, mask, {dir1, sensea}, {"", {0}}, opts]

GfactorSimulation[sensitivity_, w_, mask_, {dir1_, sensea_?ListQ}, {dir2_, senseb_?ListQ}, OptionsPattern[]] := Block[{
		dir, dim, factors, gfactorsAX, gfactorsCOR, gfactorsSAG, lambda, sense1, sense2, sense3, nn, gfactors, reg
	},
	
	(*get the sense factor and directions*)
	dir = {{dir1, sensea}, {dir2, senseb}};
	{sense1, sense2} = dir[[All, 2]];
	dir = dir[[All, 1]];
	reg = OptionValue[GRegularization];
	
	(*generate all the sense factor lists*)
	factors = Switch[dir,
	(*one directions*)
	{"FH",""}, Table[{i, 1, 1}, {i, sense2}],
	{"AP",""}, Table[{1, i, 1}, {i, sense2}],
	{"LR",""}, Table[{1, 1, i}, {i, sense2}],
	
	{"FH", "LR"}, Flatten[Table[{i, 1, j}, {i, sense1}, {j, sense2}], 1],
	{"LR", "FH"}, Flatten[Table[{i, 1, j}, {j, sense2}, {i, sense1}], 1],
	
	{"AP", "LR"}, Flatten[Table[{1, i, j}, {i, sense1}, {j, sense2}], 1],
	{"LR", "AP"}, Flatten[Table[{1, i, j}, {j, sense2}, {i, sense1}], 1],
	
	{"AP", "FH"}, Flatten[Table[{j, i, 1}, {i, sense1}, {j, sense2}], 1],
	{"FH", "AP"}, Flatten[Table[{j, i, 1}, {j, sense2}, {i, sense1}], 1]
	];
	
	(*perform the gfactor calculations*)
	gfactors = CalculateGfactori[factors, sensitivity, w, mask, GRegularization -> reg];
	
	(*output the gfactor*)
	If[OptionValue[GOutput] === "Grid", GridData3D[gfactors,Length[sense2]], {gfactors, factors}]
	]


(* ::Subsection::Closed:: *)
(*CalculateGfactor*)


Options[CalculateGfactor] = {GRegularization -> 0.};

SyntaxInformation[CalculateGfactor] = {"ArgumentsPattern" -> {_, _, _, _., OptionsPattern[]}}

CalculateGfactor[factors_, sensitivity_, wMat_, opts:OptionsPattern[]] := CalculateGfactori[factors, sensitivity, wMat, 0, opts]

CalculateGfactor[factors_, sensitivity_, wMat_, mask_, opts:OptionsPattern[]] := CalculateGfactori[factors, sensitivity, wMat, mask, opts]


Options[CalculateGfactori] = Options[CalculateGfactor];

CalculateGfactori[factorsi_, sensitivity_, wMat_, maski_, OptionsPattern[]] := Block[{
	dim,lambda,listQ,factors,ii,sens,Wmati,gfactors,factor,Rmat,usVal,
	FOVux,FOVuy,FOVuz, fcorx, fcory,fcorz, usf, FOVu,shft,FOVf,r,FOV,
	fcors,corsG,Smat,mat,pmat,gfac,gfactor,mask,gmask
	},
	
	(*get parameters*)
	dim = Drop[Dimensions[sensitivity], 1];
	lambda = OptionValue[GRegularization];
	listQ = VectorQ[factorsi];
	(*DistributeDefinitions[lambda, dim, sensitivity, wMat];*)
	factors = If[listQ, {factorsi}, factorsi];
	ii = 0;
	
	mask = If[maski=!=0, maski, Mask[Total@Abs@sensitivity, .001]];
	
	(*define the sensitivity and regularization mat*)
	sens = RotateDimensionsLeft[sensitivity];
	Wmati = Inverse[wMat];
	
	DistributeDefinitions[factors, UsFactor, dim, lambda, wMat];

	(*loop over all the factors*)
	gfactors = Monitor[
		Table[(
			factor = factors[[f]];
			Rmat = lambda^2 IdentityMatrix[Times @@ factor];
			(*get the undersample factors*)
			usVal = Transpose[UsFactor[dim, factor]];
			{FOVux, FOVuy, FOVuz} = usVal[[All, 2]];
			(*get all the indexes for x y and z*)
			{fcorx, fcory, fcorz} = Table[
				{usf, FOVu, shft, FOVf, r} = usVal[[c]];
				FOV = dim[[c]];
				(*get the folded x,y and z indexes*)
				Table[Ceiling[If[! (FOV < # <= FOVf), If[# > FOV, # - FOVf, #], FOV] & /@ (cor + FOVu*Range[0, r - 1] + shft)], {cor, FOVu}]
			, {c, 1, 3}];
			(*map the indexes to coordinates*)
			fcors = Flatten[Table[Flatten[Table[{i, j, k}, {i, fcorx[[x]]}, {j, fcory[[y]]}, {k, fcorz[[z]]}], 2], {x, FOVux}, {y, FOVuy}, {z, FOVuz}], 2];
			(*Calculate the gfactors*)
			corsG = Map[(
				Smat = Transpose[Extract[sens, #]];
				mat = ConjugateTranspose[Smat].Wmati.Smat;
				pmat = PseudoInverse[mat + Rmat];
				gfac = Abs[Sqrt[Diagonal[pmat] Diagonal[mat]]]
			) &, fcors];
			(*map the gfactors to 3D volume*)
			gfactor = ConstantArray[-1, dim];
			MapThread[(gfactor[[#1[[1]], #1[[2]], #1[[3]]]] = #2) &, {fcors, corsG}, 2];
			
			(*calculate 1/g and clip between 0 and 1 and apply mask*)
			gfactor = Clip[DivideNoZero[1,gfactor], {0,1}];
			ToPackedArray[N[(mask gfactor) - (1.-mask)/10]]
			
		), {f,1,Length[factors]}], 
	Row[{Dynamic[factor],ProgressIndicator[f,{0,Length[factors]}]}]];
		
	If[listQ, gfactors[[1]], gfactors]
]


UsFactor[dim_, r_] := Block[{usdim, Rus, shift},
	usdim = Ceiling[dim/r];
	Rus = N[dim/usdim];
	shift = (dim/2) - dim/(2 Rus);
	{Rus, usdim, shift, r*usdim, r}
]


(* ::Subsection::Closed:: *)
(*SimParameters*)


Options[SimParameters]={Reject->False}

SyntaxInformation[SimParameters] = {"ArgumentsPattern" -> {_, OptionsPattern[]}};

SimParameters[tens_,OptionsPattern[]]:=
Module[{eig,adc,fa,dataAll,rangy,bins,wbins,sol,fit,x,omega,xi,alpha},
	(
		Off[NonlinearModelFit::"cvmit"];
		Off[NonlinearModelFit::"sszero"];
		eig=1000 EigenvalCalc[#,Reject->OptionValue[Reject],MonitorCalc->False];
		adc=ADCCalc[eig];
		fa=FACalc[eig];
		dataAll=DeleteCases[DeleteCases[Flatten[#],0],0.]&/@{eig[[All,All,1]],eig[[All,All,2]],eig[[All,All,3]],adc,fa};
		rangy={{0,3},{0,3},{0,3},{0,3},{0,1}};
		bins=MapThread[{Range[#2[[1]]+.5(#2[[2]]/50),#2[[2]],#2[[2]]/50],BinCounts[#1,{#2[[1]],#2[[2]],#2[[2]]/50}]}&,{dataAll,rangy}];
		wbins=Transpose/@MapThread[{#1[[1]],(#1[[2]]/Length[#3])/(#2[[2]]/100)}&,{bins,rangy,dataAll}];
		sol=NonlinearModelFit[FitData[#],SkewNorm[x,omega,xi,alpha],{omega,xi,alpha},x,Gradient->"FiniteDifference"]&/@dataAll;
		fit=Append[ParameterFit[#]&/@dataAll,{Length[dataAll[[1]]]}];
		{dataAll,wbins,sol,fit}
		)&/@tens
]


(* ::Subsection::Closed:: *)
(*AngleParameters*)


SyntaxInformation[SimAngleParameters] = {"ArgumentsPattern" -> {_, _}};

SimAngleParameters[tens_,veci_]:=
Module[{bins,surface,wbins,fit,par,vec,ang,x,theta},
	surface=N[Table[( Cos[(x-1) Degree]- Cos[x Degree]),{x,1,90,1}]];
	(
		vec=EigenvecCalc[#,MonitorCalc->False];
		ang=AngleCalc[vec[[All,All,#]],veci[[#]],Distribution->"0-90"]&/@{1,2,3};
		bins=Map[BinCounts[DeleteCases[Flatten[#],0.],{0,90,1}]&,ang];
		wbins=Map[{#/Total[#],#/surface/Total[#/surface]}&,bins];
		fit=Map[NonlinearModelFit[#[[2]],HalfNorm[x,theta],{theta},x,Gradient->"FiniteDifference"]&,wbins];
		par=Map[({theta}/.#["BestFitParameters"])[[1]]&,fit];
		{ang,wbins,fit,par}
		)&/@tens
	]


(* ::Subsection:: *)
(*Plot Simulation*)


(* ::Subsubsection::Closed:: *)
(*Definitions*)


sizes={200,300,400,500,750,1000,1500,2000,2500,3000};
files={".pdf",".jpg",".gif",".tif",".png"};

labStyle = Directive[Bold,FontFamily->"Helvetica",14,Black];
unit = " [\!\(\*SuperscriptBox[\(10\), \(-3\)]\) \!\(\*SuperscriptBox[\(mm\), \(2\)]\)/s]";

lambda[x_] :="\!\(\*SubscriptBox[\"\[Lambda]\", \"" <> ToString[x] <> "\"]\)";

epsilon[x_] := "\!\(\*SubscriptBox[\(\[CurlyEpsilon]\), \"" <> ToString[x] <> "\"]\)"

Phi[x_]:=1/(E^(x^2/2)*Sqrt[2*Pi]);

CapitalPhi[x_]:=.5(1+Erf[(x)/Sqrt[2]]);

SkewNorm[x_,omega_,xi_,alpha_]:=(2/omega)Phi[(x-xi)/omega]CapitalPhi[alpha (x-xi)/omega];

HalfNorm[x_,theta_]:=PDF[HalfNormalDistribution[theta],x]


(* ::Subsubsection::Closed:: *)
(*PlotSimulationHist*)


SyntaxInformation[PlotSimulationHist] = {"ArgumentsPattern" -> {_, _, _, _}};

PlotSimulationHist[pars_,label_,xdata_,tr_]:=DynamicModule[{rangy,xlabel,exp},
	rangy={{0,3},{0,3},{0,3},{0,3},{0,1}};
	xlabel={lambda[1]<>unit, lambda[2]<>unit, lambda[3]<>unit, "MD"<>unit, "fa [-]"};
	Manipulate[
		If[!ListQ[pars]||!ListQ[rangy],
			Return[],
			exp=GraphicsRow[(Show[
				Histogram[Flatten[pars[[y,1,#]]],{rangy[[#,2]]/50},"ProbabilityDensity",PlotRange->{rangy[[#]],{0,1.1Max[pars[[y,2,#,All,2]]]}},
				PerformanceGoal->"Speed",AxesOrigin->{0,0},LabelStyle->labStyle,
				FrameLabel->{xlabel[[#]],"Probability density"},Axes->False,FrameStyle->Thick,Frame->{True,True,False,False},ChartBaseStyle->EdgeForm[{Thin,White}],ChartStyle->Gray],
				ListPlot[pars[[y,2,#]],Joined->True,PlotStyle->{Thick,Black},PlotRange->{rangy[[#]],{0,1.1Max[pars[[y,2,#,All,2]]]}}],
				Plot[pars[[y,3,#]][x],{x,rangy[[#,1]],rangy[[#,2]]},PlotStyle->{Thick,Red},PlotRange->{rangy[[#]],{0,1.1Max[pars[[y,2,#,All,2]]]}}],
				ListLinePlot[{{tr[[#]],0},{tr[[#]],1.1Max[pars[[y,2,#,All,2]]]}},PlotStyle->Directive[Thick,Black,Dashed]]
				]&/@{1,2,3,4,5})[[xx]],ImageSize->Length[xx]*400,PlotLabel->Style[label<>"  -  "<>ToString[xdata[[y]]],16],LabelStyle->labStyle]
			]
		,
			{{xx,{1,2,3},"Parameter"},{{1,2,3}->"eigenvalues",{4,5}->"MD\\fa"}},
			{{y,1,"Simulation Value"},1,Length[pars],1},
			Button["Export Plot To File",FileSave[Dynamic[exp],"jpg",2000],Method->"Queued"],
			{{size, 500, "Export Size"}, sizes}, 
			{{file, ".jpg","File Type"}, files},
		SaveDefinitions->True
	]
]


(* ::Subsubsection::Closed:: *)
(*PlotSimulation*)


Options[PlotSimulation]={PlotRange->{{0,3},{0,3},{0,3},{0,3},{0,1}}};

SyntaxInformation[PlotSimulation] = {"ArgumentsPattern" -> {_, _, _, _, _, OptionsPattern[]}};

PlotSimulation[pars_,xval_,tr_,label_,color_,OptionsPattern[]]:= Module[{pl,dat,err,rangx,rangy,ylabel,truey,off},

	off=0.025(Max[xval]-Min[xval]);
	rangx={Min[xval]-off,Max[xval]+off};
	rangy=OptionValue[PlotRange];
	ylabel={lambda[1]<>unit, lambda[2]<>unit, lambda[3]<>unit, "MD"<>unit, "fa [-]"};
	pl=(
	truey=ConstantArray[tr[[#]],{Length[xval]}];
	dat=pars[[All,4,#,1]];
	err=If[Length[pars[[1,4,#]]]==2,pars[[All,4,#,2]],0];
	ListLinePlot[
		{Transpose[{xval,truey}],Transpose[{xval,dat}],Transpose[{xval,dat-err}],Transpose[{xval,dat+err}]},
		Filling->{3->{4}},FillingStyle->Directive[Opacity[0.1],color],FrameTicks->{xval,Automatic},PlotMarkers->{"",{"\[FilledSmallCircle]",15},{"\[UpPointer]",15},{"\[DownPointer]",15}},
		PlotStyle->{Directive[Gray,Thick,Dashing[Medium]],Directive[color,Thick],Directive[color,Thin,Dashing[Medium]],Directive[color,Thin,Dashing[Medium]]},
		PlotRange->{rangx,rangy[[#]]},
		LabelStyle->labStyle,FrameLabel->{label,ylabel[[#]]},Axes->False,FrameStyle->Thick,Frame->{True,True,False,False}
		]
	)&/@{1,2,3,4,5};
	GraphicsGrid[Partition[pl, 3, 3, 1, {}], ImageSize -> 1200]
]


(* ::Subsubsection::Closed:: *)
(*PlotSimulationAngleHist*)


SyntaxInformation[PlotSimulationAngleHist] = {"ArgumentsPattern" -> {_, _, _}};

PlotSimulationAngleHist[pars_,label_,xdata_]:=
Module[{exp},
	Manipulate[
		If[!ListQ[pars],
			Return[],
			exp=GraphicsRow[
				Show[
					Histogram[Flatten[pars[[y,1,#]]],{1},"ProbabilityDensity",PlotRange->{{0,90},{0,1.1Max[pars[[y,2,#]]]}},PerformanceGoal->"Speed",LabelStyle->labStyle,
					FrameLabel->{"Error "<>epsilon[#]<>" [\[Degree]]","Probability density"},
					Axes->False,FrameStyle->Thick,Frame->{True,True,False,False},ChartBaseStyle->EdgeForm[{Thin,White}],ChartStyle->Gray],
					ListPlot[pars[[y,2,#,1]],Joined->True,PlotStyle->{Thick,Darker[Gray]},PlotRange->{{0,90},{0,1.1Max[pars[[y,2,#]]]}}],
					ListPlot[pars[[y,2,#,2]],Joined->True,PlotStyle->{Thick,Black},PlotRange->{{0,90},{0,1.1Max[pars[[y,2,#]]]}}],
					Plot[pars[[y,3,#]][x],{x,1,90},PlotStyle->{Thick,Red},PlotRange->{{0,90},{0,1.1Max[pars[[y,2,#]]]}}]
					]&/@{1,2,3}
				,ImageSize->1200,LabelStyle->labStyle,PlotLabel->Style[label<>" - "<>ToString[xdata[[y]]],16]]
			]
		,{{y,1,"Simulation Value"},1,Length[pars],1},
		Button["Export Plot To File",FileSave[Dynamic[exp],"jpg",2000],Method->"Queued"],
		{{size, 500, "Export Size"}, sizes}, {{file, ".jpg","File Type"}, files},
		SaveDefinitions->True
		]
	]


(* ::Subsubsection::Closed:: *)
(*PlotSimulationAngle*)


Options[PlotSimulationAngle]={PlotRange->{0,90}}

SyntaxInformation[PlotSimulationAngleHist] = {"ArgumentsPattern" -> {_, _, _, _, _., OptionsPattern[]}};

PlotSimulationAngle[par_, xdata_, label_, col_, OptionsPattern[]]:=
PlotSimulationAngle[par, xdata, label, col, {.25,.5,.95}, PlotRange->OptionValue[PlotRange]]

PlotSimulationAngle[par_, xdata_, label_, col_, quantinp_, OptionsPattern[]] := Module[{quant,pars=Transpose[par[[All,4]]],e,pdat,xrange,off},
	off=0.025(Max[xdata]-Min[xdata]);
	xrange = {Min[xdata]-off,Max[xdata]+off};

	GraphicsRow[(
		e = #;
		pdat = (
			quant = #;
			Transpose[{xdata, Quantile[HalfNormalDistribution[#], quant] & /@ pars[[e]]}]
		) & /@ quantinp;
		ListLinePlot[pdat,
			PlotStyle -> {Directive[col, Thick], 
			Directive[col, Thick, Dashing[Large]], 
			Directive[col, Thick, Dashing[Medium]], 
			Directive[col, Thick, Dashing[Small]], 
			Directive[col, Thick, Dashing[Tiny]]},
			FrameTicks->{xdata,Automatic},
			LabelStyle -> labStyle,
			PlotMarkers -> {"\[FilledSmallCircle]", 14},
			PlotRange -> {xrange,OptionValue[PlotRange]},
			FrameLabel -> {label, "Error "<>epsilon[#]<>" [\[Degree]]"}, Axes -> False,
			FrameStyle -> Thick,
			FrameTicks -> {Automatic, {0, 15, 30, 45, 60, 75, 90}},
			Frame -> {True, True, False, False}
		]
	) & /@ {1, 2, 3}, ImageSize -> 1000, Spacings -> 0]
]


(* ::Subsubsection::Closed:: *)
(*PlotSimulationVec*)


Options[PlotSimulationVec]={SortVecs->True}

SyntaxInformation[PlotSimulationVec] = {"ArgumentsPattern" -> {_, _, _, OptionsPattern[]}};

PlotSimulationVec[tens_, xdata_, label_, OptionsPattern[]] := Module[{
		eigvm, eigvcm, arrows1, arrows2, arrows3, vp1, vp2, vp3, va1, va2, va3, vv1, vv2, vv3, data, exp, xd
	},

	eigvm = Flatten[EigenvecCalc[#,MonitorCalc->False], 1] & /@ tens;

	eigvcm =If[OptionValue[SortVecs],
		Map[(
			{
			RandomReal[NormalDistribution[1.025, .025]] If[
				Negative[#[[1, 3]]], {1, -1, -1}, {1, -1, 1}]*#[[1]],
			RandomReal[NormalDistribution[1.025, .025]] If[
				Negative[#[[2, 2]]], {1, 1, 1}, {1, -1, 1}]*#[[2]],
			RandomReal[NormalDistribution[1.025, .025]] If[
				Negative[#[[3, 1]]], {-1, -1, 1}, {1, -1, 1}]*#[[3]]
			}
		) &, eigvm, {2}]
		,
		eigvm
	];

	arrows1 = Graphics3D[{
		{Darker[Blue], Arrowheads[0.05], Arrow[Tube[{{-1, 1, 0.5}, {-1, 1, 1}}, 0.025]]},
		{Darker[Red], Arrowheads[0.05], Arrow[Tube[{{-1, 1, 0.5}, {-1, .5, 0.5}}, 0.025]]},
		{Darker[Green], Arrowheads[0.05], Arrow[Tube[{{-1, 1, 0.5}, {-.5, 1, 0.5}}, 0.025]]}
	}];
	arrows2 = Graphics3D[{
		{Darker[Blue], Arrowheads[0.05], Arrow[Tube[{{-1, -.5, -1}, {-1, -.5, -.5}}, 0.025]]},
		{Darker[Red], Arrowheads[0.05], Arrow[Tube[{{-1, -.5, -1}, {-1, -1, -1}}, 0.025]]},
		{Darker[Green], Arrowheads[0.05], Arrow[Tube[{{-1, -.5, -1}, {-.5, -.5, -1}}, 0.025]]}
	}];
	arrows3 = Graphics3D[{
		{Darker[Blue], Arrowheads[0.05], Arrow[Tube[{{.5, 1, -1}, {.5, 1, -.5}}, 0.025]]},
		{Darker[Red], Arrowheads[0.05], Arrow[Tube[{{.5, 1, -1}, {.5, .5, -1}}, 0.025]]},
		{Darker[Green], Arrowheads[0.05], Arrow[Tube[{{.5, 1, -1}, {1, 1, -1}}, 0.025]]}
	}];
	
	vp1 = {0.426945, -0.474858, 3.32298}; 
	vv1 = {0.0421748, -0.881393, 0.470498}; va1 = 25 Degree;
	(*{Dynamic[vp1],Dynamic[vv1],Dynamic[va1]}*)
	vp2 = {0.429321, -3.30821, 0.56695}; 
	vv2 = {0.058434, -0.443718, 0.894259}; va2 = 25 Degree;
	(*{Dynamic[vp2],Dynamic[vv2],Dynamic[va2]}*)
	vp3 = {3.1877, 0.899157, 0.692886}; 
	vv3 = {0.416537, 0.112532, 0.902127}; va3 = 25 Degree;
	(*{Dynamic[vp3],Dynamic[vv3],Dynamic[va3]}*)

	Manipulate[
	If[!ListQ[eigvcm],Return[],
		data = eigvcm[[set]] // Transpose;
		xd = xdata[[set]];
			
		exp = GraphicsRow[{
				EigPlot[data, vp1, vv1, va1, arrows1, 1], 
				EigPlot[data, vp2, vv2, va2, arrows2, 2], 
				EigPlot[data, vp3, vv3, va3, arrows3, 3]
			}, 
			ImageSize -> {1000}, Spacings -> 0,
			PlotLabel-> Style[label <> " - " <>ToString[xdata[[set]]],18],
			LabelStyle -> labStyle
		]
	]
	,
	{{set, 1, "Simulation Value"}, 1, Length[xdata], 1},
	Button["Export Plot To File", FileSave[exp, "jpg", 2000], Method -> "Queued"],
	{{size, 500, "Export Size"}, sizes}, {{file, ".jpg","File Type"}, files},
	SaveDefinitions->True
	]
]


(* ::Subsubsection::Closed:: *)
(*EigPlot*)


EigPlot[data_, vp_, vv_, va_, arrows_, val_] := Module[{sphere,line},
	sphere = SphericalPlot3D[.975, {theta, 0, Pi}, {Phi, 0, 2 Pi}, Lighting -> "Neutral"];
	line = ParametricPlot3D[{{Sin[u], 0, Cos[u]}, -{0, Sin[u], Cos[u]}}, {u, -Pi, Pi},
		PlotStyle -> {Directive[Dashed, Thickness[.0125], Darker[Green]], Directive[Dashed, Thickness[.0125], Darker[Red]]}
	];
	Show[ListPointPlot3D[data, 
		ViewPoint -> vp, ViewVertical -> vv, ViewAngle -> va,
		PlotLabel -> {"First", "Second", "Third"}[[val]]<>" eigenvector",
		PlotRange -> {{-1.1, 1.1}, {-1.1, 1.1}, {-1.1, 1.1}}, 
		BoxRatios -> 1, PlotStyle -> {Darker[Blue], Darker[Red], Darker[Green]}, 
		Lighting -> "Neutral", Axes -> False, Boxed -> False, 
		SphericalRegion -> True, 
		LabelStyle -> labStyle
	], arrows, sphere, line]
];


(* ::Subsubsection::Closed:: *)
(*GESignal*)


GESignal[ang_?ListQ, {tr_, t1_}] := Transpose[GESignal[#, {tr, t1}] & /@ ang]

GESignal[ang_?NumberQ, {tr_, t1_}] := Block[{e1, a},
	a = ang Degree;
	e1 = Exp[-tr/t1];
	Sin[a] (1 - e1)/(1 - Cos[a] e1)
];


GESignal[ang_?ListQ, {{tr1_, tr2_}, t1_}] := Transpose[GESignal[#, {{tr1, tr2}, t1}] & /@ ang]

GESignal[ang_?NumberQ, {{tr1_, tr2_}, t1_}] := Block[{a, e1, e2, s1, s2},
	a = N[ang Degree];
	e1 = Exp[-tr1/t1];
	e2 = Exp[-tr2/t1];
	s1 = Sin[a] (1 - e2 + (1 - e1) e2 Cos[a])/(1 - e1 e2 (Cos[a])^2);
	s2 = Sin[a] (1 - e1 + (1 - e2) e1 Cos[a])/(1 - e1 e2 (Cos[a])^2);
	{s1, s2}
]


(* ::Subsubsection::Closed:: *)
(*SimulateDualTR*)


SyntaxInformation[SimulateDualTR] = {"ArgumentsPattern" -> {_.}};

SimulateDualTR[t1_ : 6000] := Manipulate[
	{s1, s2} = GESignal[ang, {{tr1, n tr1}, t1}]/0.35;
	s2a = Abs[s2];
	p1=s1[[Round[fa]]];
	p2=s2a[[Round[fa]]];
	Column[{
		Row[{
			ListLinePlot[{s1, s2a}, PlotRange -> If[! r, Full, {-0, 1}], ImageSize -> 350, PlotStyle -> (Directive[{Thick, #}] & /@ {Black, Red}),
				AxesStyle -> Directive[{Thick, Black}], LabelStyle -> Directive[Bold, 14, Black], PlotLabel -> "Signal as function of flipangle",
				GridLines -> {{fa}, {p1, p2}},
				Epilog -> {PointSize[Large], Black, Point[{fa, p1}], Red, Point[{fa, p2}]}],
			ListLinePlot[s2a/s1, PlotRange -> {0, 1.1}, ImageSize -> 350, PlotStyle -> Directive[{Black, Thick}], 
				AxesStyle -> Directive[{Thick, Black}], LabelStyle -> Directive[Bold, 14, Black], PlotLabel -> "Signal ratio as function of flipangle",
				GridLines -> {{fa}, {p2/p1}},
				Epilog -> {PointSize[Large], Black, Point[{fa, p2/p1}]}]
			}, "         "],"",
		Style["TR1: " <> ToString[tr1] <> " ms  -  TR2: " <> ToString[n tr1] <>" ms  -  Total time: " <> ToString[tr1 + n tr1] <> " ms", Bold, 14, Black, FontFamily -> "Helvetica"], "",
		Style["max. sig: " <> ToString[Round[Max[s1], .01]] <> "  -  sig per unit time: " <> ToString[Round[1000 Max[s1]/(tr1 + n tr1), .01]], Bold, 14, Black, FontFamily -> "Helvetica"], "",
		Style["sig per unit time at fa  - s1: " <> ToString[Round[1000 p1/(tr1 + n tr1), .01]]<>"  -  s2: "<>ToString[Round[1000 p2/(tr1 + n tr1), .01]], Bold, 14, Black, FontFamily -> "Helvetica"]
	}, Alignment -> Center]
	, {{tr1, 50, "first tr"}, 10, 100, 10, ControlType -> Manipulator}
	, {{n, 19, "tr ratio"}, 2, 20, 1, ControlType -> Manipulator}
	, {{fa, 60, "flip angle"}, ang, ControlType -> Manipulator}
	, {{r, True, "fix scale"}, {True, False}}
	, {ang, ControlType -> None}
	, {s1, ControlType -> None}
	, {s2, ControlType -> None}
	, {s2a, ControlType -> None}
	, {p1, ControlType -> None}
	, {p2, ControlType -> None}
	, Initialization :> (ang = Range[1, 180])
]


(* ::Subsubsection::Closed:: *)
(*ErnstAngle*)


SyntaxInformation[ErnstAngle] = {"ArgumentsPattern" -> {_., _.}};

ErnstAngle[] := ErnstAngle[1400, 15]

ErnstAngle[t1i_] := ErnstAngle[t1i, 15]

ErnstAngle[t1i_, tri_] := Manipulate[
	sge = (Sin[a Degree] (1 - Exp[-tr/t1]))/(1 - Cos[a Degree] Exp[-tr/t1]);
	ang = Round[N@ArcCos[Exp[-tr/t1]]/Degree, .1];
	top = {ang, sge /. a -> ang};
	pt = {act, sge /. a -> act};
	loss = Round[100 (sge /. a -> act)/(sge /. a -> ang)];
	
	Show[
		Plot[sge /. a -> x, {x, 0, 90}, GridLines -> {{ang}, {pt[[2]]}}, Ticks -> {Automatic, None}, PlotRange -> {All, {0, 1.4 top[[2]]}},
			PlotLabel -> "Actual flip angle: " <> ToString[act] <> " (" <> ToString[loss] <> " %)"],
		ListPlot[{Callout[top, top[[1]]], pt}]
	],
	
	{{t1, t1i, "t1 relaxation"}, 100, 5000},
	{{tr, tri, "repetition time"}, 1, 100},
	{{act, 5, "actual ang"}, 0, 90},
	{a, ControlType -> None},
	{pt, ControlType -> None},
	{loss, ControlType -> None},
	{ang, ControlType -> None},
	{sge, ControlType -> None},
	{top, ControlType -> None}
]


(* ::Section:: *)
(*End Package*)


End[]

EndPackage[]
