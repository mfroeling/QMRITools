(* ::Package:: *)

(* ::Title:: *)
(*QMRITools MuscleBidsTools*)


(* ::Subtitle:: *)
(*Written by: Martijn Froeling, PhD*)
(*m.froeling@gmail.com*)


(* ::Section:: *)
(*Begin Package*)


BeginPackage["QMRITools`MuscleBidsTools`", Join[{"Developer`"}, Complement[QMRITools`$Contexts, {"QMRITools`MuscleBidsTools`"}]]];


(* ::Section:: *)
(*Usage Notes*)


(* ::Subsection::Closed:: *)
(*Functions*)


ImportJSON::usage = 
"ImportJSON[file] imports a JSON file as rawJSON."

GetJSONPosition::usage = 
"GetJSONPosition[{json..}, {{key, value}..}] gets the position from a list of JSON association lists where keys have the given value.
GetJSONPosition[{json..}, {{key, value}..}, sortkey] same but finally sorts the positions for the value of the sortkey."

MergeJSON::usage = 
"MergeJSON[{json..}] merges a list of JSON association lists where duplicate keys with the same values are removed and duplicate keys with different values are merged."


SelectSubjects::usage = 
"SelectSubjects[dir] selects the subjects in the given data directory which has a config file."

ViewConfig::usage = 
"ViewConfig[config] shows a config file for Muscle Bids processing."

ViewProtocolNames::usage = 
"ViewProtocolNames[folder] shows the protocol names in the radData folder specified by the config file with the series number and protocol name from 
the json files in the raw folders for each subject and session."

GetProtocolNames::usage = 
"GetProtocolNames[config, subs] gets the list of protocol names in het specified subject folder."

CheckConfigLabels::usage = 
"CheckConfigLabels[dir, subs] checks for each sub in subs if the protocol names that are defined in the config file in dir are present."


GetConfig::usage = 
"GetConfig[folder] imports a Muscle Bids config file from the given folder."

MergeConfig::usage =
"MergeConfig[assoc, replace] merges the replace association with the assoc association."


PartitionBidsName::usage = 
"PartitionBidsName[name] converts a Bids name to the Bids labels as an association, i.e. {\"sub\",\"ses\",\"stk\",\"rep\",\"type\",\"suf\"}."

PartitionBidsFolderName::usage = 
"PartitionBidsFolderName[fol] partitions the Bids folder and file name. It returns the bids root folder and the label parts using PartitionBidsName."

GenerateBidsName::usage = 
"GenerateBidsName[parts] generates a Bids file name from the Bids labels association which can be generated by PartitionBidsName."

GenerateBidsFolderName::usage = 
"GenerateBidsFolderName[parts] generates a Bids folder name from the Bids labels association which can be generated by PartitionBidsFolderName."

GenerateBidsFileName::usage = 
"GenerateBidsFileName[parts] generates a Bids file name from the Bids labels association which can be generated by PartitionBidsName.
GenerateBidsFileName[fol, parts] the same but with a custom root folder."

SelectBidsFolders::usage =
"SelectBidsFolders[fol, tag] selects all folders in the fol with the name tag."

SelectBidsSubjects::usage =
"SelectBidsSubjects[fol] selects all subjects in the bids folder."

SelectBidsSessions::usage =
"SelectBidsSessions[fol] selects all sessions in the bids subject folder."


BidsDcmToNii::usage =
"BidsDcmToNii[dir] converts the bids sourceFolder with dicom files to raw nii files based on the config file."

MuscleBidsConvert::usage =
"MuscleBidsConvert[dir] converts all raw nii data in the to Muscle-Bids named nii based on the config file in the bids sourceFolder dir."

MuscleBidsProcess::usage = 
"MuscleBidsProcess[dir] processes all Muscle-Bids named nii based on the config file in the bids sourceFolder dir."

MuscleBidsMerge::usage = 
"MuscleBidsMerge[dir] merges multiple stack data for all Muscle-Bids named nii based on the config file in the bids sourceFolder dir."

MuscleBidsSegment::usage = 
"MuscleBidsSegment[dir] segments the data of Muscle-Bids named nii based on the config file in the bids sourceFolder dir. The segmentations are generated by the function SegmentData."

MuscleBidsTractography::usage =
"MuscleBidsTractography[dir] performs tractography on the Muscle-Bids named nii based on the config file in the bids sourceFolder dir. If a segmentation is present it is used as a mask for per muscle segmentation."

MuscleBidsAnalysis::usage = 
"MuscleBidsAnalysis[dir] performs analysis on the Muscle-Bids named nii based on the config file in the bids sourceFolder dir. If a segmentation is present it is used to calculate the mean per segmentation."

CheckDataDescription::usage =
"CheckDataDescription[description] checks the data description config file used in BidsDcmToNii, MuscleBidsConvert, MuscleBidsProcess, and MuscleBidsMerge."


(* ::Subsection::Closed:: *)
(*Options*)


BidsIncludeSession::usage = 
"BidsIncludeSession is an option for BidsDcmToNii. If True session folders will be used in output even if they are not specified."

DeleteAfterConversion::usage = 
"DeleteAfterConversion is an option for MuscleBidsConvert. If set True all files that have been converted will be deleted."

BidsTractographyMethod::usage =
"BidsTractographyMethod is an option for MuscleBidsTractography and can be \"Full\", \"Tractography\" or \"Segmentation\". 
With Tractography only the tractography is performed without segmentation.
With Segmentation only the segmentation is performed without tractography. With Full both are performed."

BidsOutputImages::usage = 
"BidsOutputImages is an option for MuscleBidsAnalysis. If set True the output images are saved in the output folder."

ProcessSubjects::usage = 
"ProcessSubjects is an option for Bids functions. Can be a list of bids subject names else it is All."

VersionCheck::usage = 
"VersionCheck is an option for all Bids functions. If set True data processed with an old version is reprocessed."


(* ::Subsection::Closed:: *)
(*Error Messages*)


CheckDataDescription::key = "Datasets have duplicate names which is not allowed."

CheckDataDescription::type = "Unknown Muscle-BIDS type: `1`, using folder \"miss\"."

CheckDataDescription::class = "Unknown Muscle-BIDS Class: `1`. Must be \"Volume\", \"Stacks\", \"Repetitions\", \"Chunks\", \"Acquisitions\"."

CheckDataDescription::lab = "Invalid combination of Class and Label: `1` with `2` is not allowed."

CheckDataDescription::man = "Mandatory values `1` are not in the data description."

CheckDataDescription::stk = "Class \"stacks\" or \"Chunk\" is used but overlap is not defined, assuming overlap 0."

GetConfig::conf = "Could not find config file in given folder."


(* ::Section:: *)
(*Functions*)


Begin["`Private`"] 


debugBids[x___]:=If[$debugBids, Print[x]];


(* ::Subsection:: *)
(*BIDS name and select*)


(* ::Subsubsection::Closed:: *)
(*General Definitions*)


bidsTypes = <|
	(*anata types*)
	"T1w"->"anat", "T1w-FS"->"anat", "T2w"->"anat", "T2w-FS"->"anat",
	(*dixon*)
	"megre"->"dix", "tse"->"dix",
	(*quant types*)
	"mese"->"quant",
	"T1"->"quant", "T2"->"quant", "wT2"->"quant",
	(*diff types*)
	"dwi"->"dwi",
	(*seg types*)
	"seg"->"seg"
|>;


bidsName = {"sub", "ses", "vol", "stk", "chunk", "rep", "acq" ,"part", "type", "suf"};


bidsClass = {"Volume", "Volumes", "Stacks", "Repetitions", "Chunks", "Acquisitions", "Mixed"};


dataToLog =If[KeyExistsQ[#, $Failed], 
	"Wrong data description: " <> #[$Failed], 
	StringJoin[ToString[#[[1]]] <> ": " <> ToString[#[[2]]] <> "; " & /@ Normal[KeyDrop[#, {"Process", "Merging", "Segment", "Tractography"}]]]
]&;


notAllowed = {"-"->"", "_"->"", "."->"", " "->""};
StringStrip = StringReplace[#, notAllowed]&;


(* ::Subsubsection::Closed:: *)
(*PartitionBidsName*)


SyntaxInformation[PartitionBidsName] = {"ArgumentsPattern" -> {_}};

PartitionBidsName[list_?ListQ]:=PartitionBidsName/@list

PartitionBidsName[string_?StringQ]:=Block[{parts, entity, suffix, suf},
	(*first split on "_" then on "-"*)
	parts = StringSplit[#,"-"]& /@ StringSplit[string, "_"];
	(*if length is 2 its entity else it is suffix*)
	entity = Rule@@#& /@ Select[parts, Length[#]===2&];
	suf = Flatten[Select[parts, Length[#]=!=2&]];

	(*see if type is part of suffixes*)
	suf = Which[
		suf==={}, {"suf"->{}},
		MemberQ[Keys[bidsTypes], First@suf], {"type"->First@suf,"suf"->Rest@suf},
		True, {"suf"->suf}
	];

	(*give as association*)
	Association[Join[entity, suf]]
]


(* ::Subsubsection::Closed:: *)
(*PartitionBidsFolderName*)


SyntaxInformation[PartitionBidsFolderName] = {"ArgumentsPattern" -> {_}};

PartitionBidsFolderName[fol_?ListQ]:=PartitionBidsFolderName/@fol

PartitionBidsFolderName[fol_?StringQ]:={
	First@StringSplit[fol, "sub-"], 
	PartitionBidsName@StringJoin@Riffle[Select[FileNameSplit[fol],StringContainsQ[#,"-"]&],"_"]
}


(* ::Subsubsection::Closed:: *)
(*GenerateBidsName*)


SyntaxInformation[GenerateBidsName] = {"ArgumentsPattern" -> {_}};

GenerateBidsName[list_?ListQ]:=GenerateBidsName/@list

GenerateBidsName[parts_?AssociationQ]:=StringJoin[Riffle[Select[Join[
	BidsString[parts, {"sub", "ses", "vol", "stk", "rep", "chunk", "acq", "part"}], 
	BidsValue[parts, {"type", "suf"}]
], # =!= ""&], "_"]]


(* ::Subsubsection::Closed:: *)
(*GenerateBidsFolderName*)


SyntaxInformation[GenerateBidsFolderName] = {"ArgumentsPattern" -> {_, _.}};

GenerateBidsFolderName[fol_?StringQ, list_?ListQ]:=GenerateBidsFolderName[fol,#]& /@ list

GenerateBidsFolderName[fol_?StringQ, parts_?AssociationQ]:=FileNameJoin[Select[{
	fol, BidsString[parts, "sub"], BidsString[parts, "ses"]
}, # =!= ""&]]


(* ::Subsubsection::Closed:: *)
(*GenerateBidsFileName*)


SyntaxInformation[GenerateBidsFileName] = {"ArgumentsPattern" -> {_, _.}};

GenerateBidsFileName[list_?ListQ]:=GenerateBidsFileName["", #]& /@ list

GenerateBidsFileName[fol_?StringQ, list_?ListQ]:=GenerateBidsFileName[fol, #]& /@ list

GenerateBidsFileName[parts_?AssociationQ]:=GenerateBidsFileName["", parts]

GenerateBidsFileName[fol_?StringQ, parts_?AssociationQ]:=FileNameJoin[Select[{
	(*folders*)
	GenerateBidsFolderName[fol, parts], BidsType[parts], 
	(*filename*)
	GenerateBidsName[parts]
}, # =!= ""&]]


(* ::Subsubsection::Closed:: *)
(*BidsType*)


BidsType[type_?StringQ]:= bidsTypes[type] /. {Missing[___]->"miss"} 

BidsType[parts_?AssociationQ]:= bidsTypes[parts["type"]] /. {Missing[___]->"miss"} 


(* ::Subsubsection::Closed:: *)
(*BidsValue*)


BidsValue[parts_, val_?ListQ]:=Flatten[BidsValue[parts, #] &/@ val]

BidsValue[parts_, val_?StringQ]:= parts[val]/. {Missing[___] -> ""} 


(* ::Subsubsection::Closed:: *)
(*BidsString*)


BidsString[parts_, val_?ListQ]:=BidsString[parts, #] &/@ val

BidsString[parts_, val_?StringQ]:=Block[{str},
	str = BidsValue[parts, val];
	If[str==="", "", val<>"-"<>str]
]


(* ::Subsection:: *)
(*SelectBids*)


(* ::Subsubsection::Closed:: *)
(*SelectBids*)


SelectBids[folder_?ListQ, entity_?StringQ]:=Flatten[SelectBids[#,entity]&/@folder]

SelectBids[folder_?StringQ, entity_?StringQ]:=Block[{
		baseName, start, end, what
	},
	baseName = StringStartsQ[FileNameTake[folder], #]&;
	start = Which[baseName["ses-"], 3, baseName["sub-"], 2, True, 1];
	end = Switch[entity, "sub", 1, "ses", 2, _, 3];
	what = {"sub-", "ses-", entity}[[start;;end]];
	Fold[SelectBidsI, folder, what]
]

SelectBidsI[fol_, what_]:=Select[FileNames[All, fol], DirectoryQ[#] && StringStartsQ[FileNameTake[#], what]&]


(* ::Subsubsection::Closed:: *)
(*SelectBidsFolders*)


SyntaxInformation[SelectBidsFolders] = {"ArgumentsPattern" -> {_, _}};

SelectBidsFolders[fol_?ListQ, tag_] := SelectBids[fol, tag]


(* ::Subsubsection::Closed:: *)
(*SelectBidsSubjects*)


SyntaxInformation[SelectBidsSubjects] = {"ArgumentsPattern" -> {_}};

SelectBidsSubjects[fol_] := SelectBids[fol, "sub"]


(* ::Subsubsection::Closed:: *)
(*SelectBidsSessions*)


SyntaxInformation[SelectBidsSessions] = {"ArgumentsPattern" -> {_}};

SelectBidsSessions[fol_?ListQ]:=SelectBids[fol, "ses"]


(* ::Subsection:: *)
(*Config*)


(* ::Subsubsection::Closed:: *)
(*Default config values*)


defaultConfig = <|
	"folders" -> <|
		"dicomData" -> "01_sourcedata", 
		"rawData" -> "02_rawdata", 
		"derivedData" -> "03_derivatives",
		"mergeData" -> "04_merged", 
		"analysis" -> "05_analysis"
	|>,
	"conversion"-> <|
		"Version"->1
	|>,
	"Process" -> <|
		"Masking" -> 5,
		"FlipPermute" -> {{1, -1, 1}, {"z", "y", "x"}},
		"SplitRegistration" -> True,
		"IVIMCorrection" -> True,
		"GradientCorrection" -> False,
		"FaciculationDetection" -> False
	|>,
	"Merging" -> <|
		"Overlap" -> 0,
		"Padding" -> 0,
		"Motion" -> True,
		"Reverse" -> False,
		"SplitRegistration" -> True
	|>,
	"Segment" -> <|
		"Device" -> "GPU",
		"VoxSize" -> Automatic,
		"Method" -> Automatic
	|>,
	"Tractography" -><|
		"FlipPermute" -> {{1, 1, 1}, {"x", "y", "z"}}
	|>,
	"Options" -> <|
		"MaskErosion" -> True,
		"TractWeigthing" -> False
	|>
|>;


(* ::Subsubsection::Closed:: *)
(*ConfigLookup*)


ConfigLookup[config_?StringQ, key_?StringQ, def_?StringQ] := ConfigLookup[GetConfig[config], key, def]

ConfigLookup[config_?AssociationQ, key_?StringQ, def_?StringQ] := Lookup[ConfigLookup[config, key], def, defaultConfig[key, def]];

ConfigLookup[config_?StringQ, key_?StringQ] := GetConfig[GetConfig, key]

ConfigLookup[config_?AssociationQ, key_?StringQ] := Lookup[config, key, defaultConfig[key]]


(* ::Subsubsection::Closed:: *)
(*CheckConfig*)


CheckConfig[infol_?StringQ, outfol_?StringQ]:=Block[{conf, nam},
	nam = GenerateBidsName[PartitionBidsFolderName[outfol][[-1]]];
	conf = Quiet@GetConfig[infol, nam];
	debugBids[FileNameJoin[{outfol, nam<>"_config.json"}]];

	If[conf =!= $Failed,
		Export[FileNameJoin[{outfol, nam<>"_config.json"}], conf];
		{True, conf}, 
		{False, <||>}
	]
]


(* ::Subsubsection::Closed:: *)
(*GetConfig*)


GetConfig[folder_?StringQ]:=GetConfig[folder, ""]

GetConfig[folder_?StringQ, nam_?StringQ]:=Block[{file},
	(*normal config*)
	If[DirectoryQ[folder],
		(*normal config*)
		file = FileNameJoin[{folder,"config.json"}];
		If[FileExistsQ[file],
			Import[file, "RawJSON"],
			(*subject name config*)
			file = FileNameJoin[{folder, nam<>"_config.json"}];
			If[FileExistsQ[file],
				Import[file, "RawJSON"],
				Message[GetConfig::conf];
				Return[$Failed]
			]
		],
		If[FileExistsQ[folder], 
			Import[folder, "RawJSON"],
			Return[$Failed]
		]
	]
]

(*
{"Merging", {Process, Moveing, Target}, {Overlap, Split, Reverse, Motion}}
*)



(* ::Subsubsection::Closed:: *)
(*MergeConfig*)


MergeConfig[assoc_?ListQ, replace_?AssociationQ] := Normal@MergeConfig[Association@assoc, replace]

MergeConfig[assoc_?AssociationQ, replace_?ListQ] := MergeConfig[assoc, Association@replace]

MergeConfig[assoc_?AssociationQ, replace_?AssociationQ] := Block[{assocNew }, 
	assocNew = Association[assoc];
	KeyValueMap[Function[{key, subAssoc},
		assocNew = If[AssociationQ[subAssoc],
			If[KeyExistsQ[assocNew, key],
				ReplacePart[assocNew, key -> MergeConfig[assocNew[key], subAssoc]],
				Append[assocNew, key -> subAssoc]],
			If[KeyExistsQ[assocNew, key],
				ReplacePart[assocNew, key -> subAssoc],
				Append[assocNew, key -> subAssoc]]
		]
	], replace];
	assocNew
]


(* ::Subsection:: *)
(*JSON*)


(* ::Subsubsection::Closed:: *)
(*ImportJSON*)


ImportJSON[file_]:=Import[file, "RawJSON"]


(* ::Subsubsection::Closed:: *)
(*GetJSONPosition*)


GetJSONPosition[json_, selection_]:=GetJSONPosition[json, selection, ""]

GetJSONPosition[json_, selection_, sort_]:=Block[{selIndex, selFunc, list, key, val, inds, pos},
	(*selection functions*)
	selIndex = StringReplace[ToLowerCase[Last[Flatten[{#1 /. #3}]]], {"wip " -> "", "wip_"->""}] === ToLowerCase[#2] &;
	selFunc = (list=#1; key=#2[[1]]; val=#2[[2]]; Select[list, selIndex[key, val, json[[#]]]&])&;

	(*get the file positions*)
	pos = Fold[selFunc, Range[Length[json]], selection];
	(*if sort is empty return the positions or if pos is empty return {}*)
	If[sort===""||pos==={}, pos, pos[[Ordering[sort /. json[[pos]]]]]]
]


(* ::Subsubsection::Closed:: *)
(*MergeJSON*)


MergeJSON[json:{_?AssociationQ..}]:=Block[{keys},
	keys = DeleteDuplicates[Flatten[Keys /@ json]];
	Association[If[#[[2]]==={}, Nothing, #]& /@ Thread[
		keys->(If[Length[#]===1,First@#,#]& /@ ((DeleteDuplicates /@ Transpose[(# /@ keys)& /@ json]) /. Missing[___]->Nothing))
	]]
]


(* ::Subsection:: *)
(*BidsSupport*)


(* ::Subsubsection::Closed:: *)
(*ViewConfig*)


SyntaxInformation[ViewConfig] = {"ArgumentsPattern" -> {_}};

ViewConfig[folder_?StringQ]:=ViewConfig[GetConfig[folder]]

ViewConfig[config_?AssociationQ]:=TabView[# -> Which[
	# === "datasets", ViewConfig[config[#]],
	# === "analysis", If[KeyExistsQ[config["analysis"], "Analysis"], MakeTable[config[#]], ViewConfig[config[#]]], 
	True, MakeTable[config[#]]
]& /@ Keys[config], ControlPlacement -> Left]


MakeTable[association_] := Block[{value},
	Grid[{#, 
		value = association[#];
		Which[
			AssociationQ[value], MakeTable[value],
			ListQ[value] && Length[value] > 0, If[AssociationQ[First[value]],
				Column[MakeTable /@ value],
				If[ListQ[value],
					Which[
						Length[value] && ArrayDepth == 2 > 10, Grid[value],
						Length[value] > 6, Column[Row[#, ", "]&/@Partition[value, 6, 6, 1,{}]],
						VectorQ[value], Row[value, ", "], 
						True, Column[value]],
					value]
				], 
			True, value
		]
	} & /@ Keys[association], Frame -> All, Alignment -> Left, 
	Background -> {{Gray, {White}}, White}, Spacings -> {1, 0.5}]
]


(* ::Subsubsection::Closed:: *)
(*ViewProtocolNames*)


Options[ViewProtocolNames] = {
	ProcessSubjects->All
}

SyntaxInformation[ViewProtocolNames] = {"ArgumentsPattern" -> {_, OptionsPattern[]}};

ViewProtocolNames[folder_?StringQ, opts:OptionsPattern[]] := ViewProtocolNames[GetConfig[folder], opts]

ViewProtocolNames[config_?AssociationQ, OptionsPattern[]] := Block[{subs, dataFols, fold, list, duplicates, json},
	
	subs = OptionValue[ProcessSubjects];
	dataFols = SelectBids[ConfigLookup[config, "folders", "rawData"], "ses"];

	subs = If[subs===All||subs==="All", dataFols, 
		Select[dataFols, MemberQ[SubNameToBids[subs, "Sub"], SubNameToBids[#]]&]
	];

	MenuView[(
		GetProtocolNames[fold = #];
		duplicates = Keys[Select[Counts[list[[All, 2]]], # > 1 &]];
		list = If[MemberQ[duplicates, #[[2]]], {#[[1]], Style[#[[2]], Bold, Red]}, #] & /@ list;
		(*make output*)
		fold -> Grid[list, Alignment -> Left, Frame -> All, Spacings -> {1, 1.2}]
	) & /@ subs, ControlPlacement -> Top]
]


(* ::Subsubsection::Closed:: *)
(*ViewProtocolNames*)


GetProtocolNames[fold_?ListQ] := GetProtocolNames /@ fold

GetProtocolNames[fold_?StringQ] := Block[{},
	list = Sort@DeleteDuplicates[(
		Quiet[json = ImportJSON[#]];
		{
			json["SeriesNumber"], 
			n = json["ProtocolName"]; If[StringQ[n], StringTrim[StringReplace[n, "WIP"->""]], n]
		}
	) & /@ FileNames["*.json", fold, 2]]; 
	Print[list];
	list=Select[list, 
		Head[#[[1]]] =!= Missing && Head[#[[1]]] =!= $Failed && 
		!StringContainsQ[#[[2]], RegularExpression["_\\d{6}\\.\\d{3}"]] &
	];
		Print[list];
	list
]


GetProtocolNames[dir_, sub_] := Block[{config, dataFols, subs},
	config = If[AssociationQ[dir], dir, GetConfig[dir]];
	dataFols = SelectBids[ConfigLookup[config, "folders", "rawData"], "ses"];
	subs = If[sub === All || sub === "All",	dataFols,
		Select[dataFols, MemberQ[SubNameToBids[Flatten[{sub}], "Sub"], SubNameToBids[#]] &]];
	GetProtocolNames[subs][[If[StringQ[sub], 1, All]]]
]


(* ::Subsubsection::Closed:: *)
(*SelectSubjects*)


SyntaxInformation[SelectSubjects] = {"ArgumentsPattern" -> {_}};

SelectSubjects[dir_?StringQ] := DynamicModule[{fol, selectedSubjects, list},
	fol = FileNameJoin[{dir, ConfigLookup[dir, "folders", "dicomData"]}];
	list = Sort[FileBaseName/@ Select[FileNames["*", fol], DirectoryQ]];
	selectedSubjects = {};
	Column[{
		CheckboxBar[Dynamic[selectedSubjects], list, Appearance -> "Vertical" -> {Min[{15, Length@list}], Automatic}, Method -> "Active"],
		Row[{
			Button["Select All", selectedSubjects = list],
			Button["Deselect All", selectedSubjects = {}],
			Button["Copy selected list to clipboard", CopyToClipboard[selectedSubjects]]
		}]
	}]
];


(* ::Subsubsection::Closed:: *)
(*CheckConfigLabels*)


CheckConfigLabels[dir_, sub_?ListQ] := CheckConfigLabels[dir, #] & /@ sub

CheckConfigLabels[dir_, sub_?StringQ] := Block[{names, labels},
	names = GetProtocolNames[dir, sub][[All, 2]];
	labels = Flatten[#["Label"] & /@ Values[GetConfig[dir]["datasets"]]];
	sub -> Select[labels, ! MemberQ[names, #] &]
]


(* ::Subsubsection::Closed:: *)
(*SubNameToBids*)


Options[SubNameToBids] = {BidsIncludeSession -> True};

SubNameToBids[nameIn_?ListQ, opts : OptionsPattern[]] := SubNameToBids[#, "", opts] & /@ nameIn

SubNameToBids[nameIn_?ListQ, met_, opts : OptionsPattern[]] := SubNameToBids[#, met, opts] & /@ nameIn

SubNameToBids[nameIn_?StringQ, opts : OptionsPattern[]]:= SubNameToBids[nameIn, "", opts]

SubNameToBids[nameIn_?StringQ, met_, OptionsPattern[]] := Block[{ass, keys, name, ses},
	(*get the names*)
	ass = Switch[met, 
		"Sub", PartitionBidsName, 
		"BidsDcmToNii", PartitionBidsName[FileNameTake[#, {2, -1}]]&, 
		_, PartitionBidsFolderName[#][[-1]]&
	]@nameIn;
	keys = Keys[ass];

	(*if bids take sub key else assume first suf is name*)
	name = "sub" -> If[MemberQ[keys, "sub"], ass["sub"], First[ass["suf"]]];

	(*if bids take ses key else assume last suf is session*)
	ses = "ses" -> If[MemberQ[keys, "ses"],
		(*session is present take session*)
		ass["ses"],
		(*more than one suf last is session*)
		If[Length[ass["suf"]] > 1, Last[ass["suf"]],
			(*no session,see if need to be forced*)
			If[OptionValue[BidsIncludeSession], "001", ""]]];
	Association[{name, ses, "suf" -> {}}]
]


(* ::Subsubsection::Closed:: *)
(*GetClassName*)


GetClassName[class_, nameIn_]:=Switch[class,
	"Volume"|"Volumes"|"Stacks"|"Repetitions"|"Acquisitions"|"Chunks",
	Switch[class, 
		"Volume"|"Volumes", "vol",
		"Stacks", "stk",
		"Chunks", "chunk", 
		"Repetitions", "rep", 
		"Acquisitions", "acq"
	] -> StringStrip[nameIn]
]


(* ::Subsubsection::Closed:: *)
(*CheckDataDescription*)


SyntaxInformation[CheckDataDescription] = {"ArgumentsPattern" -> {_, _}};

CheckDataDescription[dis_Association, met_] := Block[{duplicate, disK},
	If[!DuplicateFreeQ[Keys[dis]],
		(*datasets cannot have duplicate names*)
		Return[Message[CheckDataDescription::key];$Failed]
		,
		(*check if there are duplicated datasets, i.e. same type and suffix*)
		duplicate = !DuplicateFreeQ[{#["Type"], #["Suffix"]} & /@ Values[dis]];
		debugBids["data Descriptions duplicates: ", duplicate];

		(*If there are duplicates add the dataset name to the data Description*)
		disK = If[duplicate,
			KeySort[Join @@ #] & /@ Thread[{Values[dis], Association /@ Thread["Key" -> Keys[dis]]}],
			Values[dis]
		];
		Flatten[CheckDataDescription[Normal[#], met]& /@ disK]
	]
]

CheckDataDescription[dis:{_Rule..}, met_]:=Block[{ass, key, man, cls, typ, fail},
	(*Get the data Description keys*)
	ass = Association[dis];
	key = Keys[ass];
	(*fail output*)
	fail = Association[$Failed->ToString[Normal[ass]]];

	manLab = Switch[met,
		"MuscleBidsConvert", {"Label", "Type"},
		"MuscleBidsProcess", {"Type"},
		"MuscleBidsMerge", {"Type", "Merging"},
		"MuscleBidsSegment", {"Type"},
		"MuscleBidsTractography", {"Type"}
	];

	(*Check if mandatory keys are present*)
	man = ContainsAll[key, manLab];

	If[!man,
		Return[Message[CheckDataDescription::man, manLab]; fail],

		(*Check if type is valid*)
		If[!MemberQ[Keys[bidsTypes], ass["Type"]], Message[CheckDataDescription::type, ass["Type"]]];

		(*Check if class is present*)
		If[KeyExistsQ[ass, "Class"],
			(*if present add check class is valid*)
			If[!MemberQ[bidsClass, ass["Class"]], Return[Message[CheckDataDescription::class,ass["Class"]]; fail]],
			(*add class if not present*)
			ass = Association[ass, "Class"->"Volume"]
		];

		(*check if labels match class*)
		cls = Switch[ass["Class"],
			"Volume", StringQ[ass[["Label"]]],
			"Stacks"|"Volumes"|"Repetitions"|"Acquisitions"|"Mixed", ListQ[ass["Label"] && Length[ass]>1]
		];
		If[!cls, Return[Message[CheckDataDescription::lab, ass["Class"], ass["Label"]]; fail]];

		(*check suffic, in and out folder*)
		If[!KeyExistsQ[ass, "Suffix"], ass = Association[ass, "Suffix"->""]];
		Switch[met,
			"MuscleBidsConvert",
			If[!KeyExistsQ[ass, "InFolder"], ass = Association[ass, "InFolder"->"raw"]];
			ass = Association[ass, "OutFolder" -> BidsType[ass["Type"]]];
			,
			"MuscleBidsProcess"|"MuscleBidsMerge"|"MuscleBidsSegment"|"MuscleBidsTractography",
			If[!KeyExistsQ[ass, "InFolder"], ass = Association[ass, "InFolder"->BidsType[ass["Type"]]]];
			ass = Association[ass, "OutFolder" -> BidsType[ass["Type"]]];			
		];

		(*output the completed data Description*)
		{KeySort@ass}
	]
]


(* ::Subsection::Closed:: *)
(*0. BidsFolderLoop*)


Options[BidsFolderLoop] = {
	(*loop method*)
	Method->"MuscleBidsConvert", 
	(*general options*)
	ProcessSubjects->All, 
	VersionCheck->False, 
	(*method specific options*)	
	DeleteAfterConversion->True, 
	BidsTractographyMethod->"Full",
	BidsOutputImages->"All"
};

SyntaxInformation[BidsFolderLoop] = {"ArgumentsPattern" -> {_, _, OptionsPattern[]}};

BidsFolderLoop[inFol_?StringQ, outFol_?StringQ, opts:OptionsPattern[]] := BidsFolderLoop[inFol, outFol, {""}, opts]

BidsFolderLoop[inFol_?StringQ, datDis_?AssociationQ, opts:OptionsPattern[]] := BidsFolderLoop[inFol, inFol, datDis, opts]

BidsFolderLoop[inFol_?StringQ, outFol_?StringQ, datDisIn_?AssociationQ, OptionsPattern[]] := Block[{
		met, datType, fols, subs, logFile, ass, nam, filesSl, jsons, versCheck, delete, tractMet,
		files, nTyp, pat, rfol, custConf, out, datDis, imOut
	},

	{met, subs, versCheck, delete, tractMet, imOut} = OptionValue[{
		Method, ProcessSubjects, VersionCheck, DeleteAfterConversion, BidsTractographyMethod, BidsOutputImages}];

	debugBids["Enter BidsFolderLoop for method: "<>met];
	debugBids[inFol];

	(*select the subjects and folders to be processed*)
	fols =Switch[met,
		"BidsDcmToNii", ResetLog[]; Select[FileNames[All, inFol], DirectoryQ],
		_, SelectBids[inFol, "ses"]
	];
	subs = If[subs===All||subs==="All", fols, 
		Select[fols, MemberQ[SubNameToBids[subs, "Sub"], SubNameToBids[#, met]]&]
	];

	debugBids[Column@subs];

	(*loop over the subjects*)
	Table[
		debugBids["input folder:", fol];

		(* -------------- Config and naming --------------*)

		(*get the BidsName*)
		ass = SubNameToBids[fol, met];
		nam = GenerateBidsName[ass];
		out = GenerateBidsFolderName[outFol, ass];

		debugBids["output folder:", out];

		(*check for custom config - merge if config exists in input folder and copy it to output folder*)
		debugBids[datDisIn];
		Switch[met,
			"BidsDcmToNii", 
			{custConf, datDis} = CheckConfig[fol, out],
			"MuscleBidsAnalysis",
			custConf = False;
			datDis = If[KeyExistsQ[datDisIn, "Analysis"],
				{datDisIn}, 
				Map[Join[datDisIn[#], <|"Key" -> #|>] &, Keys[datDisIn]]
			],
			_,
			{custConf, datDis} = CheckConfig[fol, out];
			debugBids[{custConf, datDis}];
			datDis = CheckDataDescription[MergeConfig[datDisIn, datDis], met];
		];

		(*-------------- Logging --------------*)
		debugBids[{"starting logging: ", met}];
		SetLogFile@Switch[met,
			"BidsDcmToNii", FileNameJoin[{outFol, "DcmToNii_"<>DateName[]<>".log"}],
			"MuscleBidsConvert", FileNameJoin[{fol, nam<>"_BIDSConvert.log"}],
			"MuscleBidsProcess", FileNameJoin[{out, nam<>"_BIDSProcess.log"}],
			"MuscleBidsMerge", FileNameJoin[{out, nam<>"_BIDSMerge.log"}],
			"MuscleBidsSegment", FileNameJoin[{out, nam<>"_BIDSSegment.log"}],
			"MuscleBidsTractography", FileNameJoin[{out, nam<>"_BIDSTractography.log"}],
			"MuscleBidsAnalysis", FileNameJoin[{out, nam<>"_BIDSAnalysis.log"}]
		];
		If[met=!= "BidsDcmToNii", ImportLog[]]; 
		ShowLog[];
		
		(*----*)AddToLog[{"Starting "<>met<>" for directory: ", fol}, True, 0];
		(*----*)If[custConf, AddToLog["**********   -----   Using custom config   -----   **********", 0]];
		If[met === "BidsDcmToNii",
			(*----*)AddToLog["Using Chris Rorden's dcm2niix.exe (https://github.com/rordenlab/dcm2niix)", 1];
		];

		(* -------------- The actual processing loops -------------- *)
		debugBids[{"starting method: ", met}];
		Switch[met,
			"BidsDcmToNii", BidsDcmToNiiI[fol, out, datDisIn],
			"MuscleBidsAnalysis", MuscleBidsAnalysisI[fol, outFol, #, versCheck, imOut]&/@datDis
			,
			_,
			(*loop over the data Descriptions*)
			Table[
				(*check if datDis is valid*)
				If[KeyExistsQ[type, $Failed],
					(*----*)AddToLog[dataToLog@type, 2, True];
					(*----*)AddToLog["Skipping", 3],
					(*if valid perform conversion*)
					(*----*)AddToLog[dataToLog@type, 2, True];
					rfol = SelectBids[fol, type["InFolder"]];
					(*method specific scripts: loop over all folders in subject/session folder*)
					Table[
						(*loop needs feedback to show where bugs are.*)
						Echo[DateString[], foli];
						Switch[met,
							"MuscleBidsConvert", MuscleBidsConvertI[foli, type, delete],
							"MuscleBidsProcess", MuscleBidsProcessI[foli, outFol, type, versCheck],
							"MuscleBidsMerge", MuscleBidsMergeI[foli, outFol, type, datDis, versCheck],
							"MuscleBidsSegment", MuscleBidsSegmentI[foli, outFol, type, datDis, versCheck],
							"MuscleBidsTractography", MuscleBidsTractographyI[foli, outFol, type, datDis, versCheck, tractMet]
						];(*close method switch*)
					, {foli, rfol}];(*Close sub folders loop*)		
				];(*close type check*)
			, {type, datDis}];(*close datatype loop*)
		]; (*close method switch*)

		(*clear log filename*)
		SetLogFile[];

	, {fol, subs}];(*close subject/ses folder loop*)
]


(* ::Subsection:: *)
(*1. BidsDcmToNii*)


(* ::Subsubsection::Closed:: *)
(*BidsDcmToNii*)


Options[BidsDcmToNii]={BidsIncludeSession->True, ProcessSubjects->All}

SyntaxInformation[BidsDcmToNii] = {"ArgumentsPattern" -> {_, _., OptionsPattern[]}};

BidsDcmToNii[folder_?StringQ, opts:OptionsPattern[]] := BidsDcmToNii[folder, GetConfig[folder], opts];


BidsDcmToNii[folder_?StringQ, config_?AssociationQ, opts:OptionsPattern[]] := Block[{dir},
	debugBids["starting BidsDcmToNii"];
	dir = Directory[]; SetDirectory[folder];
	BidsDcmToNii[
		ConfigLookup[config, "folders", "dicomData"],(*the input folder of the dcm data*)
		ConfigLookup[config, "folders", "rawData"],(*the output folder for conversion*)
		ConfigLookup[config, "conversion"],(*the conversion settings*)
		opts];
	SetDirectory[dir];
]


BidsDcmToNii[inFol_?StringQ, outFol_?StringQ, settings_, opts:OptionsPattern[]] := BidsFolderLoop[inFol, outFol, settings, Method->"BidsDcmToNii", opts]


(* ::Subsubsection::Closed:: *)
(*BidsDcmToNiiI*)


BidsDcmToNiiI[fol_, outI_, settings_]:=Block[{out},
	(*define the out folder*)
	out = FileNameJoin[{outI, "raw"}];
	(*----*)AddToLog[{"Output folder: ", out}, 1];
	Quiet[CreateDirectory[out]];

	(*perform the conversions only when output folder is empty*)
	If[EmptyDirectoryQ[out],
		(*perform conversion*)			
		(*----*)AddToLog["Starting the conversion", 1, True];
		DcmToNii[FileNameJoin[{Directory[],#}]&/@{fol,out}, 
			MonitorCalc->False, UseVersion->settings["Version"]];
		(*----*)AddToLog["Folder was converted", 1],
		(*----*)AddToLog["Folder was skipped since output folder already exists", 1];
	];
]


(* ::Subsection:: *)
(*2. MuscleBidsConvert*)


(* ::Subsubsection::Closed:: *)
(*MuscleBidsConvert*)


Options[MuscleBidsConvert] = {DeleteAfterConversion->True, ProcessSubjects->All};

SyntaxInformation[MuscleBidsConvert] = {"ArgumentsPattern" -> {_, _., OptionsPattern[]}};

MuscleBidsConvert[folder_?StringQ, opts:OptionsPattern[]] := MuscleBidsConvert[folder, GetConfig[folder], opts];


MuscleBidsConvert[folder_?StringQ, config_?AssociationQ, opts:OptionsPattern[]]:=Block[{dir},
	debugBids["starting MuscleBidsConvert"];
	dir = Directory[]; SetDirectory[folder];
	MuscleBidsConvert[
		ConfigLookup[config, "folders", "rawData"],(*the input and output folder for the data*)
		ConfigLookup[config, "folders", "rawData"],
		config["datasets"],(*what data for conversion*)
		opts];
	SetDirectory[dir];
]


MuscleBidsConvert[niiFol_?StringQ, outFol_?StringQ, datDis_?AssociationQ, opts:OptionsPattern[]]:= BidsFolderLoop[niiFol, outFol, datDis, Method->"MuscleBidsConvert", opts]


(* ::Subsubsection::Closed:: *)
(*MuscleBidsConvertI*)


MuscleBidsConvertI[foli_, datType_, del_]:=Block[{
		type, fol, parts, files, json, infoExtra, pos, posIn, info, data, vox, 
		grad, val, suffix, outFile, echo, nEch, fit, labels, class, types,
		vx, vy, vz, dx, dy, dz, sx, sy, sz, off, dfile, hasb, hdr, nSl, len,
		labs, noFiles
	},

	debugBids["Starting MuscleBidsConvertI"];
	debugBids[foli];

	(*see if one label or session|repetition*)
	{fol, parts} = PartitionBidsFolderName[foli];

	(*user defined data description*)
	labels = Flatten[{datType["Label"]}];
	type = datType["Type"];
	class = datType["Class"];
	
	(*for joining dti data*)
	labels = If[class === "Volumes", {labels}, labels];

	(*-----*)AddToLog[{"Converting", ToString[Length[labels]], class}, 2, True];
	(*-----*)AddToLog[StringJoin@@Riffle[labels,", "], 3];

	(*loop over stac names*)
	Table[
		(*import the json belonging to name*)
		(*-----*)AddToLog[{"Converting", nameIn, "as", type,":"}, True, 3];
		files = Flatten@If[class === "Volumes",
			FileNames["*"<>StringReplace[#," "->"_"]<>"*.json", foli]&/@nameIn,
			FileNames["*"<>StringReplace[nameIn," "->"_"]<>"*.json", foli]
		];

		(*add settings to output json*)
		infoExtra = <|
			"ConversionSoftware"->"QMRITools.com", 
			"ConversionSoftwareVersion"->QMRITools`$InstalledVersion,
			If[class==="Volume", "Volume"->nameIn, Nothing],
			If[class==="Volumes", "Volumes"->nameIn, Nothing],
			If[class==="Repetitions", "Repetition"->nameIn, Nothing],
			If[class ==="Acquisitions", "Acquisition"->nameIn, Nothing],
			If[class==="Stacks" || class==="Chunks" || class==="Mixed", "Stack"->nameIn, Nothing],
			If[class==="Stacks" || class==="Chunks" || class==="Mixed", "OverLap"->datType["Overlap"], Nothing]
		|>;

		(*check if ther are files to do something with*)
		If[Length@Flatten[files]===0,
			(*no json files found*)
			{"!!!!!!!!! No json files found !!!!!!!!!!"}
			(*-----*)AddToLog[{"No json files found with label ", nameIn , " skipping conversion"}, 4],

			(*if json files found import them*)
			json = ImportJSON/@files;

			(*see which data type is expected*)
			Switch[datType["Type"],

				(*-------------------------------------------------*)
				(*-------- DIXON conversion script megre ----------*)
				(*-------------------------------------------------*)
				"megre"|"tse",

				Switch[datType["Process", "Method"],
					"Dixon-P",
					(*philips data with online recon*)
					suffix = datType["Process", "Types"];
					debugBids[types];

					If[ListQ[suffix]&&!MatrixQ[suffix],
						(*data is a 4D dataset and the order is in types*)

						pos = GetJSONPosition[json, {{"ProtocolName", nameIn}}];
						debugBids["Converting Dix data, json position: ", pos];
						(*get the json and data*)
						(*-----*)AddToLog[{"Importing ", Length[pos], "dataset with properties: ", nameIn}, 4];

						(*get the json and data*)
						pos = First@pos;
						info = json[[pos]];
						{data, vox} = ImportNii[ConvertExtension[files[[pos]],".nii"], NiiScaling->False];
						(*-----*)AddToLog[{"Dimensions:", Dimensions@data, "; Voxel size:", vox}, 4];

						(*loop over types and export them*)
						Table[(*export to the correct folder*)
							outFile = GenerateBidsFileName[fol, <|parts, "type"->type, GetClassName[class, nameIn], 
								"suf"->Flatten@{datType["Suffix"], suffix[[i]]}|>];
							(*-----*)AddToLog[{"Exporting to file:", outFile}, 4];
							ExportNii[data[[All, i]], vox, ConvertExtension[outFile, ".nii"]];
							Export[ConvertExtension[outFile, ".json"], MergeJSON[{info, infoExtra}]];
						,{i, 1, Length[suffix]}];

						(*export used files*)
						Quiet@If[del,
							DeleteFile[ConvertExtension[files[[pos]],".nii"]];
							DeleteFile[ConvertExtension[files[[pos]],".nii.gz"]];
							DeleteFile[ConvertExtension[files[[pos]],".json"]]
						];
					];

					If[ListQ[suffix]&&MatrixQ[suffix],
						(*data is multiple files and the order and extention is in types*)
						{suffix, types} = Transpose[suffix];
						
						debugBids[suffix, types];
						pos = GetJSONPosition[json, {{"ProtocolName", nameIn}}];
						debugBids["Converting Dix data, json position: ", pos];
						(*get the json and data*)
						(*-----*)AddToLog[{"Importing ", Length[pos], "dataset with properties: ", nameIn}, 4];

						labs = Last[StringSplit[FileBaseName[#], "_"]] & /@files;
						debugBids["file labels: ", labs];

						(*loop over types and export them*)
						pos = Table[(*export to the correct folder*)
							pos = Position[labs, types[[i]]];

							If[pos=!={},
								pos = pos[[1,1]];
								outFile = GenerateBidsFileName[fol, <|parts, "type"->type, GetClassName[class, nameIn], 
									"suf"->Flatten@{datType["Suffix"], suffix[[i]]}|>];
								(*-----*)AddToLog[{"Importing:", files[[pos]]}, 4];
								info = json[[pos]];
								{data, vox} = ImportNii[ConvertExtension[files[[pos]],".nii"], NiiScaling->False];
								(*-----*)AddToLog[{"Dimensions:", Dimensions@data, "; Voxel size:", vox}, 4];
								ExportNii[data, vox, ConvertExtension[outFile, ".nii"]];
								Export[ConvertExtension[outFile, ".json"], MergeJSON[{info, infoExtra}]];
								(*-----*)AddToLog[{"Exporting to file:", outFile}, 4];
								pos
							]
						, {i, 1, Length[suffix]}];

						debugBids[pos];

						(*export used files*)
						Quiet@If[del,
							DeleteFile[ConvertExtension[files[[pos]],".nii"]];
							DeleteFile[ConvertExtension[files[[pos]],".nii.gz"]];
							DeleteFile[ConvertExtension[files[[pos]],".json"]]
						];
					];

					,
					"Dixon-S",
					(*siemens data with online recon*)

					{suffix, types} = Transpose@datType["Process", "Types"];

					Table[
						pos = GetJSONPosition[json, {{"SeriesDescription", nameIn<>"_"<>types[[i]]}}];
						If[pos=!={},
							debugBids[{"Dixon-S", nameIn<>"_"<>types[[i]], pos}];
							(*-----*)AddToLog[{"Importing ", Length[pos], "dataset with properties: ", nameIn}, 4];
							(*get the json and data*)
							info = json[[First@pos]];
							{data, vox} = ImportNii[ConvertExtension[files[[First@pos]],".nii"], NiiScaling->False];

							(*export to the correct folder*)
							outFile = GenerateBidsFileName[fol, <|parts, "type"->type, GetClassName[class, nameIn], 
								"suf"->Flatten@{datType["Suffix"], suffix[[i]]}|>];
							debugBids[{outFile, GetClassName[class, nameIn]}];
							(*-----*)AddToLog[{"Exporting to file:", outFile}, 4];
							ExportNii[data, vox, ConvertExtension[outFile, ".nii"]];
							Export[ConvertExtension[outFile, ".json"], MergeJSON[{info, infoExtra}]];

							Quiet@If[del,
								DeleteFile[ConvertExtension[files[[pos]],".nii"]];
								DeleteFile[ConvertExtension[files[[pos]],".nii.gz"]];
								DeleteFile[ConvertExtension[files[[pos]],".json"]]
							];
						]
					, {i, Length@types}];

					,
					"Dixon-B",

					(*non default with data with 4D nii, where data correction is needed*)
					pos = GetJSONPosition[json, {{"ProtocolName", nameIn}}];
					debugBids["Converting Dix data, json position: ", pos];
					(*get the json and data*)
					(*-----*)AddToLog[{"Importing ", Length[pos], "dataset with properties: ", nameIn}, 4];

					(*get the json and data*)
					info = json[[First@pos]];
					{data, vox} = ImportNii[ConvertExtension[files[[First@pos]],".nii"], NiiScaling->False];
					(*-----*)AddToLog[{"Dimensions:", Dimensions@data, "; Voxel size:", vox}, 4];

					(*assuming data has source and echos figure out the echos and slices*)
					{nSl, nEch} = Dimensions[data][[1 ;; 2]];
					nEch = (nEch - 5)/4;
					(*-----*)AddToLog[{"Slices:", nSl, "; Echos:", nEch}, 4];

					(*extract and convert the relevant data*)
					data = Partition[#, nEch] & /@ Partition[Flatten[Transpose[data], 1][[;; 4 (nSl*nEch)]], nSl nEch];
					(*mag, real, imag, phase*)
					data = {1000. data[[1]]/2047., 1000. (data[[2]] - 2047.)/2047., 1000. (data[[3]] - 2047.)/2047., Pi (data[[4]] - 2047.)/2047.};

					echo = datType["Process", "EchoTime"];
					infoExtra = Join[infoExtra, <|
						"EchoNumber" -> Range[nEch], 
						"EchoTime" -> (echo[[1]] + Range[0, nEch - 1] echo[[2]])/1000.,
						"ForthDimension"->"EchoTime",
						"DataClass"->class
					|>];

					Table[
						{i, suffix} = Switch[dixType, "Mixed", {1, ""}, "Phase", {4, "ph"}, "Real", {2, "real"}, "Imaginary", {3, "imag"}];
						(*export to the correct folder*)
						outFile = GenerateBidsFileName[fol, <|parts, "type"->type, GetClassName[class, nameIn], 
							"suf"->Flatten@{datType["Suffix"], suffix}|>];
						(*-----*)AddToLog[{"Exporting to file:", outFile}, 4];
						ExportNii[data[[i]], vox, ConvertExtension[outFile, ".nii"]];
						Export[ConvertExtension[outFile, ".json"], MergeJSON[{info, infoExtra}]];

					, {dixType, {"Mixed", "Phase", "Real", "Imaginary"}}];

					(*Delete used files*)
					Quiet@If[del,
						DeleteFile[ConvertExtension[files[[pos]],".nii"]];
						DeleteFile[ConvertExtension[files[[pos]],".nii.gz"]];
						DeleteFile[ConvertExtension[files[[pos]],".json"]]
					];
					,
					"Dixon",
					(*default script with bids standard of each echo in one file*)
					(*get the position of the files needed*)
					(*loop over dixon data types*)
					Table[
						(*get the position of the files needed*)
						pos = GetJSONPosition[json, {{"ProtocolName", nameIn}, {"ImageType", dixType}}, "EchoNumber"];

						(*-----*)AddToLog[{"Importing", Length[pos], "datasets with properties: ", {nameIn, dixType}}, 4];
						
						If[pos==={},
							(*-----*)AddToLog[{"No json files found with label ", nameIn , " and type ", dixType, " skipping conversion"}, 4],
							(*if json files found import them*)
							info = MergeJSON[json[[pos]]];
							{data, vox} = Transpose[ImportNii[#]&/@ConvertExtension[files[[pos]], ".nii"]];
							data = Transpose[data];
							vox = First@vox;
							(*-----*)AddToLog[{"Dimensions:", Dimensions@data, "; Voxel size:", vox}, 4];

							(*correct data for different types*)
							{data, suffix} = Switch[dixType,
								"Mixed", {1000.data/2047.,""},
								"Phase", {Pi (data-2047.)/2047,"ph"},
								"Real", {1000.(data-2047.)/2047.,"real"},
								"Imaginary", {1000.(data-2047.)/2047.,"imag"}
							];

							(*make the additional mandatory bids json values*)
							infoExtra = Join[infoExtra, <|
								"ForthDimension"->"EchoTime",
								"DataClass"->class
							|>];

							(*export to the correct folder*)
							outFile = GenerateBidsFileName[fol, <|parts, "type"->type, GetClassName[class, nameIn], 
								"suf"->Flatten@{datType["Suffix"], suffix}|>];
							(*-----*)AddToLog[{"Exporting to file:", outFile}, 4];
							ExportNii[data, vox, ConvertExtension[outFile, ".nii"]];
							Export[ConvertExtension[outFile, ".json"], MergeJSON[{info, infoExtra}]];

							(*Delete used files*)
							Quiet@If[del,
								DeleteFile[ConvertExtension[files[[pos]],".nii"]];
								DeleteFile[ConvertExtension[files[[pos]],".nii.gz"]];
								DeleteFile[ConvertExtension[files[[pos]],".json"]]
							];
						]
					(*Close loop over dixon data types*)
					, {dixType, {"Mixed", "Phase", "Real", "Imaginary"}}]
				],

				(*-------------------------------------------*)
				(*---------- DWI conversion script ----------*)
				(*-------------------------------------------*)
				"dwi",

				noFiles = False; 

				Switch[class,
					"Volumes",
					(*if volumes get the position of the files needed*)
					pos = GetJSONPosition[json, {{"ProtocolName", #}}] & /@ nameIn;
					debugBids["Converting DWI data ", nameIn, ", json position: ", pos];
					
					If[pos==={}, 
						noFiles = True;
						(*-----*)AddToLog[{"No json files found with label ", nameIn , " skipping conversion"}, 4],

						(*get the json and data*)
						(*-----*)AddToLog[{"Importing ", Length/@pos, "dataset with properties: ", nameIn}, 4];
						info = json[[First@First@pos]];
						dfile = ConvertExtension[files[[First@#]],".nii"]&/@pos;
						{data, vox, hdr} = ImportNii[First@dfile, NiiMethod -> "header"];

						hasb = (FileExistsQ[ConvertExtension[#,".bval"]]&&FileExistsQ[ConvertExtension[#,".bvec"]])&/@dfile;
						hasb = AllTrue[hasb, # === True &];

						If[hasb, 
							{data, grad, val, vox} = Transpose[ImportNiiDiff[#, FlipBvec->False]&/@ dfile];
							{data, grad, val, vox} = ConcatenateDiffusionData[data, grad, val, vox];
							,
							(*-----*)AddToLog[{"!!!!!!!!!!!!!!! WARNING NO BVAL OR BVEC FILE !!!!!!!!!!!!!!!!!!!"}, 4];
						]
					];

					,_ ,
					(*get the position of the files needed*)
					pos = GetJSONPosition[json, {{"ProtocolName", nameIn}}];
					debugBids["Converting DWI data ", nameIn, ", json position: ", pos];

					If[pos==={}, 
						noFiles = True;
						(*-----*)AddToLog[{"No json files found with label ", nameIn , " skipping conversion"}, 4],

						(*get the json and data*)
						(*-----*)AddToLog[{"Importing ", Length[pos], "dataset with properties: ", nameIn}, 4];
						info = json[[First@pos]];
						dfile = ConvertExtension[files[[First@pos]],".nii"];
						{data, vox, hdr} = ImportNii[dfile, NiiMethod -> "header"];
						
						hasb = FileExistsQ[ConvertExtension[dfile,".bval"]]&&FileExistsQ[ConvertExtension[dfile,".bvec"]];

						If[hasb, 
							{data, grad, val, vox} = ImportNiiDiff[dfile, FlipBvec->False],
							(*-----*)AddToLog[{"!!!!!!!!!!!!!!! WARNING NO BVAL OR BVEC FILE !!!!!!!!!!!!!!!!!!!"}, 4];
						];
						(*-----*)AddToLog[{"Dimensions:", Dimensions@data, "; Voxel size:", vox}, 4];
					]
				];

				If[!noFiles,
					(*get the offset to add to header*)
					{vz, vy, vx} = vox;
					{sz, sy, sx} = vox Dimensions@data[[All, 1]];
					{dz, dy, dx} = {"qOffsetZ", "qOffsetY", "qOffsetX"} /. hdr;
					off = -{(sz - vz)/2, (dy + sy) - vy, dx};

					(*make the additional mandatory bids json values*)
					infoExtra = Join[infoExtra, <|
						"Offset"->off,
						"ForthDimension"->"Diffusion",
						"DataClass"->class
					|>];

					If[class==="Volumes",
						files = Flatten[files];
						pos = Flatten[pos];
						nameIn = First@nameIn;
					];

					(*export to the correct folder*)
					debugBids[{parts, type, GetClassName[class, nameIn], datType["Suffix"]}];
					outFile = GenerateBidsFileName[fol, <|parts, "type"->type, GetClassName[class, nameIn], 
						"suf"->{datType["Suffix"]}|>];
					(*-----*)AddToLog[{"Exporting to file:", outFile}, 5];
					If[hasb,
						ExportBval[val, ConvertExtension[outFile, ".bval"]];
						ExportBvec[grad, ConvertExtension[outFile, ".bvec"]];
					];
					ExportNii[data, vox, ConvertExtension[outFile, ".nii"]];
					Export[ConvertExtension[outFile, ".json"], MergeJSON[{info, infoExtra}]];

					Quiet@If[del,
						(*-----*)AddToLog[{"Deleting", Length[pos], type, "dataset with properties: ", nameIn}, 4];
						DeleteFile[ConvertExtension[files[[pos]],".nii"]];
						DeleteFile[ConvertExtension[files[[pos]],".nii.gz"]];
						DeleteFile[ConvertExtension[files[[pos]],".json"]];
						If[hasb,
							DeleteFile[ConvertExtension[files[[pos]],".bval"]];
							DeleteFile[ConvertExtension[files[[pos]],".bvec"]];
						];
					]
				],

				(*-------------------------------------------*)
				(*----------- T2 conversion script ----------*)
				(*-------------------------------------------*)
				"mese",

				
				Which[
					(*if echo time exists assume 4D nii without correct echo times*)
					KeyExistsQ[Lookup[datType, "Process", <||>], "EchoTime"],

					pos = posIn = GetJSONPosition[json, {{"ProtocolName", nameIn}}];

					(*get the json and data*)
					If[Length[pos] > 1,
						pos = pos[[{-1}]];
						AddToLog[{"!!!!!Multiple files found, taking last file"}, 4];
						debugBids["!!!!!Multiple files found, taking last file: "];
					];

					debugBids["Converting MESE data, json position: ", pos];
					(*get the json and data*)
					(*-----*)AddToLog[{"Importing ", Length[pos], "dataset with properties: ", nameIn}, 4];

					(*echo times - get the echo time from the data json if present*)
					info = json[[First@pos]];

					If[KeyExistsQ[info, "EchoTime"] && KeyExistsQ[info, "EchoTrainLength"] || info["Manufacturer"]==="Siemens",
						{data, vox} = ImportNii[ConvertExtension[files[[First@pos]],".nii"]],
						{data, fit, vox} = ImportNiiT2[ConvertExtension[files[[First@pos]],".nii"]]
					];
					(*-----*)AddToLog[{"Dimensions:", Dimensions@data, "; Voxel size:", vox}, 4];
					echo = Lookup[info, "EchoTime", datType["Process", "EchoTime"]/1000.];
					nEch = Lookup[info, "EchoTrainLength", Length[data[[1]]]];
					info = KeyDrop[info, "EchoTime"];
					echo = <|
						"EchoNumber" -> Range[nEch], 
						"EchoTime" -> (echo + Range[0, nEch - 1] echo)
					|>;
					debugBids[echo];

					,
					(*Else its a list of single echo nii files*)
					True,

					(*get the position of the files needed*)
					pos = posIn = GetJSONPosition[json, {{"ProtocolName", nameIn}}, "EchoTime"];
					debugBids["Converting MESE data ", nameIn, ", json position: ", pos];
					info = MergeJSON[json[[pos]]];

					(*select only echos*)
					len = info["AcquisitionNumber"];
					len = If[ListQ[len], Max[len], Lookup[info, "EchoTrainLength", Length[pos]]];
					pos = pos[[;; len]];
					info = MergeJSON[json[[pos]]];

					(*-----*)AddToLog[{"Importing ", Length[pos], "dataset with properties: ", nameIn}, 4];

					(*get the json and data*)
					AssociateTo[info, "EchoNumber" -> Range@len];
					{data, vox} = Transpose[ImportNii /@ ConvertExtension[files[[pos]],".nii"]];
					data = Transpose[data];
					vox = First@vox;
					(*-----*)AddToLog[{"Dimensions:", Dimensions@data, "; Voxel size:", vox}, 4];

					echo = <||>;
				];

				(*make the additional mandatory bids json values*)
				infoExtra = Join[infoExtra, echo, <|
					"ForthDimension"->"EchoTime",
					"DataClass"->class
				|>];

				(*export to the correct folder*)
				outFile = GenerateBidsFileName[fol, <|parts, "type"->type, GetClassName[class, nameIn], 
					"suf"->{datType["Suffix"]}|>];
				(*-----*)AddToLog[{"Exporting to file:", outFile}, 5];
				ExportNii[data, vox, ConvertExtension[outFile, ".nii"]];
				Export[ConvertExtension[outFile, ".json"], MergeJSON[{info, infoExtra}]];

				(*Delete used files*)
				Quiet@If[del,
					(*-----*)AddToLog[{"Deleting", Length[posIn], type, "datasets with properties: ", nameIn},4];
					DeleteFile[ConvertExtension[files[[posIn]],".nii"]];
					DeleteFile[ConvertExtension[files[[posIn]],".nii.gz"]];
					DeleteFile[ConvertExtension[files[[posIn]],".json"]]
				]

				,

				(*-------------------------------------------*)
				(*-------- Other processing script ----------*)
				(*-------------------------------------------*)
				_,
				(*-----*)AddToLog["Unknown datatype for conversion", 4];

			(*Close Type switch*)
			];
		(*close file check*)	
		];
	(*close loop over stac names*)
	,{nameIn, labels}];
] 


(* ::Subsection:: *)
(*3. MuscleBidsProcess*)


(* ::Subsubsection::Closed:: *)
(*MuscleBidsProcess*)


Options[MuscleBidsProcess] = {ProcessSubjects->All, VersionCheck->False};

SyntaxInformation[MuscleBidsProcess] = {"ArgumentsPattern" -> {_, _., _., OptionsPattern[]}};

MuscleBidsProcess[folder_?StringQ, opts:OptionsPattern[]] := MuscleBidsProcess[folder, GetConfig[folder], opts];


MuscleBidsProcess[folder_?StringQ, config_?AssociationQ, opts:OptionsPattern[]]:=Block[{dir},
	debugBids["starting MuscleBidsProcess"];
	dir = Directory[]; SetDirectory[folder];
	MuscleBidsProcess[
		ConfigLookup[config, "folders", "rawData"],(*the input folder for the data*)
		ConfigLookup[config, "folders", "derivedData"],(*the output folder for processing*)
		config["datasets"],(*what data for processing*)
		opts];
	SetDirectory[dir];	
]


MuscleBidsProcess[niiFol_?StringQ, outFol_?StringQ, datDis_?AssociationQ, opts:OptionsPattern[]]:= BidsFolderLoop[niiFol, outFol, datDis, Method->"MuscleBidsProcess", opts]


(* ::Subsubsection::Closed:: *)
(*MuscleBidsProcessI*)


MuscleBidsProcessI[foli_, folo_, datType_, verCheck_]:=Block[{
		con, fol, parts, type, files, sets, diffFile, nfile, keys, dixFiles, jfile, nFiles, phbpt, dbond,
		outfile, json, echos, mag, ph, real, imag, dvox, magM, B0mask, ph0i, pos, e1, e2, hz, b0i,
		t2stari, watfr, fatfr, wat, fat , inph, outph, b0, t2star, r2star, phi, itt, res, outTypes, preProc, 
		nfilep, jfilep, resi, data, grad, val, diffvox, mask, den, sig, snr, snr0, reg, valU, mean, fiti, s0i, fri, 
		adci, pD, tens, s0, out, l1, l2, l3, md, fa, rd, t2vox, t2w, t2f, b1, n, angle, ex, ref, thk, 
		phii, phbpi, phbp, ta, filt, field, settingPre, settingPro, regF, coil, off, ivimpar, int, dint, suffix, types,
		flip, per, bmat, magph, split, ivim, shift, t2
	},

	debugBids["Starting MuscleBidsProcessI"];
	debugBids[{foli, folo}];

	(*get the context for exporting*)
	con = Context[con];

	(*get the information needed for processing, e.g. session|repetition*)
	{fol, parts} = PartitionBidsFolderName[foli];
	type = datType["Type"];
	keys = {"EchoTime", "ForthDimension", "DataClass", "Stack", 
		"OverLap", "SliceThickness", "SpacingBetweenSlices"};

	(*see what needs to be processed*)
	files = Flatten[FileNames["*"<>StringStrip[#]<>"*.json", foli]& /@ Flatten[{datType["Label"]}]];
	sets = If[type==="megre"||type==="tse",
		DeleteDuplicates[(ta = #;AssociateTo[ta, "suf"->{First[ta["suf"]]}])&/@PartitionBidsName[FileBaseName/@files]],
		DeleteDuplicates[PartitionBidsName[FileBaseName/@files]]];
	(*-----*)AddToLog[{"Found", ToString[Length[sets]], datType["Class"], "that will be processed:"}, 2];

	debugBids[Column@files];
	debugBids[Column@sets];

	(*loop over sets*)
	Table[
		(*-----*)AddToLog[dataToLog@set, 2];
		debugBids[{set, type, datType["Process", "Method"]}];
		(*see which data type is expected*)
		Switch[type,

			"megre" | "tse",
			(*-------------------------------------------*)
			(*-------- megre processing scripts ---------*)
			(*-------------------------------------------*)

			Switch[datType["Process", "Method"],

				(*-------------------------------------------*)
				(*-------- Dixon processing scripts ---------*)
				(*-------------------------------------------*)

				"Dixon-S" | "Dixon-P",
				(*siemens data with online reconstruction*)
				suffix = datType["Process", "Types"];
				If[MatrixQ[suffix], {suffix, types} = Transpose@suffix];

				dixFiles = GenerateBidsFileName[fol, <|set, "suf"->{datType["Suffix"], #}|>]&/@suffix;
				jfile = ConvertExtension[First@dixFiles, ".json"];
				nFiles = ConvertExtension[dixFiles, ".nii"];

				(*ouput file names*)
				outfile = GenerateBidsFileName[folo, set];
				debugBids[outfile];

				(*check if files are already done*)
				If[CheckFile[outfile, "done", verCheck],
					(*if check file has label done and version is recent skip*)
					(*----*)AddToLog["Processing already done for: ", True, 3];
					(*----*)AddToLog[outfile, 4],
					(*----*)AddToLog["Starting processing for data:", 3, True];
					(*----*)AddToLog[First@dixFiles, 4];

					If[!AllTrue[nFiles, NiiFileExistQ],
						(*----*)AddToLog[{"Could not find all the ", First@dixFiles}, 4],
						(*----*)AddToLog["Importing the data", 4];
						{data, dvox} = Transpose[ImportNii/@nFiles];
						json = ImportJSON[ConvertExtension[First[nFiles], ".json"]];

						pos = Flatten[Position[suffix, #] & /@ {"inph", "outph", "fat", "wat"}];
						debugBids[pos];
						mask = If[pos==={}, 1, 
							Mask[NormalizeMeanData[Transpose[NormalizeData /@ data[[pos]]]], 15,
								MaskSmoothing -> True, MaskComponents -> 2, MaskClosing -> 2, MaskDilation -> 1]
						];
						debugBids[{Dimensions@mask, Dimensions@data}];
						
						If[MemberQ[suffix, "wat"], wat = mask data[[Position[suffix,"wat"][[1,1]]]]];
						If[MemberQ[suffix, "fat"], fat = mask data[[Position[suffix,"fat"][[1,1]]]]];
						If[MemberQ[suffix, "inph"], inph = mask data[[Position[suffix,"inph"][[1,1]]]]];
						If[MemberQ[suffix, "outph"], outph = mask data[[Position[suffix,"outph"][[1,1]]]]];
						
						If[MemberQ[suffix, "t2star"],
							t2star = mask data[[Position[suffix,"t2star"][[1,1]]]] / 10000.;
							r2star = DivideNoZero[1, t2star];
							AppendTo[suffix, "r2star"]];
						If[MemberQ[suffix, "fatfr"],
							fatfr = mask data[[Position[suffix, "fatfr"][[1,1]]]] / 100.;
							If[!MemberQ[suffix, "watfr"], watfr = mask - fatfr; AppendTo[suffix, "watfr"]];
						];

						If[!MemberQ[suffix, "fatfr"] && MemberQ[suffix, "wat"] && MemberQ[suffix, "fat"],
							{watfr, fatfr} = MaskData[DixonToPercent[wat, fat], mask];
							AppendTo[suffix, "fatfr"];
							If[!MemberQ[suffix, "watfr"], AppendTo[suffix, "watfr"]];
						]
					];

					(*export all the calculated data*)
					(*----*)AddToLog["Exporting the calculated data to:", 4];
					(*----*)AddToLog[outfile,5];
					outTypes = suffix;
					(
						ExportNii[ToExpression[con<>#], First@dvox, outfile<>"_"<>#<>".nii"];
						Export[ConvertExtension[outfile <> "_"<>#, ".json"], json]
					)&/@ outTypes;
					

					(*export the check file*)
					MakeCheckFile[outfile, Sort@Join[
						{"Check"->"done", "Outputs" -> outTypes, "SetProperties"->set}
					]];
				];
				(*----*)AddToLog["Finished processing", 3, True];

				,
				"Dixon" | "Dixon-B",
				(*philips data with offline reconstruction*)

				(*ouput file names*)
				outfile = GenerateBidsFileName[folo, set];
				debugBids[outfile];

				(*check if files are already done*)
				If[CheckFile[outfile, "done", verCheck],
					(*if check file has label done and version is recent skip*)
					(*----*)AddToLog["Processing already done for: ", True, 3];
					(*----*)AddToLog[outfile, 4],

					(*input file names*)
					dixFiles = GenerateBidsFileName[fol, <|set, "suf"->{datType["Suffix"], #}|>]&/@{"real", "imag"};
					jfile = ConvertExtension[First@dixFiles, ".json"];
					nFiles = ConvertExtension[dixFiles, ".nii"];
					magph = False;
					
					(*if not real imag check for mag phase*)
					If[!FileExistsQ[jfile],
						dixFiles = GenerateBidsFileName[fol, <|set, "suf"->{datType["Suffix"], #}|>]&/@{"", "ph"};
						jfile = ConvertExtension[First@dixFiles, ".json"];
						nFiles = ConvertExtension[dixFiles, ".nii"];
						magph = True;
					];

					(*----*)AddToLog["Starting processing for data:", 3, True];
					(*----*)AddToLog[First@dixFiles, 4];

					(*Check if needed json Exist*)
					If[!FileExistsQ[jfile],
						(*----*)AddToLog["Could not find the needed JSON file", 4];,
						(*Check if needed nii Exist*)
						If[!AllTrue[nFiles, NiiFileExistQ],
							(*----*)AddToLog[{"Could not find all the ", First@dixFiles}, 4],
							(*----*)AddToLog["Importing the data", 4];

							(*import the data*)
							json = ImportJSON[jfile];
							{echos, field} = json /@ {"EchoTime", "MagneticFieldStrength"};

							If[magph,
								{{mag, ph}, dvox} = Transpose[ImportNii/@nFiles];
								real = mag Cos[ph];
								imag = mag Sin[ph];
								,
								{{real, imag}, dvox} = Transpose[ImportNii/@nFiles];
								{mag, ph} = Through[{Abs, Arg}[real + I imag]];
							];
							dvox = First@dvox;

							(*Apply background mask*)
							magM = NormalizeMeanData@mag;
							B0mask = Mask[magM, 15, MaskSmoothing->True, MaskComponents->2, MaskClosing->2, MaskDilation->1];
							{real, imag} = MaskData[#, B0mask] &/@ {real, imag};

							(*----*)AddToLog["Starting denoising and SNR calculation", 4];
							{{real, imag}, sig} = PCADeNoise[{real, imag}, PCAKernel -> 5, Method -> "Patch", PCAComplex -> True];
							{mag, ph} = Through[{Abs, Arg}[real + I imag]];
							snr = SNRCalc[Mean@Transpose@mag, sig];

							Switch[datType["Process", "Method"],
								(*Dixon processing scrip for multi echo gradient echo complex data as used in motion study*)
								"Dixon",

								(*see if there are dixon flips*)
								(*{{mag, ph, real, imag}, pos} = FixDixonFlips[{mag, ph, real, imag}];
								(*-----*)If[pos=!={}, AddToLog[{"Found complex flips in volumes: ", pos}, 4]];*)
								pos={};

								(*calculated field maps*)
								(*-----*)AddToLog[{"Starting field map calculation"}, 4];
								{{b0i, t2stari, phii, phbpi}, {e1, e2, n}} = DixonPhase[{real, imag}, echos];
								(*-----*)AddToLog[{"used echo ", ToString[e1], "(", 1000 echos[[e1]],"ms ) and", ToString[e2], "(", 1000 echos[[e2]], "ms )"}, 5];

								(*perform the IDEAL dixon fit*)
								(*-----*)AddToLog["Starting Dixon reconstruction", 4];

								(*fit with DB fat model*)
								{{watfr, fatfr}, {wat, fat, dbond}, {inph, outph}, {{b0, phbp, phi, phbpt}, {t2star, r2star}}, itt, res} = DixonReconstruct[
									{real, imag}, echos, {b0i, t2stari, phii, phbpi}, 
									DixonPhases -> {True, True, True, True, True}, 
									DixonFixT2 -> False, DixonFieldStrength -> field, 
									DixonAmplitudes -> "CallDB", DixonTolerance->1];

								pos = {"DixonFlips" -> pos, "DixonBipolar" -> True};
								outTypes = {"dbond", "phbp", "phi", "phbpt", "phii", "phbpi"};

								,
								(*Dixon processing scrip for multi echo gradient echo complex data as used in Bochum cohort*)
								"Dixon-B"
								,

								(*uwrap and convert B0 to hz*)
								(*-----*)AddToLog[{"Starting field map calcualtion"}, 4];
								b0i = UnwrapSplit[ph[[All, -1]] - ph[[All, 1]], mag, UnwrapDimension -> "3D", MonitorUnwrap -> False];
								b0i = b0i/(2 Pi Length[echos]  (echos[[2]] - echos[[1]]));
								(*calculate the t2 star from the two in phase images*)
								t2stari = T2Fit[mag, echos][[2]];

								debugBids[Dimensions/@{real,imag, b0i, t2stari}];
								debugBids[echos];

								(*perform the IDEAL dixon fit*)
								(*-----*)AddToLog["Starting Dixon reconstruction", 4];
								{{watfr, fatfr}, {wat, fat}, {inph, outph}, {{b0}, {t2star, r2star}}, itt, res} = DixonReconstruct[{real, imag}, echos, {b0i, t2stari}, DixonClipFraction -> True];

								outTypes = {};
							];

							{wat, fat} = Abs[{wat, fat}];

							(*export all the calculated data*)
							(*----*)AddToLog["Exporting the calculated data to:", 4];
							(*----*)AddToLog[outfile,5];
							outTypes = Join[{"real", "imag", "mag", "ph", "b0i", "t2stari", "b0", "t2star", "r2star", 
								"inph", "outph", "wat", "fat", "watfr", "fatfr", "itt", "res", "snr", "sig"}, outTypes];
							ExportNii[ToExpression[con<>#], dvox, outfile<>"_"<>#<>".nii"] &/@ outTypes;
							Export[ConvertExtension[outfile <> "_"<>#, ".json"], json]&/@ outTypes;

							(*export the checkfile*)
							MakeCheckFile[outfile, Sort@Join[
								{"Check"->"done", "EchoTimes"->echos, "Outputs" -> outTypes, "SetProperties"->set}, 
								pos, Normal@KeyTake[json, keys]
							]];
							(*----*)AddToLog["Finished processing", 3, True];
						]
					]
				(*close dixon processing*)
				],

				_,
				(*-------------------------------------------*)
				(*-------------- Unknown megre --------------*)
				(*-------------------------------------------*)
				(*----*)AddToLog[{"Unknown processing ", datType["Process"], "for datatype", type}, True, 3];

			(*close megre processing*)
			],

			"dwi",
			(*-------------------------------------------*)
			(*--------- dwi processing script -----------*)
			(*-------------------------------------------*)

			(*input file names*)
			diffFile = GenerateBidsFileName[fol, set];
			jfile = ConvertExtension[diffFile,".json"];
			nfile = ConvertExtension[diffFile,".nii"];

			(*ouput file names*)
			outfile = GenerateBidsFileName[folo, set];
			debugBids[outfile];

			(*default settings*)
			settingPre = settingPro =  <||>;

			(*-------------------------------------------*)
			(*------- dwi pre -processing script --------*)
			(*-------------------------------------------*)

			(*check if pre-processin is already done*)
			preProc = False;
			If[CheckFile[outfile<>"_prep", "done", verCheck],
				(*if checkfile has label done and version is recent skip*)
				(*----*)AddToLog["Pre-processing already done for: ", True, 3];
				(*----*)AddToLog[outfile, 4],
				(*----*)AddToLog["Starting pre-processing for data:", 3, True];
				(*----*)AddToLog[diffFile, 4];

				If[!FileExistsQ[jfile],
					(*----*)AddToLog["Could not find the needed JSON file",4],
					(*Check if needed nii Exist*)
					If[!(NiiFileExistQ[nfile]&&FileExistsQ[ConvertExtension[nfile,".bval"]]&&FileExistsQ[ConvertExtension[nfile,".bvec"]]),
						(*----*)AddToLog[{"Skipping, could not find .nii, .bval and .bvec"}, 4],
						(*----*)AddToLog["Importing the data", 4];

						(*import the data*)
						json = ImportJSON[jfile];
						{data, grad, val, diffvox} = ImportNiiDiff[nfile, FlipBvec->False];
						{data, grad, val} = SortDiffusionData[NormalizeData[data], grad, val];
						debugBids[{"Raw data dimensions", Dimensions[data]}];

						(*gradient flip correction*)
						{flip, per} = ConfigLookup[datType, "Process", "FlipPermute"];
						(*----*)AddToLog[{"Gradient flips used: ", flip, per}, 4];
						grad = FlipGradientOrientation[grad, flip, per];
						settingPre = MergeConfig[settingPre, <|"FlipPermute"->{flip, per}|>];

						(*Denoise and SNR*)
						(*-----*)AddToLog["Starting dwi denoising", 4];
						mask = Mask[NormalizeMeanData[data],  ConfigLookup[datType, "Process", "Masking"], 
							MaskSmoothing->True, MaskComponents->2, MaskDilation->1];
						{den, sig} = PCADeNoise[data, mask, PCAOutput->False, PCATolerance->0, PCAKernel->5];
						snr = SNRCalc[den, sig];
						snr0 = Mean@Transpose@First@SelectBvalueData[{snr, val}, {0, Max[{2, Min[val]}]}];
						debugBids[{"denoised data dimensions", Dimensions[den]}];

						(*register data - each leg seperate*)
						(*-----*)AddToLog["Starting dwi motion and eddy correction", 4];
						split = ConfigLookup[datType, "Process", "SplitRegistration"];
						regF = If[split, RegisterDiffusionDataSplit, RegisterDiffusionData];
						settingPre = MergeConfig[settingPre, <|"SplitRegistration"->split|>];
						debugBids[{"Registration function", regF}];
						reg = regF[{den, mask, diffvox}, Iterations->300, NumberSamples->5000, 
							PrintTempDirectory->False];

						(*anisotropic filtering*)
						(*-----*)AddToLog["Starting anisotropic data smoothing", 4];
						filt = AnisoFilterData[reg, diffvox];

						(*export all the calculated data*)
						(*----*)AddToLog["Exporting the calculated data to:", 4];
						(*----*)AddToLog[outfile, 5];
						outTypes = {"den", "reg", "sig", "snr0", "snr", "filt"};
						(
							ExportNii[ToExpression[con<>#], diffvox, outfile<>"_"<>#<>".nii"];
							Export[ConvertExtension[outfile <> "_"<>#, ".json"], MergeJSON[{json, settingPre}]];
						) &/@ outTypes;
						(
							ExportBval[val, ConvertExtension[outfile <> "_"<>#, ".bval"]];
							ExportBvec[grad, ConvertExtension[outfile <> "_"<>#, ".bvec"]];
						)&/@{"reg", "filt"};

						(*export the checkfile*)
						MakeCheckFile[outfile<>"_prep", Sort@Join[
							{"Check"->"done", "Bvalue" -> val, "Gradient" -> grad, "Outputs" -> outTypes, "SetProperties"->set},
							Normal@KeyTake[json, keys]
						]];
						(*----*)AddToLog["Finished pre-processing", 3, True];

						(*Set preproc true, overrules checkfile for processing*)
						preProc = True;
					]
				]
			(*close preprocessing*)
			];

			Switch[datType["Process", "Method"],

				"DTI",
				(*-------------------------------------------*)
				(*---------- dwi processing script ----------*)
				(*-------------------------------------------*)

				(*input file for processing*)
				nfilep = ConvertExtension[GenerateBidsFileName[folo, <|set, "suf"->{datType["Suffix"], "filt"}|>],".nii"];
				jfilep = ConvertExtension[nfilep, ".json"];

				(*check if processin is already done, redo is prep is done*)					
				If[If[!preProc, CheckFile[outfile, "done", verCheck], False],
					(*if checkfile has label done and version is recent skip*)
					(*----*)AddToLog["Processing already done for: ", True, 3];
					(*----*)AddToLog[outfile, 4],
					(*----*)AddToLog["Starting processing for data:", 3, True];
					(*----*)AddToLog[nfilep, 4];				

					If[!FileExistsQ[jfilep],
						(*----*)AddToLog["Could not find the needed JSON file", 4];,

						(*Check if needed nii Exist*)
						If[!(NiiFileExistQ[nfilep]&&FileExistsQ[ConvertExtension[nfilep,".bval"]]&&FileExistsQ[ConvertExtension[nfilep,".bvec"]]),
							(*----*)AddToLog[{"Skipping, could not find .nii, .bval and .bvec"}, 4],
							(*----*)AddToLog["Importing the data", 4];

							(*import the data*)
							json = ImportJSON[jfilep];
							{data, grad, val, diffvox} = ImportNiiDiff[nfilep, FlipBvec->False];
							mask = Mask[NormalizeMeanData[data], ConfigLookup[datType, "Process", "Masking"], MaskSmoothing->True, 
								MaskComponents->2, MaskClosing->2];
							data = MaskData[data, mask];
							(*get bvalues and mean data*)
							{mean, valU} = MeanBvalueSignal[data, val];
							
							(*initialize IVIM fit*)
							ivim = ConfigLookup[datType, "Process", "IVIMCorrection"];
							settingPro = Join[settingPro, <|"IVIMCorrection"->ivim|>];

							If[ivim,
								(*-----*)AddToLog["Starting ivim calculation", 4];
								(*estimatie inti values*)
								fiti = IVIMCalc[MeanSignal[mean], valU, {1, .05, .003, .015}, IVIMFixed->True];
								(*perform IVIM correction*)
								{s0i, fri, adci, pD} = Quiet@IVIMCalc[mean, valU, fiti, IVIMConstrained->False, Parallelize->True, 
									MonitorIVIMCalc->False, IVIMFixed->True];
								fri = Clip[fri, {0,1}, {0,1}];
								adci = 1000 adci;
								resi = Quiet@IVIMResiduals[mean, valU, {s0i, fri, adci, pD}];
								data = First@IVIMCorrectData[data, {s0i, fri, pD}, val, FilterMaps->False];
								ivimpar = {"adci", "fri", "s0i"}
								,
								(*-----*)AddToLog["Skipping IVIM correction", 4];
								ivimpar = {}; 
							];

							(*calculate tensor from corrected data*)
							(*-----*)AddToLog["Starting tensor calculation", 4];
							coil = ConfigLookup[datType, "Process", "GradientCorrection"];
							settingPro = Join[settingPro, <|"GradientCorrection"->coil|>];
							off = Lookup[json, "Offset", False];

							coil = If[!StringQ[coil], 
								False,
								(*-----*)AddToLog[{"Using Gradient correction: ", coil}, 4];
								If[!VectorQ[off], 
									(*-----*)AddToLog["No offset defined in json, skipping grad correction" , 5];
									False,
									{int, dint} = MakeGradientDerivatives[diffvox, coil];
									{diffvox, off, dint}
								]
							];

							(*check if field map is needed in output*)
							{tens, s0, out} = Quiet@TensorCalc[data, grad, val, coil, FullOutput->True, 
								Method->"iWLLS", RobustFit->True, Parallelize->True, MonitorCalc->False];
							coil = If[coil===False, 
								{out, res} = out; {},
								{out, res, field} = out; {"field"}
							];
							out = Total@Transpose@out;

							(*calculate tensor parameters*)
							{l1, l2, l3, md, fa} = ParameterCalc[tens];
							rd = Mean[{l2, l3}];
							tens = Transpose[tens];

							(*export all the calculated data*)
							(*----*)AddToLog["Exporting the calculated data to:", 4];
							(*----*)AddToLog[outfile, 5];
							debugBids[Column[{json, settingPro}]];

							outTypes = Join[{"data", "mean", "tens", "res", "out", "s0", 
								"l1", "l2", "l3", "md",	"fa", "rd"}, coil, ivimpar];
							(
								ExportNii[ToExpression[con<>#], diffvox, outfile<>"_"<>#<>".nii"];
								Export[ConvertExtension[outfile <> "_"<>#, ".json"], MergeJSON[{json, settingPro}]];
							) &/@ outTypes;

							(*export the checkfile*)
							MakeCheckFile[outfile, Sort@Join[
								{"Check"->"done", "Bvalue" -> val, "Gradient" -> grad, "Outputs" -> outTypes, "SetProperties"->set},
								Normal@KeyTake[json,keys]
							]];
							(*----*)AddToLog["Finished processing", 3, True];				
						]
					]
				(*close dti processing*)
				],

				_,
				(*-------------------------------------------*)
				(*--------------- Unknown dti ---------------*)
				(*-------------------------------------------*)
				(*----*)AddToLog[{"Unkonwn processing ", datType["Process"], "for datatype", type}, True, 3];
			],

			"mese",
			(*-------------------------------------------*)
			(*-------- mese processing scripts ----------*)
			(*-------------------------------------------*)

			Switch[datType["Process", "Method"],				

				"EPGT2"|"Exp",
				(*-------------------------------------------*)
				(*---------- EPG processing script ----------*)
				(*-------------------------------------------*)

				(*input file names*)
				diffFile = GenerateBidsFileName[fol, set];
				jfile = ConvertExtension[diffFile,".json"];
				nfile = ConvertExtension[diffFile,".nii"];

				(*ouput file names*)
				outfile = GenerateBidsFileName[folo, set];

				(*check if files are already done*)
				If[CheckFile[outfile, "done", verCheck],
					(*if checkfile has label done and version is recent skip*)
					(*----*)AddToLog["Processing already done for: ", True, 3];
					(*----*)AddToLog[outfile, 4],
					(*----*)AddToLog["Starting processing for data:", 3, True];
					(*----*)AddToLog[diffFile, 4];

					(*Check if needed json Exist*)
					If[!FileExistsQ[jfile],
						(*----*)AddToLog[{"Could not find the needed JSON file of", jfile}, 4];,
						(*Check if needed nii Exist*)
						If[!NiiFileExistQ[nfile],
							(*----*)AddToLog[{"Could not find the data of", diffFile}, 4],
							(*----*)AddToLog["Importing the data", 4];

							(*import the data*)
							json = ImportJSON[jfile];
							echos = json["EchoTime"];
							debugBids["importing: ", nfile];
							{data, t2vox} = ImportNii[nfile];

							(*mask the background*)		
							mask = Mask[NormalizeMeanData[data], ConfigLookup[datType, "Process",  "Masking"], MaskSmoothing -> True, MaskComponents -> 2, MaskClosing -> 2];
							data = NormalizeData@MaskData[data, mask];

							Switch[datType["Process", "Method"],

								"EPGT2",

								(*determine the pulse profiles*)
								(*-----*)AddToLog["Calculating the slice profiles", 4];	
								{ex, ref} = ConfigLookup[datType, "Process", "Settings"];
								debugBids[{ex, ref, echos}];
								(*check if the profiles are given as numbers or as files*)
								angle = If[NumberQ[ex] && NumberQ[ref],
									shift = 0.;
									{ex, ref},
									thk = json["SliceThickness"];
									angle = GetPulseProfile[ex, ref, SliceRange -> 3 thk, SliceRangeSamples -> 6 thk][[1;;2]];
									shift = ConfigLookup[datType, "Process", "Shift"];
									shift = If[shift=!=True, 0.,
										shift = (1/ref[[3, 1]] - 1/ex[[3, 1]]) (3(*filed times ppm*) 3.4);
										(*-----*)AddToLog[{"Shifting fat profile with: ", shift}, 4];
										Round[shift/((3 thk/2)/(6 thk))]
									];
									angle
								];

								debugBids[Dimensions/@{data, t2vox}];

								(*caculate the water t2 map*)
								(*-----*)AddToLog["Starting EPG T2 calculation", 4];
								{{t2w, t2f, b1}, {wat, fat, fatfr}, res} = EPGT2Fit[data, 1000 echos, angle, 
									MonitorCalc -> False, DictT2IncludeWater -> True, 
									EPGFitFat -> False, EPGCalibrate -> True, EPGFatShift -> shift,
									DictT2fValue -> 150, DictT2fRange -> {150, 250, 5}, 
									DictB1Range -> {0.5, 1.4, 0.02}, DictT2Range -> {15, 45, 0.2}];

								outTypes = {"data", "t2w", "t2f", "b1", "wat", "fat", "fatfr", "res"};

								,
								"Exp",
								(*-----*)AddToLog["Starting exponential T2 fitting", 4];
								{s0, t2} = T2Fit[data, 1000 echos];

								outTypes = {"data", "t2", "s0"};
							];

							(*export all the calculated data*)
							(*----*)AddToLog["Exporting the calculated data to:", 4];
							(*----*)AddToLog[outfile, 5];		

							ExportNii[ToExpression[con<>#], t2vox, outfile<>"_"<>#<>".nii"] &/@ outTypes;
							Export[ConvertExtension[outfile <> "_"<>#, ".json"], json]&/@ outTypes;
													
							(*export the checkfile*)
							MakeCheckFile[outfile, Sort@Join[
								{"Check"->"done", "EchoTimes" -> echos, "Outputs" -> outTypes, "SetProperties"->set},
								Normal@KeyTake[json, keys]
							]];
							(*----*)AddToLog["Finished processing", 3, True];
						]
					]
				(*close t2 processing*)
				],

				_,
				(*-------------------------------------------*)
				(*--------------- Unknown mese ---------------*)
				(*-------------------------------------------*)
				(*----*)AddToLog[{"Unkonwn processing ", datType["Process"], "for datatype", type}, True, 3];
			],
			(*-------------------------------------------*)
			(*------------------ Other ------------------*)
			(*-------------------------------------------*)
			_,
			(*-----*)AddToLog["Unknown datatype for processing", 4];

		(*Close Type switch*)
		];

	(*close loop over sets*)
	, {set, sets}]
]


(* ::Subsection:: *)
(*4. MuscleBidsMerge*)


(* ::Subsubsection::Closed:: *)
(*MuscleBidsMerge*)


Options[MuscleBidsMerge] = {ProcessSubjects->All, VersionCheck->False};

SyntaxInformation[MuscleBidsMerge] = {"ArgumentsPattern" -> {_, _., _., OptionsPattern[]}};

MuscleBidsMerge[folder_?StringQ, opts:OptionsPattern[]] := MuscleBidsMerge[folder, GetConfig[folder], opts];


MuscleBidsMerge[folder_?StringQ, config_?AssociationQ, opts:OptionsPattern[]]:=Block[{dir}, 
	debugBids["starting MuscleBidsMerge"];
	dir = Directory[]; SetDirectory[folder];
	MuscleBidsMerge[
		ConfigLookup[config, "folders", "derivedData"],(*the input folder for the data*)
		ConfigLookup[config, "folders", "mergeData"],(*the output folder for merging*)
		config["datasets"],(*what data merging*)
		opts];
	SetDirectory[dir];	
]


MuscleBidsMerge[datFol_?StringQ, merFol_?StringQ, datDis_?AssociationQ, opts:OptionsPattern[]]:= BidsFolderLoop[datFol, merFol, datDis, Method->"MuscleBidsMerge", opts]


(* ::Subsubsection::Closed:: *)
(*MuscleBidsMergeI*)


MuscleBidsMergeI[foli_, folo_, datType_, allType_, verCheck_]:=Block[{
		nonQuant, motion, reverse, fol, parts, merge, outfile, tarType, tarSuf, tarCon, tarFile, n,
		movs, movStacs, tarStacs, overT, overM, targets, movings, mov, nStac, nCheck, nSet, target, voxt, moving, 
		voxm, files, im, func, reg, mskm, mskt, vox, sameType, metReg, pad, movp, duplicate, tarDat,
		multDim, movsAll, movsMD, movingsAll, movingsMD, movingA, movingMD, leng, lengMD, movpS, movpN,
		jsonAll, native, movsName, posAll, posNat, posScale, voxtR, voxF, targetR, msktR, split,
		tarMer, dupKey, settings
	},

	(*get the input settings*)
	debugBids["Starting MuscleBidsMergeI"];
	debugBids[foli, folo];
	debugBids[datType];

	(*muscle bids that are non quantitative of multi dimensional and or have to stay native*)
	nonQuant = {"inph", "outph", "wat", "fat", "s0"};
	multDim = {"tens"};
	native = {"tens"};

	(*figure out if duplicate handeling is needed.*)
	duplicate = KeyExistsQ[datType, "Key"];

	(*get the outfile names*)
	{fol, parts} = PartitionBidsFolderName[foli];
	merge = datType["Merging"];
	tarMer = merge["Target"];

	dupKey = If[datType["Class"] === "Stacks", "stk", "chunk"];

	outfile = GenerateBidsFileName[folo, <|parts, If[duplicate, dupKey->StringStrip@datType["Key"], Nothing], 
		"type"->datType["Type"], "suf"->datType["Suffix"]|>];

	debugBids[{parts, outfile}];
	debugBids["duplicates: ", {duplicate, Length[tarMer], duplicate && Length[tarMer] ===3}];

	(*------------------ perform all check and figure out settings ------------------*)

	(*get the settings for the target data if there are duplicates the target needs to be 4 else 3*)
	If[duplicate && Length[tarMer] ===3,
		(*-----*)AddToLog[{"Skipping merging since there are duplicate data and the targerts are unclear"}, 3];
		Return[]
	];
	If[duplicate || Length[tarMer] === 4,
		{tarDat, tarType, tarSuf, tarCon} = tarMer;
		tarFile = GenerateBidsFileName[folo, <|parts, dupKey->tarDat, "type"->tarType, 
			"suf"->{tarSuf, tarCon}|>]<>".nii";
		tarStacs = StringStrip /@ Flatten[{First[Select[allType, #["Key"] === tarDat &]]["Label"]}];
		,
		{tarType, tarSuf, tarCon} = tarMer;
		tarFile = GenerateBidsFileName[folo, <|parts, "type"->tarType, 
			"suf"->{tarSuf, tarCon}|>]<>".nii";
		tarStacs = StringStrip /@ Flatten[{First[Select[allType, #["InFolder"] === tarSuf &]]["Label"]}];
	];
	debugBids[{tarDat, tarType, tarSuf, tarCon}];

	(*get the settings for the moving data*)
	movStacs = StringStrip /@ Flatten[{datType["Label"]}];
	If[datType["Class"] === "Volumes", movStacs = movStacs[[{1}]]];
	nStac = Length@movStacs;
	debugBids[{datType["Class"], nStac, {tarStacs, movStacs}}];

	movs = Select[merge["Process"], !MemberQ[multDim, #] &];
	movsMD = Select[merge["Process"], MemberQ[multDim, #] &];
	movsAll = Join[movs, movsMD];
	nSet = Length[movsAll];

	(*get the settings for the merging*) 
	overT = ConfigLookup[datType, "Merging", "Overlap"];
	pad = ConfigLookup[datType, "Merging", "Padding"];
	motion = ConfigLookup[datType, "Merging", "Motion"];
	reverse = ConfigLookup[datType, "Merging", "Reverse"];
	split = ConfigLookup[datType, "Merging", "SplitRegistration"];

	{overT, overM} = If[IntegerQ[overT], {overT, overT}, overT];
	If[overT === 0, pad = 0; motion = False];

	settings = <|
		"Merge Overlap" -> {overT, overM},
		"Merge Padding" -> pad,
		"Merge Motion" -> motion,
		"Merge Reverse" -> reverse,
		"Merge Split" -> split
	|>;

	debugBids["overlap and split: ",{overT, pad, split}];

	(*start the merging, if checkfile has label done and version is recent skip*)
	(*-----*)AddToLog[{"The types that will be merged are: "}, 3];
	(*-----*)AddToLog[{StringJoin@Riffle[movsAll,", "]}, 4];
	If[CheckFile[outfile, "done", verCheck],
		(*-----*)AddToLog[{"Processing already done."}, 3];
		Return[]];
	If[pad > 0, 
		(*-----*)AddToLog[{"Padding overlap with: ", pad}, 5]];

	debugBids[Column[{
		{tarSuf, tarCon, tarStacs, foli},
		("*"<>#<>"*"<>tarSuf<>"*"<>tarCon<>".nii.gz")&/@tarStacs,
		FileNameJoin[{DirectoryName[foli], tarType/.bidsTypes}]
	}]];
	(*get all the moving and target data file names*)
	targets = Flatten[
		FileNames["*"<>#<>"*"<>tarSuf<>"*"<>tarCon<>".nii.gz", FileNameJoin[{DirectoryName[foli], tarType/.bidsTypes}]]&/@tarStacs
	];
	debugBids[targets];

	(*figure out all the filenames*)
	movings = (mov = #; Flatten[FileNames["*"<>#<>"*"<>mov<>".nii.gz", foli]& /@movStacs])& /@movs;
	movingsMD = (mov = #; Flatten[FileNames["*"<>#<>"*"<>mov<>".nii.gz", foli]& /@movStacs])& /@movsMD;
	movingsAll = Join[movings, movingsMD];
	debugBids[movingsAll];

	(*check if number of stacks are consistant*)
	If[!AllTrue[n = Join[{Length[targets]}, Length/@movingsAll], #===nStac&],
		(*-----*)AddToLog[{"Not all types have the same number of stacs:", StringJoin@Riffle[ToString/@n,", "]}, 3];
		Return[],
		(*-----*)AddToLog[{"Start joining ", nStac, "stacs for", nSet, "dataypes"}, 3];
	];

	(*------------------ Importing off all data after checks ------------------*)

	(*import the Target data, import merged target if it exists else merge it*)
	(*-----*)AddToLog[{"Importing and processing the target data"}, 4];

	(*if target is same type as moving never load from disk*)
	sameType = tarType === datType["Type"] && tarSuf === datType["Suffix"];
	If[NiiFileExistQ[tarFile] && !sameType,
		{target, voxt} = ImportNii[tarFile];
		(*-----*)AddToLog[{"Splitting the primary datatype that already existed"}, 4];
		If[nStac=!=1, 
			target = SplitSets[target, nStac, overT, ReverseSets->reverse, PadOverlap->pad], 
			target = {target}
		];
		,
		(*remake target*)
		{target, vox} = Transpose[ImportNii/@targets];
		voxt = First@vox;
		debugBids["voxel size per stack: ", {vox, voxt}];
		(* make data real valued*)
		target = If[RealValuedNumberQ[target[[1, 1, 1, 1]]], target, Abs[target]];

		(*-----*)AddToLog[{"Joining the primary datatype", If[motion,"with","without"], "motion correction"}, 4];
		If[nStac=!=1,
			target = JoinSets[target, overT, voxt, ReverseSets->reverse, MotionCorrectSets->motion, 
				NormalizeSets->True, NormalizeOverlap->True, MonitorCalc->False];
			debugBids["target dimensions: ", Dimensions@target];
			target = SplitSets[target, nStac, overT, ReverseSets->reverse, PadOverlap->pad];
		];
	];
	debugBids["target dimensions: ", Dimensions/@target];

	(*import the Moving data, import the mulit dimm seperately*)
	(*-----*)AddToLog[{"Importing and processing the moving data"}, 4];

	(*import the 3D moving data *)
	{moving, vox} = Transpose[(files=#; Transpose[ImportNii[#]&/@files]) &/@ movings];
	(* make data real valued to prevent errors*)
	moving = If[RealValuedNumberQ[N@#[[1,1,1,1]]], #, Abs[#]] &/@ moving;
	leng = Length[movs]; (*number of moving contrasts*)
	voxm = First@vox; (*voxel size per stack*)
	(*check voxel sizes of moving*)
	If[!Equal@@voxm,
		(*-----*)AddToLog[{"**********  The voxel size is not the same for all stacks **********"}, 0];
		(*-----*)AddToLog[{"Voxel size per stack: ", voxm}, 4];
		(*-----*)AddToLog[{"", (Dimensions /@ First@moving) voxm}, 4];
	];

	(*import the multi dim data*)
	movingMD = If[movingsMD=!={},
		(*4D data has to be transposed*)
		{movingMD, vox} = Transpose[(files=#;Transpose[ImportNii[#]&/@files])& /@movingsMD];
		lengMD = Length /@ movingMD[[All, 1, 1]];(*number of moving multi dim constrast*)
		Flatten[movingMD, {1, 4}],
		lengMD=0;{}];
	movingA = Join[moving, movingMD];
	movsName = Flatten[{movs, ConstantArray[#[[1]], #[[2]]] & /@ Thread[{movsMD, lengMD}]}];

	(*figure out the scaling of each contrast*)
	posAll = Range[Length[movsName]];
	posNat = Flatten[Position[movsName, _?(MemberQ[native, #] &), {1}]];
	posScale = Complement[posAll, posNat];
	voxtR = First@voxm;
	voxF = If[MemberQ[native, movsName[[#]]], voxtR, voxt]&;

	debugBids["moving dimensions: ", Dimensions/@{movingA, moving, movingMD}];
	debugBids["moving before registr: ", Column[Dimensions /@ # & /@ movingA]];
	debugBids["number of sets: ", {leng, lengMD}];
	debugBids["names:", movsName];
	debugBids["positions:", {posNat, posScale}];

	(*import the json information*)
	jsonAll = (files=#; MergeJSON[ImportJSON[ConvertExtension[#, ".json"]]&/@files]) &/@ movingsAll;
	
	debugBids["json dimensions: ", Dimensions@jsonAll];

	(*------------------ performing registration to target for all constrasts ------------------*)

	(*perform motion correction after target merging*)
	(*If motion correction for joning is False and target is of same type no need for motion correction*)
	debugBids["go into registration:", {motion, sameType, !(!motion && sameType)}];
	If[!(!motion && sameType), 
		(*-----*)AddToLog[{"Performing the registration for the all the datasets"}, 4];
		im = First@First@Position[movs, merge["Moving"]];
		debugBids["location moting contrast: ", im];

		movingA = Table[
			(*-----*)AddToLog[{"Stack: ", i}, 5];
			debugBids["start registration: ", i];

			(*make target in native space*)
			targetR = RescaleData[target[[i]], {voxt, voxtR}];

			(*make masks*)
			debugBids[Dimensions/@{movingA[[im, i]], target[[i]], targetR}];
			mskm = DilateMask[Mask[NormalizeData[movingA[[im, i]]], 5], 5];
			mskt = DilateMask[Mask[NormalizeData[target[[i]]], 5], 5];
			msktR = DilateMask[Mask[NormalizeData[targetR], 5], 5];

			(*register the data*)
			metReg = Switch[datType["InFolder"], 
				"dix", "rigid", 
				"quant", {"rigid", "affine"}, 
				_, {"rigid","affine","bspline"}
			];

			(*only register if not the same contrast and not the first stack*)
			debugBids["check for registration: ", {i===If[reverse, nStac, 1], sameType, i===If[reverse, nStac, 1]&& sameType}];
			
			If[i===If[reverse, nStac, 1] && sameType,
				(*just select data and do nothing*)
				debugBids["no registration: ", i];
				movingA[[All, i]]
				,
				(*move the target from anatomical to native space*)
				func = If[i===If[reverse, nStac, 1] || split===False, 
					RegisterData, RegisterDataSplit];
				reg = ToPackedArray@N@Chop@func[
					{movingA[[im, i]], mskm, voxm[[i]]}, {target[[i]], voxt}, 
					Iterations->300, BsplineSpacing->20 voxt, InterpolationOrderReg->1, NumberSamples -> 10000,
					PrintTempDirectory->False, MethodReg->metReg];

				(*if padding enlarge the moving files*)
				If[pad > 0,					
					reg = ArrayPad[reg, Ceiling@{{pad, pad}/2, 0, 0}];
					movp = Transpose[ArrayPad[#, Ceiling@{{pad, pad}/2, 0, 0}]&/@movingA[[All, i]]],
					movp = Transpose[movingA[[All, i]]]
				];
				debugBids["Dimension before registration: ", Dimensions@movp, Dimensions/@Transpose[movp]];

				(*register back the target from native space to anatomy and tranfrom the rest*)
				func = If[i===If[reverse, nStac, 1] || split===False, 
					RegisterDataTransform, RegisterDataTransformSplit];
				movp = Flatten[(
					debugBids["registering: ", #[[1]]];
					If[#[[1]]==={}, {},
						Transpose@ToPackedArray@N@Chop@Last@func[
							#[[2]], {reg, voxm[[i]]}, {movp[[All, #[[1]]]], voxm[[i]]},
							Iterations->300,  BsplineSpacing->30 voxt, InterpolationOrderReg->1, NumberSamples -> 10000, 
							PrintTempDirectory->False, DeleteTempDirectory->False, MethodReg->metReg
							, BsplineDirections -> {1, 1, 0}
						]
					])& /@ {{posScale, {target[[i]], mskt, voxt}}, {posNat, {targetR, msktR, voxtR}}}
				, 1][[Ordering[Join[posScale, posNat]]]];
				debugBids["Dimensions after registraion: ", Dimensions@movp, Dimensions/@movp];
				movp
			]
		, {i, 1, nStac}];

		(*extract all parameters after registration*)
		debugBids["after dimensions befor transpose: ", Dimensions/@movingA, Dimensions@movingA];
		movingA = Transpose[movingA];
	];(*clolse motion moving*)


	(*------------------ actually join the data and reorder for multi dim ------------------*)

	debugBids["after dimensions: ", Dimensions@movingA];
	debugBids["after registration: ", Column[Dimensions /@ # & /@ movingA]];

	(*join the moving types*)
	(*-----*)AddToLog[{"Joining the data"}, 4];
	movingA = If[nStac===1,
		movingA[[All, 1]],
		debugBids["joining: ", posAll];
		JoinSets[movingA[[#]], overT, voxF[#], 
			MonitorCalc->False, MotionCorrectSets->False, 
			PadOverlap->pad, ReverseSets->reverse, 
			NormalizeSets->MemberQ[nonQuant, movsName[[#]]], NormalizeOverlap->MemberQ[nonQuant, movsName[[#]]]
		]&/@posAll
	];

	debugBids["after merging: ", Column[Dimensions /@ movingA]];		

	(*split in single dim and multi dim*)
	If[movingMD =!= {},
		moving = movingA[[1;;leng]];
		movingMD = movingA[[leng+1;;]];
		movingMD = Transpose[movingMD[[#[[1]];;#[[2]]]]] & /@ ({1, 0} + # & /@ Partition[Prepend[Accumulate[lengMD], 0], 2, 1]);
		movingA = Join[moving, movingMD];
	];


	(*------------------ exporting the data ------------------*)

	(*export the joined data with the merged json*)
	(*----*)AddToLog["Exporting the calculated data to:", 4];
	(*----*)AddToLog[outfile, 5];
	(
		debugBids["Exporting: ", {movsAll[[#]], voxF[#]}];
		ExportNii[movingA[[#]], voxF[#], outfile<>"_"<>movsAll[[#]]<>".nii"];
		Export[outfile<>"_"<>movsAll[[#]]<>".json", MergeJSON[{jsonAll[[#]], settings}]];
	)&/@ Range[nSet];

	(*make the checkfile*)
	MakeCheckFile[outfile, Sort@Join[{"Check"->"done"}, Normal@datType]];
	(*----*)AddToLog["Finished merging", 3, True];
]


(* ::Subsection:: *)
(*5. MuscleBidsSegment*)


(* ::Subsubsection::Closed:: *)
(*MuscleBidsSegment*)


Options[MuscleBidsSegment] = {ProcessSubjects->All, VersionCheck->False};

SyntaxInformation[MuscleBidsSegment] = {"ArgumentsPattern" -> {_, _., _., OptionsPattern[]}};

MuscleBidsSegment[folder_?StringQ, opts:OptionsPattern[]] := MuscleBidsSegment[folder, GetConfig[folder], opts];


MuscleBidsSegment[folder_?StringQ, config_?AssociationQ, opts:OptionsPattern[]]:=Block[{dir},
	debugBids["starting MuscleBidsSegment"]; 
	dir = Directory[]; SetDirectory[folder];
	MuscleBidsSegment[
		ConfigLookup[config, "folders", "mergeData"],(*the input folder for the data, output is in same folder*)
		ConfigLookup[config, "folders", "mergeData"],
		config["datasets"],(*what data for segmentation*)
		opts];
	SetDirectory[dir];	
]


MuscleBidsSegment[datFol_?StringQ, outFol_?StringQ, datDis_?AssociationQ, opts:OptionsPattern[]]:= BidsFolderLoop[datFol, outFol, datDis, Method->"MuscleBidsSegment", opts]


(* ::Subsubsection::Closed:: *)
(*MuscleBidsSegmentI*)


MuscleBidsSegmentI[foli_, folo_, datType_, allType_, verCheck_]:=Block[{
		segment, segType, segTypeLab, checkFile, fol, segLocation, device,
		parts, outfile, segfile, out, vox, seg, duplicate, key, dupKey, status, segiu,
		voxS, tari, movi, segi, tar, mov, dim
	},

	status = "done";

	debugBids["Starting MuscleBidsSegmentI"];
	debugBids[foli, folo];
	debugBids[datType];

	(*get the segment data type*)
	segment = datType["Segment"];
	debugBids[segment];
	If[segment===Missing["KeyAbsent", "Segment"],	
		(*-----*)AddToLog[{"No Segmentations defined for this data"}, 3];
		Return[]
	];

	(*figure out if duplicate handeling is needed.*)
	duplicate = KeyExistsQ[datType, "Key"];
	dupKey = If[datType["Class"]==="Stacks", "stk", "chunk"];
	key = If[duplicate, dupKey->StringStrip@datType["Key"], Nothing];

	{fol, parts} = PartitionBidsFolderName[foli];
	debugBids[{fol, parts}];
	checkFile = GenerateBidsFileName[folo, <|parts, key, "type" -> "seg", "suf"->{"auto", datType["Type"]}|>];

	(*Get the segmentation targets and its names*)
	segType = segment["Target"];	
	If[ArrayDepth[segType]===1, segType = {segType}];
	segTypeLab = StringRiffle[#, "_"]&/@segType;
	
	debugBids[segType];
	debugBids[segTypeLab];

	(*Check if segmentation needs to be performed*)
	If[CheckFile[checkFile, "done", verCheck],
		(*-----*)AddToLog[{"Segmentation already done for:", StringJoin@Riffle[segTypeLab,", "]}, 3];
		Return[]
	];
	(*-----*)AddToLog[{"The types that will be segmented are: ", StringJoin@Riffle[segTypeLab,", "]}, 3];

	Switch[ConfigLookup[datType, "Segment", "Method"],
		
		(*Automatic segmentations using NN*)
		Automatic,

		(*Loop over the segmentation types if more are specified*)
		Table[
			(*-----*)AddToLog[{"Performing segmentation for ", StringRiffle[segi, "_"]}, 3];

			(*get the correct filenames*)
			segiu = If[duplicate, Rest[segi], segi];
			outfile = GenerateBidsFileName[folo, <|parts, key, "type" -> "seg", "suf" -> Join[{"auto"}, segiu]|>]<>".nii";
			segfile = GenerateBidsFileName[fol, <|parts, key, "type" -> First[segiu], "suf" -> Rest[segiu]|>]<>".nii";

			(*check if target file exists if so perform the segmentation*)
			If[!NiiFileExistQ[segfile],
				AddToLog[{"The segmentation file does not exist", segfile}, 4];
				status = "error"
				,
				segLocation = segment["Location"];
				{out, vox} = ImportNii[segfile];
				voxS = ConfigLookup[datType, "Segment", "VoxSize"];

				If[voxS =!= Automatic, 
					debugBids[voxS];
					AddToLog[{"Using specified reduced voxel size", voxS}, 4];
					dim = Dimensions[out]; out = RescaleData[out, {vox, voxS}]
				];

				seg = SegmentData[out, segLocation, TargetDevice -> ConfigLookup[datType, "Segment", "Device"], Monitor -> False];
				If[voxS =!= Automatic, seg = RescaleSegmentation[seg, dim]];
				ExportNii[seg, vox, outfile];
			];
			, {segi, segType}			
		],

		(*Register existing segmentation*)
		"Registration",

		tari = segment["Target"];
		movi = segment["Moving"];
		segi = segment["Segmentation"];

		voxS = ConfigLookup[datType, "Segment", "VoxSize"];

		outfile = MakeFileNameI[{duplicate, dupKey}, {fol, parts}, tari, {"seg", {"reg"}}];
		seg = MakeFileNameI[{duplicate, dupKey}, {fol, parts}, segi, {"seg", {"auto"}}];
		tar = MakeFileNameI[{duplicate, dupKey}, {fol, parts}, tari, {"", {}}];
		mov = MakeFileNameI[{duplicate, dupKey}, {fol, parts}, movi, {"", {}}];

		debugBids[Column[{out, seg, tar, mov}]];

		{tar, voxt} = ImportNii[tar];
		{mov, voxm} = ImportNii[mov];
		{seg, voxs} = ImportNii[seg];

		mask = Mask[NormalizeData[tar], 5, MaskSmoothing -> True, MaskDilation -> 5];
		If[voxS =!= Automatic, mov = RescaleData[mov, {voxm, voxS}]; voxm = voxS;];

		debugBids[Column[Dimensions/@{seg, tar, mov}]];

		seg = Table[RegisterDataTransform[
			{tar[[{i}]], mask[[{i}]], voxt}, {mov, voxm}, {seg, voxs},
			MethodReg -> {"rigid", "affine", "bspline"}, BsplineSpacing -> {30, 15, 15}, NumberSamples -> 20000, 
			Resolutions -> 1, Iterations -> 200, DeleteTempDirectory -> False, TransformMethod -> "Segmentation"
		][[2]], {i, 1, 3}];

		ExportNii[seg, voxt, outfile];

	];
	(*make the checkfile*)
	MakeCheckFile[checkFile, Sort@Join[{"Check" -> status}, Normal@datType]];
	(*----*)AddToLog["Finished the segmentation", 3, True];
]


MakeFileNameI[{dup_, dupKey_}, {fol_, parts_}, tags_, {type_, lab_}] := Block[{key, typ, tagsu, dupl},
	dupl = dup || Length[tags] === 4;
	{key, tagsu} = If[dupl, {First[tags], Rest[tags]}, {Nothing, tags}];
	{typ, tagsu} = 
	If[type === "", {First@tagsu, Rest@tagsu}, {type, tagsu}];
	key = If[dupl, dupKey -> StringStrip[key], Nothing];
	GenerateBidsFileName[fol, <|parts, key, "type" -> typ, "suf" -> Join[lab, tagsu]|>] <>".nii"
]


(* ::Subsection:: *)
(*6. MuscleBidsTractography*)


(* ::Subsubsection::Closed:: *)
(*MuscleBidsTractography*)


Options[MuscleBidsTractography] = {ProcessSubjects->All, VersionCheck->False, BidsTractographyMethod->"Full"};

SyntaxInformation[MuscleBidsTractography] = {"ArgumentsPattern" -> {_, _., _., OptionsPattern[]}};

MuscleBidsTractography[folder_?StringQ, opts:OptionsPattern[]] := MuscleBidsTractography[folder, GetConfig[folder], opts];


MuscleBidsTractography[folder_?StringQ, config_?AssociationQ, opts:OptionsPattern[]]:=Block[{dir},
	debugBids["starting MuscleBidsTractography"];
	dir = Directory[]; SetDirectory[folder];
	MuscleBidsTractography[
		ConfigLookup[config, "folders", "mergeData"],(*the input folder for the data, output is in same folder*)
		ConfigLookup[config, "folders", "mergeData"],
		config["datasets"],(*what data for tractography*)
		opts];
	SetDirectory[dir];	
]


MuscleBidsTractography[datFol_?StringQ, outFol_?StringQ, datDis_?AssociationQ, opts:OptionsPattern[]]:= BidsFolderLoop[datFol, outFol, datDis, Method->"MuscleBidsTractography", opts]


(* ::Subsubsection::Closed:: *)
(*MuscleBidsTractographyI*)


MuscleBidsTractographyI[foli_, folo_, datType_, allType_, verCheck_, met_]:=Block[{
		tracto, tractType, tractSeg, tractStopLab, tractStopVal, tractStopLabNam, trkFile,
		tractTypeLab, fol, parts, checkFile, outfile, seed, lenS, segBone, tractSegLab,
		datfile, stopfile, tens, vox, dim, stop, ang, step, tracts, seeds, len, seg, curv,
		segfile, muscles, mlabs, mus, bones, con, leng, dens, flip, per, duplicate, key, keyS,
		voxs, dims
	}, 

	debugBids["Starting MuscleBidsTractographyI"];
	debugBids[foli, folo];
	debugBids[datType];

	(*!!options!!*)
	{len, ang, step, seed} = {{15, 500}, 25, Automatic (*1.5*), Scaled[0.66]};
	{lenS, segBone} = {{15, 500}, 100};

	(*figure out if duplicate handeling is needed.*)
	duplicate = KeyExistsQ[datType, "Key"];
	key = If[duplicate, "stk"->StringStrip@datType["Key"], Nothing];

	(* Extract tractography data *)
	tracto = datType["Tractography"]; 

	(* Check if tractography is specified *)
	If[tracto===Missing["KeyAbsent", "Tractography"],
		(*-----*)AddToLog[{"No tractography defined for this data"}, 3];
		Return[];
	];

	(* Extract flip and permutation settings*)
	{flip, per} = ConfigLookup[datType, "Tractography", "FlipPermute"];

	(* Extract tractography target, segmentation and stopping criteria *)
	tractType = tracto["Target"];
	tractSeg = tracto["Segmentation"];
	{tractStopLab, tractStopVal} = Transpose@tracto["Stopping"];

	(* Ensure tractStopLab and tractStopVal are lists *)
	If[ArrayDepth[tractStopLab]===1, tractStopLab = {tractStopLab}];
	If[ArrayDepth[tractStopVal]===1, tractStopVal = {tractStopVal}];

	(* Generate labels for tractStopLab and tractType *)
	tractStopLabNam = StringRiffle[#, "_"]&/@tractStopLab;
	tractTypeLab = StringRiffle[tractType, "_"];
	tractSegLab = StringRiffle[tractSeg, "_"];

	(* Partition the input folder name *)
	{fol, parts} = PartitionBidsFolderName[foli];

	trkFile = GenerateBidsFileName[folo, <|parts, key, "type" -> First[tractType], "suf" -> Join[tractType[[2;;2]], {"trk"}]|>]<># &;
	checkFile = trkFile[""];

	(* If tractography and segmentation is already done, log the event *)
	If[CheckFile[checkFile, "done", verCheck],
		(*----*)AddToLog[{"Tractography and segmentation already done for:", tractTypeLab}, 3];
		Return[]
	];

	(* Check if tractography needs to be performed *)
	Which[
		CheckFile[checkFile, "track", verCheck],
		(* If tractography is already done, log the event *)
		(*----*)AddToLog[{"Tractography already done for:", tractTypeLab}, 3];
		,
		!(met === "Full" || met==="Tractography"),
		(*----*)AddToLog[{"Skipping tractography because of method:", met}, 3];
		,
		True,
		(* If tractography is not done, log the event and proceed with the processing*)
		(*----*)AddToLog[{"Starting the whole volume tractography"}, 3, True];
		(*----*)AddToLog[{"The type that will be tracted is: ", tractTypeLab}, 4];

		(* Generate stop and data file names *)
		datfile = GenerateBidsFileName[fol, <|parts, key, "type" -> First[tractType], "suf" -> Rest[tractType]|>]<>".nii";
		stopfile = GenerateBidsFileName[fol, <|parts, key, "type" -> First[#], "suf" -> Rest[#]|>]<>".nii"&/@tractStopLab;

		(* Check if the tensor file and stop files exist *)
		Which[
			!NiiFileExistQ[datfile],
			(*----*)AddToLog[{"The tensor file does not exist", datfile}, 4];
			,
			!And@@(NiiFileExistQ/@stopfile),
			(*----*)AddToLog[{"Not all stop files exist not exist", stopfile}, 4];
			,
			True,
			(* If all files exist, proceed with the tractography processing*)

			(*----*)AddToLog[{"Importing the needed data"}, 4];
			{tens, vox} = ImportNii[datfile];
			tens = Transpose@ToPackedArray@N@Chop@tens;
			dim = Rest@Dimensions@tens;

			(* Import stop files *)
			stop = (
				{stop, voxs } =ImportNii[#];
				If[voxs=!=vox, RescaleData[stop, {voxs, vox}], stop]
			)&/@stopfile;
			debugBids[Dimensions@stop];
			stop = Transpose[{stop, tractStopVal}];

			(*----*)AddToLog[{"Starting the whole volume tractography"}, 4];

			(* Perform tractography *)
			{tracts, seeds} = FiberTractography[tens, vox, stop,
				InterpolationOrder -> 0, StepSize -> step, Method -> "RK4", MaxSeedPoints -> seed, 
				FiberLengthRange -> len, FiberAngle -> ang, TractMonitor -> False,
				TensorFlips -> flip, TensorPermutations -> per, Parallelization -> True
			];

			(* Export the tractography results *)
			(*-----*)AddToLog[{"Exporting the whole volume tractography"}, 4];
			ExportTracts[trkFile[".trk"], tracts, vox, dim, seeds];

			MakeCheckFile[checkFile, Sort@Join[{"Check" -> "track"}, Normal@datType]];
			(*----*)AddToLog["Finished the tractograpy", 3, True];
		];
	];

	(* Check if segmentation needs to be performed *)
	Which[
		CheckFile[checkFile, "seg", verCheck],
		(* If segmentation or tractography is already done, log the event *)
		(*----*)AddToLog[{"Segmentation of tractography already done for:", tractSegLab}, 3];
		,
		!(met === "Full" || met==="Segmentation"),
		(*----*)AddToLog[{"Skipping tractography segmentation because of method:", met}, 3];
		,
		True,
		(* If segmentation or tractography is not done, log the event and proceed with the processing *)
		(*----*)AddToLog[{"Starting the tractography segmentation"}, 3, True];
		(*----*)AddToLog[{"The tractography will be segmented using: ", tractSegLab}, 4];

		If[duplicate, keyS = "stk"->StringStrip@First[tractSeg]; tractSeg = Rest[tractSeg];, keyS = Nothing;];
		segfile = GenerateBidsFileName[fol, <|parts, keyS, "type" -> First[tractSeg], "suf" -> Rest[tractSeg]|>]<>".nii";
		debugBids[Column@{trkFile[".trk"], segfile}];

		Which[
			!NiiFileExistQ[segfile],
			(*----*)AddToLog[{"The segmentation file does not exist: ", segfile}, 4];
			,
			!FileExistsQ[trkFile[".trk"]],
			(*----*)AddToLog[{"The tracts file does not exist: ", trkFile[".trk"]}, 4];
			,
			True,

			(*----*)AddToLog[{"Importing the needed data"}, 4];
			(*import trk file if needed, if processing was done in same run this is skipped*)
			If[Dimensions[tracts] === {}, {tracts, vox, dim, seeds} = ImportTracts[trkFile[".trk"]]];
			{seg, voxs} = ImportNii[segfile];
			dims = Dimensions@seg;

			debugBids[{{dims,voxs, dims voxs}, {dim, vox, dim vox}}];

			(*----*)AddToLog[{"Analyzing the segmentation"}, 4];
			(*split the segmentations in bones and muscles*)
			{muscles, mlabs} = SplitSegmentations[SelectSegmentations[seg, Range[segBone]]];
			mus = Dilation[Normal@Total@Transpose@muscles, 3];
			bones = Unitize[SelectSegmentations[seg, Range[segBone + 1, segBone + 30]]];

			(*----*)AddToLog[{"Analyzing the tracts"}, 4];
			(*perform fitting and segmentations of the tracts*)
			tracts = SegmentTracts[tracts, muscles, voxs, dims, FiberLengthRange -> lenS, FitTractSegments->True];

			(*Calculate tract parameters*)
			seed = SeedDensityMap[seeds, voxs, dims];
			dens = TractDensityMap[tracts, voxs, dims];
			leng = TractLengthMap[tracts, voxs, dims];
			ang = TractAngleMap[tracts, voxs, dims];
			curv = TractCurvatureMap[tracts, voxs, dims];

			(*----*)AddToLog[{"Exporting the results and maps"}, 4];
			(*export stuff*)
			con = Context[con];
			ExportNii[ToExpression[con<>#], voxs, trkFile["_"<>#<>".nii.gz"]]& /@ {"dens", "leng", "ang", "seed","curv"};
			ExportTracts[trkFile["_seg.trk"], tracts, voxs, dims, seeds];

			(*export plot scene*)
			(*----*)AddToLog[{"Exporting the scene"}, 4];
			Export[trkFile["_plot.wxf"],
				PlotSegmentedTracts[tracts, muscles, bones, dims, voxs, 
					OutputForm -> "All", Method -> "tube", MaxTracts -> 10000]
			];

			MakeCheckFile[checkFile, Sort@Join[{"Check"->"seg"}, Normal@datType]];
			(*----*)AddToLog["Finished the tractograpy segmentation", 3, True];
		];
	];

	If[CheckFile[checkFile, "seg", verCheck],
		MakeCheckFile[checkFile, Sort@Join[{"Check"->"done"}, Normal@datType]]
	];
]


(* ::Subsection:: *)
(*7. MuscleBidsAnalysis*)


(* ::Subsubsection::Closed:: *)
(*MuscleBidsAnalysis*)


Options[MuscleBidsAnalysis] = {ProcessSubjects->All, VersionCheck->False, BidsOutputImages->"All"};

SyntaxInformation[MuscleBidsAnalysis] = {"ArgumentsPattern" -> {_, _., _., OptionsPattern[]}};

MuscleBidsAnalysis[folder_?StringQ, opts:OptionsPattern[]] := MuscleBidsAnalysis[folder, GetConfig[folder], opts];


MuscleBidsAnalysis[folder_?StringQ, config_?AssociationQ, opts:OptionsPattern[]]:=Block[{dir}, 
	debugBids["starting MuscleBidsAnalysis"];
	dir = Directory[]; SetDirectory[folder];
	MuscleBidsAnalysis[
		ConfigLookup[config, "folders", "mergeData"],(*the input folder for the data*)
		ConfigLookup[config, "folders", "analysis"],(*the output folder for analsys*)
		config["analysis"],(*what data for analysis*)
		opts];
	SetDirectory[dir];	
]


MuscleBidsAnalysis[datFol_?StringQ, anFol_?StringQ, datDis_?AssociationQ, opts:OptionsPattern[]] := Block[{data, name},
	(*loop over all folders*)
	BidsFolderLoop[datFol, anFol, datDis, Method->"MuscleBidsAnalysis", opts];

	(*processing for joining all generated datafiles*)
	data = Join @@ (Import /@ Select[FileNames["*.wxf", anFol, Infinity], 
		First[StringSplit[FileBaseName[#], "_"]] =!= "All" &]);
	name = FileNameJoin[{anFol, "All_"<>DateName[]}];

	(*export to summary data file*)
	Export[name <> ".xlsx", data];
	Export[name <> ".wxf", data];
]


(* ::Subsubsection::Closed:: *)
(*MuscleBidsAnalysisI*)


MuscleBidsAnalysisI[foli_, folo_, datDis_, verCheck_, imOut_] := Block[{
		maskErosion, tractWeighting, anaSeg, fol, parts, segfile, fileName, partsO, fileNameO, checkFileX, checkFileI,
		n, what, seg, vox, vol, musNr, musName, sideName, sideNr, dataLabs, anaType, densLab, str,
		densFile, trType, trMask, segT,	datfile, data, scale, tract, outFile, meanType, hasKey,
		quantIm, segIm, tractIm, imRef, ref, crp, refC, size, pos, sliceData, make3DImage, make2DImage,
		cols, cFun, ran, clip, type, imFile, imDat, voxi, voxs, segPl, imTrk, trkfile, reffile,
		addLabel, img, lab
	},

	debugBids["Starting MuscleBidsAnalysisI"];
	debugBids[{foli, folo}];

	(*Options*)
	maskErosion = True;
	tractWeighting = False;

	(*----------- make the xls files -------------*)

	(*get the segmentation settings*)
	hasKey = KeyExistsQ[datDis, "Key"];
	{fol, parts} = PartitionBidsFolderName[foli];
	partsO = If[hasKey, Join[<|"stk"->StringStrip@datDis["Key"]|>, parts], parts];
	debugBids[{parts, partsO, hasKey}];

	If[hasKey,
		(*----*)AddToLog[{"Multiple analysis - starting:", datDis["Key"]}, 2, True];
	];

	(*file name functions*)
	fileName = If[hasKey,
		GenerateBidsFileName[fol, <|parts, "stk" -> StringStrip@#[[1]], 
			"type" -> StringStrip@#[[2]], "suf" -> #[[3;;]]|>]&,
		GenerateBidsFileName[fol, <|parts, "type" -> First[#], "suf" -> Rest[#]|>]&
	];
	fileNameO = FileNameJoin[{GenerateBidsFolderName[folo, #], GenerateBidsName[#]}]&;

	(*checkfiles image and xls*)
	partsO["suf"] = {"xls"}; 
	checkFileX = fileNameO[partsO];
	partsO["suf"] = {"img"}; 
	checkFileI = fileNameO[partsO];

	anaSeg = datDis["Segmentation", "Type"];
	{n, what} = datDis["Segmentation", "Labels"];
	(*----*)AddToLog[{"Segmentation file used for analysis is:", StringRiffle[StringStrip/@anaSeg, "_"]}, 3];

	(*Perform the segmentation analysis, what are the label names and volumes*)
	debugBids[{"Segmentation to xls analysis", parts}];
	segfile = fileName[anaSeg]<>".nii";

	Which[
		(*segmentation is already done*)
		CheckFile[checkFileX, "done", verCheck],
		(*----*)AddToLog[{"Skipping: the segmentation to xls analysis is already done "}, 4],

		(*no segmentation file exists*)
		!NiiFileExistQ[segfile],
		(*----*)AddToLog[{"The segmentation file does not exist: ", segfile}, 4],

		(*segmentation file existes perform the analysis*)
		True,
		(*----*)AddToLog[{"Importing and processing the needed segmentation"}, 4];
		{seg, vox} = ImportNii[segfile];
		{seg, musNr} = SelectSegmentations[SplitSegmentations[seg], Range[n]];

		(*----*)AddToLog[{"Calculating the volume of the segmentation"}, 4];
		vol = SegmentationVolume[seg, vox];

		(*switch to the correct segmentation label*)
		Switch[what,
			"Legs",
			(*----*)AddToLog[{"Using the Legs for muscle labeling"}, 4];
			musName = MuscleLabelToName[musNr, GetAssetLocation["MusclesLegLabels"]];
			{musName, sideName} = Transpose[(str = StringSplit[#, "_"];
				If[Last[str] == "Left" || Last[str] == "Right",
					{StringRiffle[Most@str, "_"], Last@str},
					{StringRiffle[str, "_"], "Both"}
				]) & /@ musName];
			sideNr = sideName /. Thread[{"Left", "Right", "Both"} -> {1, 2, 3}];
			musNr = MuscleNameToLabel[musName, GetAssetLocation["MusclesLegAllLabels"]];


			,
			_,(*unknown label type*)
			(*----*)AddToLog[{"Unknown Label type: ", what}, 4];
		];

		(*summarize the data labels for export later*)
		dataLabs = Join[
			Thread[{"subject", "subjectID", "session", "sessionID"} -> Transpose@ConstantArray[{
				parts["sub"], ToExpression[Last@StringCases[parts["sub"], NumberString]],
				parts["ses"], ToExpression[Last@StringCases[parts["ses"], NumberString]]}, Length[musNr]
			]],
			{"muscle"->musName, "muscleID"->musNr, "side"->sideName, "sideID"->sideNr, "volume"->vol}
		];

		(*get the labels for analysis, see if and which need to be done using tract based analysis*)
		debugBids["data analysis"];
		(*labels to be analysed*)
		anaType = datDis["Analysis", "Types"];
		anaType = Flatten[Thread /@ anaType, 1];
		(*----*)AddToLog[{"Analsysis will be performed for:", StringRiffle[StringStrip/@#, "_"]&/@anaType}, 3];

		(*Figure out the tract analysis*)
		debugBids["tract mask"];
		If[KeyExistsQ[datDis["Analysis"], "TractBased"],
			densLab = {If[hasKey, StringStrip@datDis["Analysis", "TractBased"][[1,1]], Nothing], "dwi", "dti", "trk","dens"};
			densFile = fileName[densLab]<>".nii";
			trType = Flatten[Thread /@ datDis["Analysis", "TractBased"], 1];
			trType = Select[trType, MemberQ[anaType, #] &];
			(*----*)AddToLog[{"The types with tract weighting will be:", StringRiffle[StringStrip/@#, "_"]&/@trType}, 3];
			(*----*)AddToLog[{"Import tract mask:", StringRiffle[densLab, "_"]}, 4];
			trMask = ImportNii[densFile][[1]];
			trMask = If[tractWeighting, trMask, Unitize@trMask];
			,
			(*----*)AddToLog[{"No tract bases analysis given"}, 4];
			trMask = 1;
		];

		(*perform the actual data analysis *)
		(*----*)AddToLog[{"Starting the data analysis:"}, 3, True];
		debugBids[{"tract mask", Dimensions@seg, Dimensions@trMask}];
		(*make the correcet masks*)
		If[maskErosion,	seg = DilateMask[seg, -1]];
		segT = If[trMask=!=1, MaskSegmentation[seg, trMask], seg];

		(*loop over all datatypes and perform the mask analysis*)
		data = Flatten[Table[
			datfile = fileName[datType]<>".nii";
			Which[
				(*data does not exist so skip*)
				!NiiFileExistQ[datfile],
				(*----*)AddToLog[{"The data does not exist: ", StringRiffle[datType, "_"]}, 4],

				(*data exists so perform the analysis*)
				True,
				debugBids[datType];
				{data, vox} = ImportNii[datfile];

				(*figure out how to handle this type *)
				tract = MemberQ[trType, datType];
				scale = Switch[datType, {"megre","dix","fatfr"}|{"mese","t2","fatfr"}, 100, {"megre","dix","t2star"}, 1000, _, 1];
				meanType = (datType==={"dwi", "dti", "trk", "seed"} || datType==={"dwi", "dti", "trk", "dens"});
				(*----*)AddToLog[{"Processing file "<>If[tract,"with","without"]<>" tract weighting:", StringRiffle[StringStrip@datType, "_"]}, 4];

				(*mask based analysis*)
				label = StringRiffle[datType[[-2;;]], "_"];
				Thread[{label, label<>"_IQR"} -> Transpose[scale GetMaskData[data, If[tract, segT, seg], 
					GetMaskOutput->If[meanType, "MeanSTD", "MedianIQR"],
					GetMaskOnly -> If[meanType, True, False]
				]]]
			]
		, {datType, anaType}], 1];

		(*merge the data and export*)
		partsO["suf"] = {};
		outFile = fileNameO[partsO];
		debugBids[{"exporting", outFile}];
		(*----*)AddToLog[{"Data will be exported to:", DirectoryName@outFile}, 3, True];
		data = Dataset[Association /@ Transpose[Thread[#] & /@ Join[dataLabs, data]]];
		Export[outFile<>".xlsx", data];
		Export[outFile<>".wxf", data];

		MakeCheckFile[checkFileX, Sort@Join[{"Check"->"done"}, Normal@datDis]];
	];


	(*----------- make the images -------------*)


	(*figure out which images to make based on setting*)
	{quantIm, segIm, tractIm} = Switch[imOut, 
		"All", {True, True, True},
		"Quantitative", {True, False, False},
		"Segmentation", {False, True, False},
		"Tractography", {False, False, True},
		_, {False, False, False}
	];
	debugBids[{"Image Analysis", {quantIm, segIm, tractIm}}];

	(*make images if needed*)
	Which[
		(*segmentation is already done*)
		CheckFile[checkFileI, "done", verCheck],
		(*----*)AddToLog[{"Skipping: the iamges are already done"}, 4],

		(*No images need to be made*)
		!AnyTrue[{quantIm, segIm, tractIm}, # &],
		(*----*)AddToLog[{"No images will be made since option is set to None:"}, 3],

		(*making the images*)
		True,
		(*----*)AddToLog[{"Starting making the images:"}, 3];

		(*get the reference file and figure out image slice posisions*)
		imRef = datDis["Images", "Reference"];
		(*----*)AddToLog[{"Checking the reference file for 2D images: ", StringRiffle[imRef, "_"]}, 4];
		reffile = fileName[imRef]<>".nii";
		debugBids[{reffile, NiiFileExistQ[reffile]}];

		(*quantIm and SegIm need refffile, check if there to get needed information.*)
		If[!NiiFileExistQ[reffile],
			(*----*)AddToLog[{"No reference file skipping 2D quant and seg images."}, 4]; 
			quantIm = segIm = False;
			,
			(*get the ref data for the slice posisions and background of seg images*)
			{ref, vox} = ImportNii[reffile];
			crp = FindCrop[ref, CropPadding -> 10];
			refC = ApplyCrop[ref, crp];
			size = Dimensions[refC] vox;

			pos = GetSlicePositions[GaussianFilter[refC, 15], vox, MakeCheckPlot -> False, 
				DropSlices -> {1, 1, 1}, PeakNumber -> {0, 1, 2}];
			pos[[1]] = Reverse[Range[0., 1., 1/(Ceiling[Divide @@ size[[;; 2]]] + 1)][[2 ;; -2]] size[[1]]];

			(*Function to extract slice data for 2D images*)
			sliceData = Block[{slDat},
				slDat = GetSliceData[ApplyCrop[#, crp, {vox, voxi}], pos, voxi];
				{slDat[[1]], {slDat[[3, 1]], slDat[[2, 1]], Reverse[slDat[[3, 2]], 2]}, {}}
			] &;
		];

		(*3D image function needed for segmentation and tractography*)
		make3DImage = With[{gc = #, sc = 0.75}, 
			ImageResize[ImagePad[ImageCrop@Image[Graphics3D[Table[
				Translate[Rotate[(First@gc), -i 90 Degree, {0, 0, 1}, 0.5 Options[gc, PlotRange][[1, 2, All, 2]]], 
					{sc i Options[gc, PlotRange][[1, 2, 1, 2]], 0, 0}], 
				{i, 0, 3}], Background -> Lighter@Gray, ViewPoint -> {0, -2, .1}, ##] & @@ Join[{
					BoxRatios -> {sc  4, 1, 1} Options[gc, BoxRatios][[1, 2]], 
					PlotRange -> {sc  4, 1, 1} Options[gc, PlotRange][[1, 2]], 
					Options@gc
					}], ImageSize -> {Automatic, 2400}, ImageResolution -> 300], 
			{{60, 60}, {60, 60}}, Lighter@Gray], {Automatic, 2000}]
		]&;

		(*2D image function*)
		make2DImage = With[{di = Max[ImageDimensions[#][[2]]&/@#[[2]]]/4},
		ImagePad[ImageAssemble[ImageResize[#, {Automatic, di}] & /@ Join[
			{ImageAssemble[Transpose@{ImagePad[#, -5] & /@ #[[1]]}, Spacings -> 20, Background -> White]},
			ImagePad[#, -5] & /@ #[[2]]], Spacings -> 20, Background -> White, 
			ImageResolution -> 300], 20, White
		]]&;

		addLabel = ImageAssemble[{
			{ImageCrop[#2, ImageDimensions[#2] - {0, 20}, {Left, Bottom}]}, 
			{LegendImage[#1, First[ImageDimensions@#2], #3]}}
		]&;

		(*------------ quantiatavite images ------------*)
		If[!quantIm,
			(*----*)AddToLog[{"Not making Quant images since setting is False."}, 4],
			(*----*)AddToLog[{"Start making Quant images:"}, 4]; 

			debugBids["Making quantitative map images:"];
			Table[
				(*get the color and styling function for the image*)
				cols = Rest@im;
				{cFun, ran, lab} = Switch[Length@cols,
					0, {"BlackToWhite", Automatic, None},
					1, {cols[[1]], Automatic, None},
					2, {cols[[1]], cols[[2]], None},
					3, cols];
				clip = If[cFun === "BlackToWhite", Automatic, Black];

				(*get the filenames for import and export*)
				type = First@im;				
				imFile = fileName[type]<>".nii";
				partsO["suf"] = If[hasKey, type[[2;;]], type];

				(*check if the data file exist*)				
				If[!NiiFileExistQ[imFile],
					(*----*)AddToLog[{"Cant make image for because data does not exist: ", StringRiffle[StringStrip/@type, "_"]}, 5],
					(*----*)AddToLog[{"Making image for: ", StringRiffle[type, "_"]}, 5];

					(*import data and make image and export*)
					{imDat, voxi} = ImportNii[imFile];
					img = make2DImage@MakeSliceImages[sliceData@imDat, voxi, 
							ColorFunction -> cFun, PlotRange -> ran, ClippingStyle -> clip, ImageSize -> 2400];
					img = If[lab =!= None, addLabel[cFun, img, lab], img];
					Export[fileNameO[partsO]<>".jpg", img, ImageResolution -> 300];
				]
			, {im, datDis["Images", "QuantImages"]}];
		];

		(*------------ segmentation images ------------*)

		(*check if segmentation can be done*)
		debugBids[{segfile, NiiFileExistQ[segfile]}];
		If[!NiiFileExistQ[segfile], 
			(*----*)AddToLog[{"Segmentation file does not exist."}, 4];
			segIm = False
		];

		If[!segIm,
			(*----*)AddToLog[{"Not making Segment images since setting is False."}, 4],
			(*----*)AddToLog[{"Start making segmentation images:"}, 4]; 
			debugBids["Making segment images:"];

			(*import the segmation*)
			{seg, voxi} = ImportNii[segfile];

			(*make the 2D segmentation image*)
			(*----*)AddToLog[{"Making 2D Segment image"}, 5]; 
			partsO["suf"] = If[hasKey, anaSeg[[2;;4]], anaSeg[[;;3]] ];
			Export[fileNameO[partsO]<>".jpg", 
				make2DImage@MakeSliceImages[sliceData@ref, {sliceData@seg, GetSegmentationLabels[seg]}, vox,
					ColorFunction -> {"BlackToWhite","RomaO"}, PlotRange -> Automatic, ClippingStyle -> Automatic, ImageSize -> 2400]
			, ImageResolution -> 300];

			(*make the 3D segmentation image*)
			(*----*)AddToLog[{"Making 3D Segment image"}, 5];
			partsO["suf"] = Join[partsO["suf"], {"vol"}];
			segPl = PlotSegmentations[SelectSegmentations[seg, Range[n]], SelectSegmentations[seg, Range[n+1, n+30]], 
				voxi, ContourResolution -> 2 voxi];
			Export[fileNameO[partsO]<>".jpg", make3DImage@segPl, ImageResolution -> 300];

			(*make the grid segmentation image*)
			(*----*)AddToLog[{"Making 2D Segment grid image"}, 5];
			partsO["suf"] = If[hasKey, anaSeg[[2;;4]], anaSeg[[;;3]] ];
			partsO["suf"] = Join[partsO["suf"], {"grid"}];
			{ref, crp} = AutoCropData[ref];
			{segPl, lab} = SplitSegmentations[ApplyCrop[seg, crp]];
			SeedRandom[12345];
			segPl = MergeSegmentations[segPl, Join[RandomSample[Select[lab, # <= n &]], Select[lab, # > n &]]];
			Export[fileNameO[partsO]<>".jpg", 
				MakeChannelClassGrid[{ref}, segPl,
					Which[Length[ref] > 32, {4, 8}, Length[ref] > 18, {3, 6}, Length[ref] > 8, {2, 4}, True, {1, 3}]
				]
			, ImageResolution -> 300, ImageSize->{Automatic, 2000}];
		];

		(*------------ tractography images ------------*)

		(*check if tract image can be done*)
		imTrk = datDis["Images", "TractImages"];
		trkfile = fileName[imTrk]<>".wxf";
		debugBids[{trkfile, FileExistsQ[trkfile]}];
		If[!FileExistsQ[trkfile], 
			(*----*)AddToLog[{"Tract file does not exist."}, 4];
			tractIm = False;
		];

		If[!tractIm,
			(*----*)AddToLog[{"Not making Tract images since setting is False."}, 4],
			(*----*)AddToLog[{"Start making tractography images:"}, 4]; 

			(*import the tractography, make the image and export*)
			(*----*)AddToLog[{"Making 3D tract image"}, 5];
			debugBids["Making tract images:"];
			partsO["suf"] = Join[If[hasKey, imTrk[[2;;4]], imTrk[[;;3]]], {"vol"}];
			Export[fileNameO[partsO]<>".jpg", make3DImage@Import@trkfile, ImageResolution -> 300];
		];

		(*finalize image making*)
		(*----*)AddToLog[{"Finished making the images"}, 3, True];
		MakeCheckFile[checkFileI, Sort@Join[{"Check"->"done"}, Normal@datDis]];
	]
];


(* ::Section:: *)
(*End Package*)


End[]

EndPackage[]
