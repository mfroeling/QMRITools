(* ::Package:: *)

(* ::Title:: *)
(*QMRITools ProcessingTools*)


(* ::Subtitle:: *)
(*Written by: Martijn Froeling, PhD*)
(*m.froeling@gmail.com*)


(* ::Section:: *)
(*Begin Package*)


BeginPackage["QMRITools`ProcessingTools`", Join[{"Developer`"}, Complement[QMRITools`$Contexts, {"QMRITools`ProcessingTools`"}]]];


(* ::Section:: *)
(*Usage Notes*)


(* ::Subsection:: *)
(*Functions*)


SNRCalc::usage = 
"SNRCalc[data, sigma] calculates the ANR of the data using a noise sigma map for example generated by PCADeNoise."

SNRMapCalc::usage =
"SNRMapCalc[data1, noisemap] calculates the signal to noise ratio of the data using MN[data]/(1/sqrt[pi/2] sigma), 
where sigma is the local mean of the noise map assuming it is a Rician distribution.

SNRMapCalc[{data1,data2}] calculates the signal to noise ratio from two identical images using 
MN[data1,data2] / (.5 SQRT[2] STDV[data2-data1]).

SNRMapCalc[{data1, .. dataN}] calculates the signal to noise ratio of the data using MN/sigma where the mean signal MN is the average voxel
value over all dynamics N and the sigma is the standard deviation over all dynamics N."

FitData::usage = 
"FitData[data,range] converts the data into 100 bins within the +/- range around the mean. Function is used in ParameterFit."

ParameterFit::usage = 
"ParameterFit[data] fits a (skew)Normal probability density function to the data.
ParameterFit[{data1, data2,...}] fits a (skew)Normal probability density function to each of the datasets. Is used in Hist."

ParameterFit2::usage = 
"ParameterFit2[data] fits two skewNormal probability density functions to the data. Assuming two compartments, 
one for fat and one for muscle."

DatTot::usage = 
"DatTot[{data1, data2, ..}, name, vox] calculates the parameter table containing the volume, mean, std and 95 CI for each of the diffusion parameters."

DatTotXLS::usage = 
"DatTotXLS[{data1, data2, ..}, name, vox] is the same as DatTot, but gives the parameters as strings for easy export to excel."

GetMaskMeans::usage = 
"GetMaskMeans[dat, mask] calculates the mean, std, 5,50 and 95% CI form the given data for each of the given masks. 
Mask can be generated by SegmentTracts. 

GetMaskMeans[dat, mask, name] where name is a string that is added to the header."


MeanSignal::usage = 
"MeanSignal[data] calculates the mean signal per volume of 4D data.
MeanSignal[data, pos] calculates the mean signal per volume of 4D data for the given list of positions."

GetMaskData::usage =
"GetMaskData[data, mask] returns the data selected by the mask."


GetTractMeans::usage = 
"GetTractMeans[dat, tracts, vox] calculates the mean, std, 5,50 and 95% CI form the given data for each of the given tracts. 
Tracts can be by SplitSegmentations. name is a string that is added to the header.

GetTractMeans[dat, tracts, vox, name] where name is a string that is added to the header."


JoinSets::usage =
"JoinSets[{dat1, dat2, ...}, over] joins dat1, dat2, ... with over slices overlap.
JoinSets[{dat1, dat2, ...},{over1, over2, ...}] joins dat1 and dat2 with over1 slices overlap, Joins dat2 and dat3 with over2 slices overlap and so on.
JoinSets[{dat1, dat2, ...},{{over, drop1, drop2}, ...}] joins dat1, dat2 with over slices overlap and drops drop1 slices for dat1 and drop2 from drop 2.

DOI: 10.1148/radiol.14140702."

SplitSets::usage = 
"SplitSets[data, Nsets, Nover] splits the data in Nsets with Nover slices overlap."

CorrectJoinSetMotion::usage =
"CorrectJoinSetMotion[[{dat1, dat2, ...}, vox, over] motion corrects multiple sets with overlap. Over is the number of slices overlap between stes. A Translation registration is performed."

DataTransformation::usage = 
"DataTransformation[data, vox, w] transforms a 3D dataset according to the affine transformation vector w."

InvertDataset::usage = 
"InvertDataset[data] inverts the data along the x y and z axes. In other words it is rotated aroud the origin such that (x,y,z)=(-x,-y,-z) and (0,0,0)=(0,0,0)."


Hist::usage = 
"Hist[data, range] plots a probability density histogram of the data from xmin to xmax with a fitted (skew)normal distribution. Uses ParameterFit.
Hist[data, range, label] plots a probability density histogram of the data from xmin to xmax with a fitted (skew)normal distribution and label as x-axis label.
Hist[{data1.., data2,..}, {range1, range2,..}] plots a probability density histogram of the data from xmin to xmax with a fitted (skew)normal distribution. Uses ParameterFit.
Hist[{data1, data2,..}, {range1, range2,..}, {label1, label2,..}] plots a probability density histogram of the data from xmin to xmax with a fitted (skew)normal distribution and label as x-axis label."

Hist2::usage = 
"Hist2[pars, range] plots a probability density histogram of the data over range with two fitted (skew)normal distribution. Uses ParameterFit2.
Hist2[pars, range, label] plots a probability density histogram of the data over range with two fitted (skew)normal distribution. Uses ParameterFit2."

ErrorPlot::usage = 
"ErrorPlot[data, xdata] plots a error plot of the data where the first dim of the data is the xrange which matches the xdata list. 
ErrorPlot[data, xdata, range] similar with a given y range."


NumberTableForm::usage = 
"NumberTableForm[data] makes a right aligned table of the numbers with 3 decimal precision.
NumberTableForm[data, n] makes a right aligned table of the numbers with n decimal precision.";

MeanStd::usage = 
"MeanStd[data] calculates the mean and standard deviation and reports it as a string."

MeanRange::usage = 
"MeanRange[Range] calculates the median (50%) and standard deviation (14% and 86%) range and reports it as a string."

MinMaxRange::usage =
"MinMaxRange[Range] calculates the min and max range and reports it as a string."

MeanStdRange::usage =
"MeanStdRange[Range] calculates the mean and standard deviation and the min max range and reports it as a string."


FindOutliers::usage =
"FindOutliers[data] finds the outliers of a list of data."

MedCouple::usage = 
"MedCouple[data] calculates the medcouple of a list of data."


SmartMask::usage = 
"SmartMask[input] crates a smart mask of input, which is either the tensor or the tensor parameters calculated using ParameterCalc.
SmartMask[input, mask] crates a smart mask of input and used the mask as a prior selection of the input."

B1MapCalc::usage =
"B1MapCalc[data, TR, alpha] calculates the B1 map from a dual TR {tr1, tr2} acquisition (AFI) using magnitude data with reference angle alpha.
data has dimensions {z, {tr1,tr2}, x, y}.
B1MapCalc[dataTr1, dataTr2, TR, alpha] where dataTr1 and and dataTr2 can have any dimensions.

The Output can be \"Map\", \"MagPhase\", or \"Complex\"}

B1MapCalc[] is based on DOI: 10.1002/mrm.21120."

CombineB1::usage = 
"CombineB1[b10,b190,{f1,f2,ang}] combines the complex b1 maps with relative amplitudes f1 and f2 using phase angle ang."

B1Shimming::usage = 
"B1Shimming[b10, b190, mask] finds the optimal shim values to shim to 100% b1. Assumes B1Scaling \"Relative\".
B1Shimming[b10, b190, mask, target] finds the optimal shim values to shim to target, which can be a number or a map."


RotateData::usage = 
"RotateData[data] rotates the data 180 degree, e.g. inversion of the z direction."

RotateTensor::usage = 
"RotateTensor[tens] rotates the tensor 180 degree, e.g. inversion of the z direction with also inverting the tensor orientation."


(* ::Subsection:: *)
(*Options*)


FitFunction::usage = 
"FitFunction is an option for ParameterFit. Options are \"Normal\" or \"SkewNormal\". Indicates which function wil be fitted."

FitOutput::usage = 
"FitOutput is an option for ParameterFit and ParameterFit2. Option can be \"Parameters\", \"Function\" or \"BestFitParameters\"."

OutputSNR::usage = 
"OutputSNR is an option for SNRMapCalc."

SmoothSNR::usage = 
"SmoothSNR is an option for SNRMapCalc."


MeanMethod::usage = 
"MeanMethod is an option for GetMaskMeans. The option can be \"NormalDist\", \"SkewNormalDist\", or \"Mean\"."

UseMask::usage = 
"UseMask is a function for MeanSignal and DriftCorrect."


GetMaskOutput::usage = 
"GetMaskOutput is an option for GetMaskData. Default is \"Slices\" which gives the mask data per slices. Else the entire mask data is given as output."

GetMaskOnly::usage = 
"GetMaskOnly is an option for GetMaskData. If set True all values in the mask are given, if set False only non zero values in the mask are give."

PadOutputDimensions::usage =
"PadOutputDimensions is an options for DataTransformation. If False the data is the same dimensions as the input else the data is padded."

ReverseData::usage =
"ReverseData is an option for JoinSets. Reverses each individual datset given as input for the JoinSets function. True by default."

ReverseSets::usage =
"ReverseSets is an option for JoinSets. Reverses the order of the datsets, False by default."

NormalizeSets::usage = 
"NormalizeSets is an option for JoinSets. True normalizes the individual stacks before joining."

NormalizeOverlap::usage = 
"NormalizeOverlap is an option for JoinSets. True removes strong signal dropoff at the end of a stacks."

MotionCorrectSets::usage = 
"MotionCorrectSets is an option for JoinSets. True motion corrects the individual stacks before joining using CorrectJoinSetMotion."

JoinSetSplit::usage = 
"JoinSetSplit is an option ofr CorrectJoinSetMotion. If True RegisterDataTransformSplit is used else RegisterDataTransform is used."

PadOverlap::usage = 
"PadOverlap is an option of CorrectJoinSetMotion and JoinSets. it allows for extra motion in the z direction."


OutlierMethod::usage = 
"OutlierMethod is an option for FindOutliers. values can be \"IQR\", \"SIQR\" or \"aIQR\". \"IRQ\" is used for normally distributed data, \"SIQR\" or \"aIQR\" are better for skewed distributions."

OutlierOutput::usage = 
"OutlierOutput is an option for FindOutliers. If value is \"Mask\" it gives a list of 1 for data and 0 for outliers. Else the output is {data, outliers}."

OutlierIterations::usage = 
"OutlierIterations is an option for FindOutliers. Specifies how many iterations are used to find the outliers. 
Each iteration the outliers are reevaluated on the data with the previously found outliers already rejected."

OutlierRange::usage = 
"OutlierRange is an option for FindOutliers. Specifies how many times the IQR is considered an outlier."

OutlierIncludeZero::usage = 
"OutlierIncludeZero is an option for FindOutliers. If set to True all values that are zero are ignored and considered outliers."

OutlierCheckNormality::usage = 
"OutlierCheckNormality is an option for FindOutliers. If set to True the data is checked for normality using the DistributionFitTest function. 
If the data is not normal the data is log transformed before outlier detection."


ColorValue::usage = 
"ColorValue is an option for Hist and ErrorPlot. Default {Black, Red}."

Scaling::usage = 
"Scaling is an option for Hist2. Scales the individual fits of the fat and muscle compartment."


Strictness::usage = 
"Strictness is an option for SmartMask value between 0 and 1. higher values removes more data."

MaskCompartment::usage = 
"MaskCompartment is an option for SmartMask. Can be \"Muscle\" or \"Fat\"."

SmartMethod::usage = 
"SmartMethod is an option for SmartMask. This specifies how the mask is generated. Can be \"Continuous\" or \"Catagorical\"."

SmartMaskOutput::usage = 
"SmartMaskOutput is an option for Smartmask. Can be set to \"mask\" to output only the mask or \"full\" to also output the probability mask."


TableMethod::usage = 
"TableMethod is an option for NumberTableForm. It specifies which number form to uses. Values can be NumberForm, ScientificForm or EngineeringForm."


B1Output::usage=
"B1Output is an option for B1MapCalc. Values can be \"Map\", \"MagPhase\", or \"Complex\"."

B1Masking::usage=
"B1Masking is an option for B1MapCalc. If True then values where S2 is larger than S1 are masked."

B1FilterData::usage=
"B1FilterData is an option for B1MapCalc. If True HammingFilterData is applied to the data before B1 calculation."

ReferenceB1::usage = 
"ReferenceB1 is an option for B1MapCalc. Default value is None. Can be given a numeric value in uT."

B1Scaling::usage = 
"B1Scaling is an option for B1Shimming and CombineB1. Values can be \"Relative\" or \"Absolute\". \"Absolute\" assumes b1 maps are
given in uT, \"Relative\" assumes that maps are in %."

B1ShimMethod::usage = 
"B1ShimMethod is an option for B1Shimming. Values can be \"All\", \"Phase\" or \"Magnitude\"."

B1MaxPower::usage = 
"B1MaxPower is an option for B1Shimming. Specifies how much power can be used per channel."

B1EqualPower::usage = 
"B1EqualPower is an option for B1shimming. If true equal power for both channels is used."


MonitorCalc::usage = 
"MonitorCalc is an option for many processing functions. When true the process of the calculation is shown."


(* ::Subsection:: *)
(*Error Messages*)


ParameterFit::func = "Unknown fit function: `1`. options are SkewNormal or Normal."

ParameterFit::outp = "Unknown output format: `1`. options are Parameters or Function."

GetMaskData::tresh = "The dimensions of the data and the mask must be the same, dataset: `1`, mask: `2`."

JoinSets::over = "Error: The overlap must be a number or a list which gives the overlap and how many slice must be dropped. Not: `1`."

Hist::size = "Length of data (`1`)must be the same as the length of the range (`2`) and labels (`3`)."

ErrorPlot::size = "Length of data (`1`)must be the same as the length of the range (`2`) and labels (`3`)."

Hist2::size = "Length of data (`1`), labels (`2`) and range (`3`) must be 5."


(* ::Section:: *)
(*Functions*)


Begin["`Private`"]


(* ::Subsection:: *)
(*ParameterFit*)


(* ::Subsubsection::Closed:: *)
(*ParameterFit*)


Options[ParameterFit] = {FitFunction -> "SkewNormal", FitOutput -> "Parameters", Method -> Automatic}

SyntaxInformation[ParameterFit] = {"ArgumentsPattern" -> {_, OptionsPattern[]}};

ParameterFit[dat : {_?ListQ ..}, opts : OptionsPattern[]] := ParameterFit[Flatten[#], opts] & /@ dat

ParameterFit[dat_List, OptionsPattern[]] := Module[{
		noFit, mod, out, met, data, nodat, mdat, sdat, fdat, sol ,par, fun
	},

	(*get option values*)
	mod = OptionValue[FitFunction];
	out = OptionValue[FitOutput];
	met = OptionValue[Method];

	(*prepare data*)
	data = Pick[dat, Unitize[dat], 1];
	nodat = Length[data] <= 10;

	Off[NonlinearModelFit::"cvmit"]; Off[NonlinearModelFit::"sszero"];
	(*perform the fit for one compartment*)
	If[nodat,
		Print["Not Enough data in the ROI"];
		,
		(*initialization for mean and std*)
		mdat = Mean[data];
		sdat = StandardDeviation[data];

		noFit = (sdat === 0.);

		If[!noFit,
			(*fit data*)
			fdat = FitData[data];

			Switch[mod,
				(*SkewNormal dist parameter fit*)
				"SkewNormal",
				sol = NonlinearModelFit[fdat, {PDF[SkewNormalDistribution[mu, sigma, alpha], x], sigma>0}, {{mu, mdat}, {sigma, sdat}, {alpha, 0}}, x, Method -> met];
				par = sol["BestFitParameters"];
				fun = SkewNormalDistribution[mu, sigma, alpha] /. par;
				,
				(*Normal dist parameter fit*)
				"Normal",
				sol = NonlinearModelFit[fdat, {PDF[NormalDistribution[mu, sigma], x], sigma>0}, {{mu, mdat}, {sigma, sdat}}, x, Method -> met];
				par = sol["BestFitParameters"];
				fun = NormalDistribution[mu, sigma] /. par;
				,
				_,
				Message[ParameterFit::func, mod]
			]
		]
	];
	On[NonlinearModelFit::"cvmit"]; On[NonlinearModelFit::"sszero"];

	(*generate Output*)
	Switch[out,
		"Parameters",
		Which[
			nodat, {0., 0.},
			noFit, {mdat, 0.},
			True, {Mean[fun], StandardDeviation[fun]}
		],
		"ParametersExtra",
		Which[
			nodat, {0., 0., 0., 0., 0.},
			noFit, {mdat, 0., mdat, 0., 0.},
			True, Flatten[{Mean[fun], StandardDeviation[fun], Quantile[fun, {.5, .05, .95}]}]
		],
		"Function",
		If[nodat||noFit, 0., sol],
		"BestFitParameters",
		If[nodat||noFit, 0., par[[All,2]]],
		_, 
		Message[ParameterFit::outp, out]
	]
]


(* ::Subsubsection::Closed:: *)
(*ParameterFit2*)


Options[ParameterFit2]={FitOutput->"BestFitParameters"}

SyntaxInformation[ParameterFit2] = {"ArgumentsPattern" -> {_, OptionsPattern[]}};

ParameterFit2[dat_List, OptionsPattern[]] := 
Module[{i,datf,init,out,sol,par,
	omega1i,omega2i,alpha1i,alpha2i,xi1i,xi2i,
	omega1,xi1,alpha1,omega2,xi2,alpha2},
	Off[NonlinearModelFit::cvmit];Off[NonlinearModelFit::eit];Off[NonlinearModelFit::sszero];

	init={
		{.2,.2,0,0,.6,2.1},
		{.2,.2,0,0,.6,1.6},
		{.2,.2,0,0,.6,1.3},
		{.2,.2,0,0,.6,1.7},
		{.2,.2,0,0,.3,.2}
		};
	datf=Cases[Cases[Flatten[#]//N,Except[0.]],Except[1.]]&/@dat;
	out=OptionValue[FitOutput];
	i=0;
	sol=MapThread[
		(
		i++;
		{omega1i,omega2i,alpha1i,alpha2i,xi1i,xi2i}=#2;
		NonlinearModelFit[
			FitData[#1,3.5],
			{f SkewNorm[x,omega1,xi1,alpha1]+(1-f)SkewNorm[x,omega2,xi2,alpha2],
			0<=f<=1,
			0<omega1,
			0<omega2,
			0<Mn[omega1,xi1,alpha1]<1,
			If[i==5,Mn[omega1,xi1,alpha1]>1.2Mn[omega2,xi2,alpha2],Mn[omega1,xi1,alpha1]<Mn[omega2,xi2,alpha2]],
			If[i==5,-2<alpha1<0,-1.5<alpha1<1.5],
			If[i==5,0<alpha2<2,-1.5<alpha2<1.5]},
			{{f,0.5},{omega1,omega1i},{omega2,omega2i},{alpha1,alpha1i},{alpha2,alpha2i},{xi1,xi1i},{xi2,xi2i}},
			x,MaxIterations->1000]
		)&,{datf,init}];

	par={Mn[omega1,xi1,alpha1],Sqrt[Var[omega1,alpha1]]}/.#["BestFitParameters"]&/@sol;

	On[NonlinearModelFit::cvmit];On[NonlinearModelFit::eit];On[NonlinearModelFit::sszero];

	Switch[
		out,
		"Parameters",
		{Mn[omega1,xi1,alpha1],Sqrt[Var[omega1,alpha1]],Mn[omega2,xi2,alpha2],Sqrt[Var[omega2,alpha2]]}/.#["BestFitParameters"]&/@sol,
		"Function",
		sol,
		"BestFitParameters",
		{f,omega1,omega2,xi1,xi2,alpha1,alpha2}/.#["BestFitParameters"]&/@sol,
		_,
		Message[ParameterFit::outp,out]
		]
	]


(* ::Subsubsection::Closed:: *)
(*FitData*)


SyntaxInformation[FitData] = {"ArgumentsPattern" -> {_, _.}};

FitData[dat_, sdr_:2] := 
Module[{m, s, min, max, range, step, xdat, data, out},
	If[dat == {} || Length[dat] == 1, {}, 
		m = Mean[dat];
		s = StandardDeviation[dat];
		min = (m - sdr s); max = (m + sdr s);
		range = max - min;
		step = range/50;
		data = BinCounts[dat, {min, max, step}];
		xdat = Range[min + 0.5 step, max - 0.5 step, step];
		out = Transpose[{xdat, data/Length[dat]/step}];
		DeleteCases[out, {_, 0.}]
	]
];


(* ::Subsubsection::Closed:: *)
(*GetMaskMeans*)


Options[GetMaskMeans] = {MeanMethod -> "SkewNormalDist"}

SyntaxInformation[GetMaskMeans] = {"ArgumentsPattern" -> {_, _, _., OptionsPattern[]}};

GetMaskMeans[dat_, mask_, opts:OptionsPattern[]] := GetMaskMeans[dat, mask, "", opts]

GetMaskMeans[dat_, mask_, lab_, OptionsPattern[]] := Block[{labels, out, fl},

	labels = If[lab==="", 
		{"Mean", "Std", "Median", "5%", "95%"}, 
		lab <> " " <> # & /@ {"Mean", "Std", "Median", "5%", "95%"}
	];

	out = If[Total[Flatten[#]]<=10,
		{0.,0.,0.,0.,0.}
		,
		fl = GetMaskData[dat, #, GetMaskOutput -> "All"];
		Switch[OptionValue[MeanMethod],
			"NormalDist",
			ParameterFit[fl, FitOutput -> "ParametersExtra", FitFunction -> "Normal"],
			"SkewNormalDist",
			ParameterFit[fl, FitOutput -> "ParametersExtra", FitFunction -> "SkewNormal"],
			"Mean",
			labels = {""};
			{Mean[fl]},
			_,
			Flatten[{Mean[fl], StandardDeviation[fl], Quantile[fl, {.5, .05, .95}]}]
		]
	]&/@ Transpose[mask];

	Prepend[out, labels]
]


(* ::Subsubsection::Closed:: *)
(*GetTractMeans*)


Options[GetTractMeans] = {MeanMethod -> "SkewNormalDist", InterpolationOrder -> 0}

SyntaxInformation[GetTractMeans] = {"ArgumentsPattern" -> {_, _, _, _., OptionsPattern[]}};

GetTractMeans[dat_, tracts_, vox_, opts : OptionsPattern[]] := GetTractMeans[dat, tracts, vox, "", opts]

GetTractMeans[dat_, tracts_, vox_, lab_, OptionsPattern[]] := Block[{labels, fl, out},
	labels = If[lab === "", 
		{"mean", "std", "Median", "5%", "95%"}, 
		lab <> " " <> # & /@ {"mean", "std", "Median", "5%", "95%"}
	];

	out = If[Length[#] <= 10,
		{0., 0., 0., 0., 0.},
		fl = GetTractValues[Flatten[#, 1], dat, vox, InterpolationOrder -> OptionValue[InterpolationOrder]];
		fl = Pick[fl, Unitize[fl], 1];
		Switch[OptionValue[MeanMethod],
			"NormalDist", ParameterFit[fl, FitOutput -> "ParametersExtra", FitFunction -> "Normal"],
			"SkewNormalDist", ParameterFit[fl, FitOutput -> "ParametersExtra", FitFunction -> "SkewNormal"],
			_, Flatten[{Mean[fl], StandardDeviation[fl], Quantile[fl, {.5, .05, .95}]}]
		]
	] & /@ tracts;

	Prepend[out, labels]
]


(* ::Subsubsection::Closed:: *)
(*RegNorm*)


RegNorm[x_,mu_,sigma_] := 1/(E^((x - mu)^2/(2*sigma^2))*(Sqrt[2*Pi]*sigma));


(* ::Subsubsection::Closed:: *)
(*SkewNorm*)


Phi[x_] := 1/(E^(x^2/2)*Sqrt[2*Pi]);
CapitalPhi[x_] := .5(1+Erf[(x)/Sqrt[2]]);
SkewNorm[x_,omega_,xi_,alpha_] := (2/omega)Phi[(x-xi)/omega]CapitalPhi[alpha (x-xi)/omega];
Delta[a_] := a/Sqrt[1+a^2];
Mn[w_,e_,a_] := e+w Delta[a] Sqrt[2/Pi];
Var[w_,a_] := w^2(1-(2Delta[a]^2/Pi));

SkewNormC=Compile[{{x, _Real},{omega, _Real},{xi, _Real},{alpha, _Real}},
Chop[(2/omega)(1/(E^(((x-xi)/omega)^2/2)*Sqrt[2*Pi]))(.5(1+Erf[((alpha (x-xi)/omega))/Sqrt[2]]))]
];


(* ::Subsection::Closed:: *)
(*GetMaskData*)


Options[GetMaskData] = Options[GetMaskDatai] = {GetMaskOutput -> "All", GetMaskOnly -> False}

SyntaxInformation[GetMaskData] = {"ArgumentsPattern" -> {_, _, OptionsPattern[]}};

GetMaskData[data_?ArrayQ, mask_, opts : OptionsPattern[]] := Block[{
		out, msk, cr, lout
	},
	Which[
		(*Apply same maks to multiple datasets with cropping*)
		ArrayDepth[data] === 4 && ArrayDepth[mask] === 3,
		{msk, cr} = AutoCropData[mask];
		GetMaskData[#, msk, opts] & /@ Transpose[ApplyCrop[data, cr]]
		,
		(*Apply multiple masks to one or multiple datasets with cropping *)
		(ArrayDepth[data] === 3 || ArrayDepth[data] === 4) && ArrayDepth[mask] === 4,
		(
			{msk, cr} = AutoCropData[#];
			GetMaskData[ApplyCrop[data, cr], msk, opts]
		) & /@ Transpose[mask]
		,
		True,
		If[(Dimensions[data] =!= Dimensions[mask]) || ArrayDepth[data] < 3,
			Return[Message[GetMaskData::dim, Dimensions[data], Dimensions[mask]]; $Failed],
			GetMaskDatai[data, mask, opts]
		]
	]
];


GetMaskData[data_?ArrayQ, mask_, n_?NumberQ, opts : OptionsPattern[]] := GetMaskData[data, mask, {n, 0.}, opts]

GetMaskData[data_?ArrayQ, mask_, {n_?NumberQ, o_?NumberQ}, opts : OptionsPattern[]] := Block[{
		p, msk, out
	},
	Which[
		ArrayDepth[mask] === 4,
		GetMaskData[data, #, {n, o}, opts] & /@ Transpose[mask],
		ArrayDepth[mask] === 3,
		{p, msk} = SegmentMask[mask, n, o];
		out = GetMaskData[data, msk, opts];
		Flatten /@ Thread[{p, out}],
		True,
		$Failed
	]
]


GetMaskDatai[data_, mask_, OptionsPattern[]] := Block[{
		out, lout, met
	},
	met = OptionValue[GetMaskOutput];
	(*select the correct method for selection of data*)
	out = Switch[
	met,
		"Slices", 
		MapThread[Pick[Chop[Flatten[N[#1]]], Unitize[Flatten[Normal@#2]], 1] &, {data, mask}, ArrayDepth[data] - 2],
		"Sparse", 
		(data mask)["ExplicitValues"],
		_,
		If[Max[mask] === 0, {}, Pick[Flatten[N[data]], Unitize[Flatten[Normal@mask]], 1]]
	];
	(*select only non zero values if mask only to false*)
	out = If[OptionValue[GetMaskOnly], out, Pick[out, Unitize[out], 1]];

	(*Check if to output means or not*)
	lout = Length[out] < 2;
	Switch[met,
		"Mean", If[lout, 0., Mean[out]],
		"MeanSTD", If[lout, {0., 0.}, {Mean[out], StandardDeviation[out]}],
		"Median", If[lout, 0., Median[out]],
		"MedianIQR", If[lout, {0., 0}, {Median[out], InterquartileRange[out]}],
		_, out
	]
]


(* ::Subsection::Closed:: *)
(*MeanSignal*)


Options[MeanSignal] = { UseMask->True }

SyntaxInformation[MeanSignal] = {"ArgumentsPattern" -> {_, _.,OptionsPattern[]}};

MeanSignal[data_, opts:OptionsPattern[]] := MeanSignal[data, "", opts];

MeanSignal[data_, posi_, OptionsPattern[]] := Block[{pos, dat, mask},
	{pos, dat} = Which[
		ListQ[posi], {posi, data[[All,posi]]},
		IntegerQ[posi], {{posi}, data[[All,posi]]},
		True, {All, data}
	];

	mask = If[OptionValue[UseMask], Mask[NormalizeMeanData[dat], MaskSmoothing->True], 0 dat[[All,1]] + 1];

	N@MeanNoZero[Flatten[#]] & /@ Transpose[MaskData[dat, mask]]
]


(* ::Subsection:: *)
(*FindOutliers*)


(* ::Subsubsection::Closed:: *)
(*FindOutliers*)


Options[FindOutliers] = {
	OutlierMethod -> "IQR", 
	OutlierOutput -> "Mask", 
	OutlierIterations -> 1, 
	OutlierRange -> 1.5, 
	OutlierIncludeZero -> True,
	OutlierCheckNormality -> False
}

SyntaxInformation[FindOutliers] = {"ArgumentsPattern" -> {_, _., OptionsPattern[]}};

FindOutliers[datai_?VectorQ, opts:OptionsPattern[]] := FindOutliers[datai, 1, opts]

FindOutliers[datai_?VectorQ, ignore_, OptionsPattern[]] := Block[{
		data, maxIt, diff, it, out, outI, outNew, q1, q2, q3, sc, iqr, dataQ, up, low, mc, met, incZero, output,
		sd, mn, mad, med, norm, dataL, min
	},

	(*make numeric*)
	data = N@datai;
	min = Min[data];

	(*get options*)
	{met, output, maxIt, sc, incZero, norm} = OptionValue[{OutlierMethod, OutlierOutput, OutlierIterations, 
		OutlierRange, OutlierIncludeZero, OutlierCheckNormality}];
	
	(*initialize*)
	diff = it = 1;
	outI = out = N@If[incZero, 0 data + 1, Unitize[data]];

	(*Log transpose data if not normal distribution*)
	norm = norm && DistributionFitTest[Pick[data, ignore out, 1.]] < 0.05;
	dataL = If[norm, Log[data + 1 - min], data];

	(*perform iterative outlier detection*)
	While[(diff != 0.) && it <= maxIt,
		(*get the data quantile and iqr*)
		dataQ = Pick[dataL, ignore out, 1.];

		{q1, q2, q3} = Quantile[dataQ, {.25, .50, .75}];
		iqr = (q3 - q1);

		(*switch methods: 10.1016/j.csda.2007.11.008*)
		(*IQR-inter quantile range, SIQR-skewed iql, aIQR-adjusted iqr using medcouple for skewness*)
		{low, up} = Switch[OptionValue[OutlierMethod], 
			"SD",
			sd = StandardDeviation[dataQ];
			mn = Mean[dataQ];
			{mn - sc sd, mn + sc sd},
			"MAD",
			mad = 1.4826 MedianDeviation[dataQ];
			med = Median[dataQ];
			{med - sc mad, med + sc mad},
			"IQR", 
			{q1, q3} = Quantile[dataQ, {.25, .75}];
			iqr = (q3 - q1);
			{q1 - sc iqr, q3 + sc iqr},
			"sIQR"|"SIQR", 
			{q1, q2, q3} = Quantile[dataQ, {.25, 0.5, .75}];
			{q1 - sc 2 (q2 - q1), q3 + sc 2 (q3 - q2)},
			"aIQR"|"AIQR", 
			{q1, q2, q3} = Quantile[dataQ, {.25, 0.5, .75}];
			iqr = (q3 - q1);
			mc = MedCouple[dataQ, q2];
			If[mc >= 0,
				{q1 - sc iqr Exp[-4 mc], q3 + sc iqr Exp[3 mc]},
				{q1 - sc iqr Exp[-3 mc], q3 + sc iqr Exp[4 mc]}
			]
		];

		(*make the oulier mask*)
		outNew = N[outI (If[(# < low || # > up), 0, 1] & /@ N[dataL])];

		(*update ouliers and iteration*)
		diff = Total[out - outNew];
		out = outNew;
		it++
	];

	(*make the output*)
	If[output === "Mask",
		Round[out],
		{Pick[datai, out, 1.], Pick[datai, out, 0.]}
	]
]


(* ::Subsubsection::Closed:: *)
(*MedCouple*)

MedCouple[data_] := MedCouple[data, Median@Flatten@data]

MedCouple[data_, q2_] := Block[{dat, diff, larger, smaller, equal, xi, xid, xj, xjd, xk, xkd, lk},
	(*doi.org/10.1198/106186004X12632*)
	dat = Flatten[data];
	diff = dat - q2;

	larger = UnitStep[diff];
	smaller = UnitStep[-diff];
	equal = larger smaller;

	xi = Pick[dat, (1 - equal) larger, 1];
	xid = Pick[diff, (1 - equal) larger, 1];
	xj = Pick[dat, (1 - equal) smaller, 1];
	xjd = Pick[diff, (1 - equal) smaller, 1];
	xk = Pick[dat, equal, 1];
	xkd = Pick[diff, equal, 1];
	lk = Length[xk];

	Median@ToPackedArray@N@Join[
		Flatten[(xid + # & /@ xjd)/(xi - # & /@ xj)]
		,
		If[lk > 0, Join[
			Flatten[(xid + # & /@ xkd)/(xi - # & /@ xk)],
			Flatten[(xjd + # & /@ xkd)/(xj - # & /@ xk)],
			Flatten[Table[Which[
				i + j - 1 < lk, -1.,
				i + j - 1 == lk, 0.,
				i + j - 1 > lk, 1.
			], {i, lk}, {j, lk}]]
		], {}]
	]
]


(* ::Subsection:: *)
(*Number Functions*)


(* ::Subsubsection::Closed:: *)
(*NumberTableForm*)


Options[NumberTableForm] = Join[{TableMethod -> NumberForm}, Options[TableForm]];

SyntaxInformation[NumberTableForm] = {"ArgumentsPattern" -> {_, _., OptionsPattern[]}};

NumberTableForm[dat_, opts : OptionsPattern[]] := NumberTableForm[dat, 3, opts];

NumberTableForm[dat_, depth_, opts : OptionsPattern[]] := Block[{opt, met},
	met = OptionValue[TableMethod];
	met = If[MemberQ[{NumberForm, ScientificForm, EngineeringForm}, met], met, NumberForm];
	TableForm[
	Map[met[#, {20*depth, depth}] &, dat, {ArrayDepth[dat]}],
	FilterRules[{opts}, Options[TableForm]], TableAlignments -> Right]
];


(* ::Subsubsection::Closed:: *)
(*MeanStd*)


MeanStd[inp_] := MeanStd[inp, 1]
MeanStd[inp_, n_?IntegerQ] := Block[{dat = selectDat[inp]},
	toNumString[dat, n, Mean] <> " \[PlusMinus] " <> toNumString[dat, n, StandardDeviation]
]


(* ::Subsubsection::Closed:: *)
(*MeanRange*)


MeanRange[inp_] := MeanRange[inp, {.14, .86}, 1]
MeanRange[inp_, n_?IntegerQ] := MeanRange[inp, {.14, .86}, n]
MeanRange[inp_, q_?ListQ] := MeanRange[inp, q, 1]
MeanRange[inp_, q_?ListQ, n_?IntegerQ] := Block[{dat = selectDat[inp]},
	toNumString[dat, n, Median] <> " (" <> toNumString[dat, n, Quantile[#, q[[1]]] &] <> " - " <> toNumString[dat, n, Quantile[#, q[[2]]] &] <> ")"
]


MinMaxRange[inp_] := MinMaxRange[inp, 1]
MinMaxRange[inp_, n_] := Block[{dat = selectDat[inp]},
	toNumString[dat, n, Min] <> " to " <> toNumString[dat, n, Max]
]

MeanStdRange[inp_] := MeanStdRange[inp, 2]
MeanStdRange[inp_, n_] := MeanStd[inp, n] <> " (" <> MinMaxRange[inp, n] <> ")"


selectDat[dat_] := Select[N@ToExpression[Normal@dat] /. {Mean[{}] -> Nothing}, NumberQ]

toNumString[dat_] := toNumString[dat, 2, Mean]
toNumString[dat_, n_] := toNumString[dat, n, Mean]
toNumString[dat_, n_, func_] := Block[{data, num},
	data = N@ToExpression[Normal@dat];
	num = Which[NumberQ[data], data, ListQ[data], func[data], True, Nothing];
	If[num === Nothing, "-", ToString[NumberForm[If[n > 0, Round[num, 10.^-n], Round[num]], {Infinity, n}]]]
]


(* ::Subsection::Closed:: *)
(*SNRCalc*)


SyntaxInformation[SNRCalc] = {"ArgumentsPattern" -> {_, _}};

SNRCalc[data_?ArrayQ, sig_?ArrayQ] := Block[{sigma, snr},
	sigma = MedianFilter[ToPackedArray@N@Chop[sig, 10^-3], 2];
	Which[
		ArrayDepth[data] === 4 && ArrayDepth[sigma] === 3,
		snr = Map[DivideNoZero[#, sigma] &, Transpose[data]];
		Transpose[Clip[#, {0, Quantile[DeleteCases[Flatten[#], 0.], 0.995]}] & /@ snr]
		,
		ArrayDepth[data] === ArrayDepth[sigma],
		snr = DivideNoZero[data, sigma];
		Clip[snr, {0, Quantile[DeleteCases[Flatten[snr], 0.], 0.995]}]
	]
]


(* ::Subsection::Closed:: *)
(*SNRMapCalc*)


Options[SNRMapCalc] = {OutputSNR -> "SNR", SmoothSNR->2};

SyntaxInformation[SNRMapCalc] = {"ArgumentsPattern" -> {_, _., _., OptionsPattern[]}};


SNRMapCalc[data_?ArrayQ, noise_?ArrayQ, opts:OptionsPattern[]] := SNRMapCalc[data, noise, OptionValue[SmoothSNR], opts]

SNRMapCalc[data_?ArrayQ, noise_?ArrayQ, k_?NumberQ, OptionsPattern[]] := Module[{sigma, sigmac, snr, depthD, depthN},

	sigma = N[GaussianFilter[noise, 4]];
	sigmac = (sigma/Sqrt[Pi/2.]) /. 0. -> Infinity;

	depthD=ArrayDepth[data];
	depthN=ArrayDepth[noise];

	snr = If[k>=1,
		If[depthD==depthN,
			GaussianFilter[data/(sigmac), k],
			If[depthD==depthN+1&&k>=1,
				If[depthD==4,
					Transpose[GaussianFilter[#/sigmac, k]&/@Transpose[data]],
					GaussianFilter[#/sigmac, k]&/@data
				] 				
			]
		]
		,
		If[depthD==depthN,
			data/(sigmac),
			If[depthD==depthN+1&&k>=1,
				If[depthD==4,
					Transpose[(#/sigmac)&/@Transpose[data]],
					#/sigmac&/@data
				] 				
			]
		]
	];

	Switch[OptionValue[OutputSNR],
	"Sigma"|"sigma", sigma,
	"Both"|"both", {snr, sigma},
	_, snr
	]
]


SNRMapCalc[{data1_?ArrayQ, data2_?ArrayQ}, opts:OptionsPattern[]] := SNRMapCalc[{data1, data2}, 2, opts]

SNRMapCalc[{data1_?ArrayQ, data2_?ArrayQ}, k_?NumberQ, OptionsPattern[]] := Module[{noise, signal, sigma, snr},
	noise = (data1 - data2);
	signal = Mean[{data1, data2}];
	sigma = ConstantArray[StandardDeviation[Cases[Flatten[noise] // N, Except[0.]]],Dimensions[signal]];
	snr = GaussianFilter[signal/(.5 Sqrt[2] sigma), k];
	Switch[OptionValue[OutputSNR],
		"Sigma"|"sigma", sigma,
		"Both"|"both", {snr, sigma},
		_, snr
	]
]


SNRMapCalc[data : {_?ArrayQ ...}, opts:OptionsPattern[]] := SNRMapCalc[data, 2, opts]

SNRMapCalc[data : {_?ArrayQ ...}, k_?NumberQ, OptionsPattern[]] := Module[{signal, sigma, snr,div},
	signal = Mean[data];
	sigma = Chop[StandardDeviation[data]]-10^-15;
	div=N@Clip[signal / sigma, {0, Infinity}];
	div=Clip[div, {0., 100 Median[Cases[Flatten[div], Except[0.]]]}];
	snr = GaussianFilter[div, k];

	Switch[OptionValue[OutputSNR],
		"Sigma"|"sigma", sigma,
		"Both"|"both", {snr, sigma},
	_, snr
	]
]


(* ::Subsection::Closed:: *)
(*DataTot and DataTotXLS*)


SyntaxInformation[DatTot] = {"ArgumentsPattern" -> {_, _, _}};

DatTot[data_,name_,vox_] := Module[{fitdat},
fitdat=ParameterFit[DeleteCases[Flatten[#],Null]&/@data];
		With[{quant=Function[dat,{dat[[1]],dat[[2]],100dat[[2]]/dat[[1]]}]},
			Flatten[{name,vox[[1]],vox[[2]],quant[fitdat[[1]]],quant[fitdat[[2]]],quant[fitdat[[3]]],quant[fitdat[[4]]],quant[fitdat[[5]]]}]
		]
]

SyntaxInformation[DatTotXLS] = {"ArgumentsPattern" -> {_, _, _}};

DatTotXLS[data_,name_,vox_] := Module[{fitdat},
	fitdat=ParameterFit[DeleteCases[Flatten[#],Null]&/@data];
	With[{quant=Function[dat,ToString[Round[dat[[1]],.01]]<>" \[PlusMinus] "<>ToString[Round[dat[[2]],.01]]]},
		Flatten[{name,vox[[1]],vox[[2]],quant[fitdat[[1]]],quant[fitdat[[2]]],quant[fitdat[[3]]],quant[fitdat[[4]]],quant[fitdat[[5]]]}]
	]
]


(* ::Subsection:: *)
(*TransformData*)


(* ::Subsubsection::Closed:: *)
(*TransformData*)


Options[DataTransformation] = {
	InterpolationOrder -> 1, 
	PadOutputDimensions -> False
}

SyntaxInformation[DataTransformation] = {"ArgumentsPattern"->{_, _, _, _., OptionsPattern[]}};

DataTransformation[data_, vox_, wi_, opts:OptionsPattern[]] := DataTransformation[data, vox, wi, "Real32", opts]

DataTransformation[data_, vox_, wi_, type_, OptionsPattern[]] := Block[{w, func, int, dim, ran, aff, pad},

	w = Which[
		Length[wi] == 3, Join[wi, {0, 0, 0, 1, 1, 1, 0, 0, 0}], 
		Length[wi] == 12, wi, 
		True, Return[$Failed]
	];

	int = Round@OptionValue[InterpolationOrder];
	int = Which[int === 0, "Nearest", 0 < int <=9, {"Spline", int}, True, {"Spline", 1}];

	dim = Dimensions[If[ArrayDepth[data] === 4, data[[All, 1]], data]];
	ran = {-1, 1} # / 2. & /@ Reverse[vox dim];

	aff = ParametersToTransformFull[w, "Inverse"];

	pad = If[OptionValue[PadOutputDimensions]===True, All, Automatic];

	func = ImageData[ImageTransformation[Image3D[#, type], aff, Automatic,
		Resampling -> int, DataRange -> ran, PlotRange->pad,
		Padding -> 0., Background -> 0., Masking -> Full
	]]&;

	If[ArrayDepth[data] === 4, Transpose[func/@Transpose[data]], func@data]
]


(* ::Subsubsection::Closed:: *)
(*ParametersToTransformFull*)


ParametersToTransformFull[w_] := ParametersToTransformFull[w, "Normal"]

ParametersToTransformFull[w_, opt_] := Block[{
		rz, rx, ry, tz, tx, ty, sz, sx, sy, gz, gx, gy, 
		rotM, transM, skewM, scaleM, mat
	},

	(*parameters for transformation*)
	{rz, rx, ry, tz, tx, ty, sz, sx, sy, gz, gx, gy} = N@w;
	(*rotation*)
	rotM = Dot @@ MapThread[RotationTransform[#1, #2] &, {{-ry, rx, rz} Degree, N@IdentityMatrix[3]}];
	(*translation*)
	transM = TranslationTransform[{ty, -tx, -tz}];
	(*scaling*)
	scaleM = ScalingTransform[{sy, sx, sz} /. {0. -> 1}];
	(*skew*)
	skewM = AffineTransform[{{1, gy, gz}, {0, 1, gx}, {0, 0, 1}}];
	(*combine*)
	mat = Dot[transM, rotM, scaleM, skewM];

	Switch[opt,
		"Normal", mat,
		"Inverse", TransformationFunction@Inverse@First@mat
	]
]


(* ::Subsection:: *)
(*Join sets*)


(* ::Subsubsection::Closed:: *)
(*JoinSets*)


Options[JoinSets]={
	ReverseSets->False, 
	ReverseData->True, 
	NormalizeOverlap->True, 
	NormalizeSets -> True, 
	MotionCorrectSets -> False, 
	PadOverlap -> 0, 
	JoinSetSplit -> True,
	MonitorCalc -> True
};

SyntaxInformation[JoinSets] = {"ArgumentsPattern" -> {_, _, OptionsPattern[]}};

JoinSets[data: {_?ArrayQ ..}, over_, opts:OptionsPattern[]] := JoinSets[data, over, {1,1,1}, opts]

JoinSets[data: {_?ArrayQ ..}, over_, vox_, OptionsPattern[]] := Block[{
		dat, mon, overlap, motion, pad, normalize, depth, meth, target, normover, ran,
		reverseS, reverseD, split
	},

	(*get the options*)
	{motion, pad, normalize, normover, mon, reverseS, reverseD, split} = OptionValue[{MotionCorrectSets, PadOverlap, 
		NormalizeSets, NormalizeOverlap, MonitorCalc, ReverseSets, ReverseData, JoinSetSplit}];

	normover = If[normalize, normover, False];
	depth = ArrayDepth[data];
	depth = 1 + ArrayDepth@First@data;
	overlap = If[ListQ[over], First@over, over];

	(*normalize the data*)
	dat = If[normalize, 
		If[mon, PrintTemporary["Normalizing data"]]; 
		NormalizeData/@data, data];
	ran = MinMax[dat];

	(*reverse the order of the sets if needed*)
	dat = If[reverseS, Reverse[dat], dat];

	If[overlap===0,
		(*reverse the order of the slices if needed*)
		dat = N@If[reverseD, Reverse[dat, 2], dat];
		dat = Flatten[dat, 1];
		,
		If[motion, Switch[depth,
			5,
			motion = False;
			If[mon, Print["Motion correct is only for 3D volumes"]],
			4,
			If[mon, PrintTemporary["Motion correcting data"]];
			dat = CorrectJoinSetMotion[dat, vox, over, PadOverlap->pad, JoinSetSplit->split, MonitorCalc->mon];
		]];

		(*reverse the order of the slices if needed*)
		dat = N@If[reverseD, Reverse[dat, 2], dat];

		If[mon, PrintTemporary["Joining data"]];	
		overlap = overlap + 2*pad;
		dat = Switch[depth,
			5, Transpose[(JoinSetsi[dat[[All, All, #]], overlap, normover]) & /@ Range[Length[dat[[1, 1]]]]],
			4, JoinSetsi[dat, overlap, normover],
			_,$Failed
		];
	];

	(*give output*)	
	dat = ArrayPad[dat, Prepend[ConstantArray[{0, 0}, ArrayDepth[dat] - 1], {-pad, -pad}]];
	dat = ToPackedArray@N@Clip[dat, 1.1 ran, 1.1 ran];

	Return[If[reverseD, Reverse[dat], dat]]
]


JoinSetsi[data: {_?ArrayQ ..}, overlap_?IntegerQ, norm_:False] := Block[{
		sets,set1,set2,step,set1over,set2over,joined,mn1,mn2
	},

	sets=Length[data];
	step=1/(overlap+1);

	(*perform the join*)
	Table[
		If[i==1,
			set1=Drop[data[[i]],{-overlap,-1}];
			set1over=Take[data[[i]],{-overlap,-1}];
			,
			set1=Drop[joined,{-overlap,-1}];
			set1over=Take[joined,{-overlap,-1}];
			];
		set2=Drop[data[[i+1]],{1,overlap}];
		set2over=Take[data[[i+1]],{1,overlap}];

		If[norm,
			mn1 = MeanNoZero[Flatten[#]] & /@ set1over;
			mn2 = MeanNoZero[Flatten[#]] & /@ set2over;

			mn1 = DivideNoZero[mn1[[1]],mn1];
			mn2 = DivideNoZero[mn2[[-1]],mn2];

			set1over = mn1 set1over;
			set2over = mn2 set2over;
		];

		joined = Joini[{set1, set2}, {set1over, set2over}, overlap];
	,{i, 1, sets-1}];

	joined
];


JoinSetsi[data_?ArrayQ, overlap_?ListQ, OptionsPattern[]] := 
Module[{sets,set1,set2,i,step,set1over,set2over,joined,overSet,data1,data2,drop1,drop2,overl},

	sets=Length[data];

	(*perform the join*)
	Table[
		overSet=overlap[[i]];
		If[i==1,
			data1=data[[i]];,
			data1=joined;
			];
		If[Length[overSet]!=3&&!IntegerQ[overSet],
			Return[Message[JoinSets::over,overSet]];
			,
			If[IntegerQ[overSet],
				step=1/(overSet+1);
				data2=data[[i+1]];
				overl=overSet;
				,
				If[Length[overSet]==3,
					overl=overSet[[1]];
					step=1/(overl+1);
					drop1=overSet[[2]];
					drop2=overSet[[3]];
					If[drop1!=0,data1=Drop[data1,{-drop1,-1}]];
					If[drop2!=0,data2=Drop[data[[i+1]],{1,drop2}];,data2=data[[i+1]];];
					]
				]
			];
		set1=Drop[data1,{-overl,-1}];
		set1over=Take[data1,{-overl,-1}];
		set2=Drop[data2,{1,overl}];
		set2over=Take[data2,{1,overl}];

		joined=Joini[{set1,set2},{set1over,set2over},overl];
	,{i, 1, sets-1}];

	joined
];


(* ::Subsubsection::Closed:: *)
(*Joini*)


Joini[sets_, setover_, step_] := Module[{over,dato,unit,noZero,tot},
	(*define the overlapping voxels*)
	unit = Unitize[setover];
	noZero = Times @@ unit;
	tot = Total[noZero];
	(*prepare the data for listable compliled function*)
	noZero = RotateDimensionsLeft[noZero];
	dato = RotateDimensionsLeft[setover, 2];
	(*merge the overlapping data*)
	over = RotateDimensionsRight[JoinFuncC[dato, noZero, tot, step]];
	(*merge the non ovelap with the overlap*)
	Chop[Join[sets[[1]], over, sets[[2]]]]
]


JoinFuncC = Compile[{{dat, _Real, 2}, {noZero, _Integer, 1}, {tot, _Integer, 0}, {steps, _Integer, 0}}, Block[{
		ran, unit, tot1, out
	},

	out = First@dat;

	If[tot === 0,
		(*all zeros, no overlap of signals so just the sum of signals*)
		out = Total[dat];
		,
		(*overlap of signals*)
		(*define the range needed*)
		tot1 = 1./(tot + 1.);
		ran = Reverse@Range[tot1, 1. - tot1, tot1];

		(*replace with gradient*)
		If[tot === steps,
			(*full overlap*)
			out = Total[{ran, 1. - ran} dat];
			,
			(*partial overlap*)
			(*summ all signals*)
			unit = (0 dat + 1);
			(*replace the overlapping signals with a gradient*)
			unit[[All, Flatten[Position[noZero, 1]]]] = {ran, 1 - ran};
			(*sum the signals*)
			out = Total[unit dat]
		]
	];
	(*give the output*)
	out
], RuntimeAttributes -> {Listable}, RuntimeOptions -> "Speed"];


(* ::Subsubsection::Closed:: *)
(*CorrectJoinSetMotion*)


Options[CorrectJoinSetMotion] = {JoinSetSplit -> True, PadOverlap -> 2, MonitorCalc->True}

SyntaxInformation[CorrectJoinSetMotion] = {"ArgumentsPattern" -> {_, _, _, OptionsPattern[]}};

CorrectJoinSetMotion[input_, vox_, over_, OptionsPattern[]] := Module[
	{sets, mon, nmax, dim, d1, d2, maskd1, maskd2, samp, overp, pad, regFunc, depth},

	(*get the input*)
	pad = OptionValue[PadOverlap];
	mon = OptionValue[MonitorCalc];
	depth = ArrayDepth[input];

	(*data which will be joined, make all data sets 4D*)
	sets = Switch[depth,
		5, input,
		4, Transpose[{#}]&/@input
	];

	(*add z padding to allow more overlap*)
	sets = ArrayPad[#, Prepend[ConstantArray[{0, 0}, ArrayDepth[#] - 1], {pad, pad}]] & /@ sets;

	(*set needed values*)
	nmax = Length[sets];
	overp = over + 2 pad;
	dim = Dimensions[sets[[1,All,1]]];

	(*define the registration function*)
	regFunc = If[OptionValue[JoinSetSplit], RegisterDataTransformSplit, RegisterDataTransform];

	i=0;
	If[mon, PrintTemporary[Dynamic[i]]];

	(*perform the motion correction*)
	Table[
		i = n;
		(*get the seconds overlap stac*)
		d1 = sets[[n, ;; overp,1]];
		maskd1 = Dilation[#, 3] &/@ Unitize[d1];
		(*pad to allow motion*)
		d1 = PadLeft[d1, dim];
		maskd1 = PadLeft[maskd1, dim];
		(*get the seconds overlap stac*)
		d2 = sets[[n + 1, -overp ;;,1]];
		maskd2 = Dilation[#, 3] &/@ Unitize[d2];
		(*pad to allow motion*)
		d2 = PadLeft[d2, dim];
		maskd2 = PadLeft[maskd2, dim];
		maskd1 = maskd2 = Dilation[maskd1 maskd2, 5];
		(*get the number of samples for the registration*)
		samp = Round[((Total@Flatten@maskd1)+(Total@Flatten@maskd2))/10];
		(*perform the registration*)
		sets[[n + 1]] = Last@regFunc[{d1, maskd1, vox}, {d2, maskd2, vox}, {sets[[n + 1]], vox},
				MethodReg -> "translation", Iterations -> 300, NumberSamples -> samp, 
				PrintTempDirectory -> False, InterpolationOrderReg -> 1];
		sets[[n+1]] = MaskData[sets[[n+1]], Dilation[Mask[NormalizeMeanData[sets[[n+1]]], .5], 2]];
	, {n, 1, nmax - 1}];

	(*output the data, make the 3D data 3D again*)
	Switch[depth,
		5, sets,
		4, sets[[All,All,1]]
	]

]


(* ::Subsection::Closed:: *)
(*SplitSets*)


Options[SplitSets] = {ReverseSets -> False, ReverseData -> True, PadOverlap -> 0};

SyntaxInformation[SplitSets] = {"ArgumentsPattern" -> {_, _, _, OptionsPattern[]}};

SplitSets[data_, sets_, overlap_, OptionsPattern[]] := Module[{lengthSet, sels, start, end, dat, over, pad},

	dat = If[OptionValue[ReverseData], Reverse[data], data];

	pad = OptionValue[PadOverlap]; 
	dat = ArrayPad[dat, {{pad, pad}, {0,0}, {0,0}}];
	over = overlap + 2 pad;

	lengthSet = Round[(Length[dat] + (sets - 1)*over)/sets];
	sels = Table[
		start = (i lengthSet + 1) - i over;
		end = start + lengthSet - 1;
		Range[start, end]
	, {i, 0, sets - 1}];

	dat = (dat[[#]] & /@ sels);

	dat = If[OptionValue[ReverseData], Reverse[dat, 2], dat];
	dat = If[OptionValue[ReverseSets], Reverse[dat], dat];

	dat
]


(* ::Subsection::Closed:: *)
(*RotateData*)


(* ::Subsubsection::Closed:: *)
(*RotateData*)


SyntaxInformation[RotateData] = {"ArgumentsPattern" -> {_}};

RotateData[data_] := Switch[ArrayDepth[data],
	3, RotDati[data],
	4, Transpose[RotDati /@ Transpose[data]],
	5, RotDati[data]
]


RotDati[data_] := Reverse[Reverse[data, 2], 1]


(* ::Subsubsection::Closed:: *)
(*RotateTensor*)


SyntaxInformation[RotateTensor] = {"ArgumentsPattern" -> {_}};

RotateTensor[tens_] := FlipTensorOrientation[RotDati /@ tens, {1, 1, -1}, {"y", "x", "z"}]


(* ::Subsubsection::Closed:: *)
(*InvertDataset*)


InvertDataset[data_] := Module[{dep},
	dep = ArrayDepth[data];
	Switch[dep,
		4, Transpose[Inverse3Di /@ Transpose[data]],
		_, Inverse3Di[data]
	]
]


Inverse3Di[data_] := Block[{out},
	out = data;
	(out = Reverse[out, #]) & /@ {1, 2, 3};
	out
]


(* ::Subsection::Closed:: *)
(*Hist*)


labStyle=Directive[Bold,FontFamily->"Helvetica",14,Black];


Options[Hist] = {
	ColorValue -> {{Black,White}, Red, Green, Blue}, 
	Method -> "SkewNormal", 
	PlotLabel -> "", 
	AxesLabel -> "", 
	ImageSize -> 300
}

SyntaxInformation[Hist] = {"ArgumentsPattern" -> {_, _., OptionsPattern[]}};

Hist[dat_, ops : OptionsPattern[]] := Hist[dat, 0, ops]

Hist[dat_, range_, OptionsPattern[]] := Module[{sol, line, hist, x, colbar, coledge, color2, color3, color4, data, r1, r2, sdr, m, s, title, label,mn,std ,fdat},

	{{colbar,coledge}, color2, color3, color4} = OptionValue[ColorValue];

	title = OptionValue[PlotLabel];
	title = If[title === "", None, title];
	label = OptionValue[AxesLabel];
	label = If[label === "", None, label];


	fdat = Normal[N@Flatten[Chop[dat]]];
	data = Pick[fdat, Unitize[fdat], 1];

	{r1, r2} = If[range===0,
		Quantile[data, {0.01, .99}],
		If[IntegerQ[range],
			sdr = range;
			{m, s} = {Mean[data], StandardDeviation[data]};
			{(m - sdr s), (m + sdr s)},
			range
		]
	];

	Quiet@Switch[OptionValue[Method],
		"None",
		line = Graphics[{}],
		"Normal",
		sol = ParameterFit[data, FitOutput -> "Function", FitFunction -> "Normal"];
		line = Plot[sol[x], {x, r1, r2}, PlotStyle -> {Thick, color2}, PlotRange -> Full, PlotHighlighting -> None],

		"SkewNormal",
		sol = ParameterFit[data, FitOutput -> "Function", FitFunction -> "SkewNormal"];
		line = Plot[sol[x], {x, r1, r2}, PlotStyle -> {Thick, color2}, PlotRange -> Full, PlotHighlighting -> None],

		"Both",
		sol = {
			ParameterFit[data, FitOutput -> "Function", FitFunction -> "SkewNormal"], 
			ParameterFit[data, FitOutput -> "Function", FitFunction -> "Normal"]
		};
		line = Plot[{sol[[1]][x], sol[[2]][x]}, {x, r1, r2}, PlotStyle -> {Directive[Thick, color2], Directive[Thick, color3]}, PlotRange -> Full, PlotHighlighting -> None],

		"All",
		sol = {
			ParameterFit[data, FitOutput -> "Function", FitFunction -> "SkewNormal", Method->"NMinimize"], 
			ParameterFit[data, FitOutput -> "Function", FitFunction -> "Normal", Method->"NMinimize"]
		};
		mn = Mean[data];
		std = StandardDeviation[data];
		line = Plot[{sol[[1]][x], sol[[2]][x], PDF[NormalDistribution[mn, std], x]}, {x, r1, r2}, 
			PlotStyle -> {Directive[Thick, color2], Directive[Thick, color3], Directive[Thick, color4]}, PlotRange -> Full, PlotHighlighting -> None]
	];

	hist = Histogram[
		Select[data, (r1 < # < r2) &], {r1, r2, (r2 - r1)/50}, 
		"ProbabilityDensity",
		PerformanceGoal -> "Speed", PlotRange -> {{r1, r2}, All},
		PlotLabel -> title, LabelStyle -> labStyle, Axes -> False, 
		FrameStyle -> Directive[Thick, Black],
		FrameLabel -> {label, "Probability Density"}, 
		Frame -> {True, True, False, False}, 
		ChartBaseStyle -> EdgeForm[coledge], ChartStyle -> colbar];

	Show[hist, line, ImageSize -> OptionValue[ImageSize]]
]


(* ::Subsection::Closed:: *)
(*Hist2*)


Options[Hist2]={Scaling->False}

SyntaxInformation[Hist2] = {"ArgumentsPattern" -> {_, _, _, OptionsPattern[]}};

Hist2[dat_?ArrayQ,range:{{_,_}..},label:{_String..},OptionsPattern[]] := 
Module[{data,line,line1,line2,hist,x,f,omega1,omega2,xi1,xi2,alpha1,alpha2,r1,r2,sol},

	If[!(Length[range]==Length[dat]==Length[label]==5),Return[Message[Hist2::size,Length[dat],Length[range],Length[label]]]];
	data=DeleteCases[Flatten[#]//N,0.]&/@dat;
	sol=ParameterFit2[data];
	Map[
		(
		{r1,r2}=range[[#]];

		{f,omega1,omega2,xi1,xi2,alpha1,alpha2}=sol[[#]];

			line1=Plot[If[OptionValue[Scaling],(1-f),1]*SkewNorm[x,omega2,xi2,alpha2],
				{x,r1,r2},PlotStyle->{Thick,Red},PlotRange->Full];

			line2=Plot[If[OptionValue[Scaling],(f),1]*SkewNorm[x,omega1,xi1,alpha1],
				{x,r1,r2},PlotStyle->{Thick,Blue},PlotRange->Full];

			line=Plot[f SkewNorm[x,omega1,xi1,alpha1]+(1-f)SkewNorm[x,omega2,xi2,alpha2],
				{x,r1,r2},PlotStyle->{Thick,Green},PlotRange->Full];

			hist=Histogram[
				Select[data[[#]],(r1<#<r2)&],{Range[r1,r2,(r2-r1)/50]},"ProbabilityDensity",
				PerformanceGoal->"Speed",
				PlotRange->{{r1,r2},All},LabelStyle->labStyle,Axes->False,FrameStyle->Thick,
				FrameLabel->{label[[#]],"Probability Density"},Frame->{True,True,False,False},
				ChartBaseStyle->EdgeForm[White],ChartStyle->Black
				];

			Show[hist,line1,line2,line])&,Range[Length[range]]
		]
	]


Phi[x_] := 1/(E^(x^2/2)*Sqrt[2*Pi]);

CapitalPhi[x_] := .5(1+Erf[(x)/Sqrt[2]]);

Delta[a_] := a/Sqrt[1+a^2];

Mn[w_,e_,a_] := e+w Delta[a] Sqrt[2/Pi];

Var[w_,a_] := w^2(1-(2Delta[a]^2/Pi));

SkewNorm[x_,omega_,xi_,alpha_] := (2/omega)Phi[(x-xi)/omega]CapitalPhi[alpha (x-xi)/omega];


(* ::Subsection::Closed:: *)
(*ErrorPlot*)


Options[ErrorPlot] = {ColorValue -> {Black, Red}, PlotLabel -> "", AxesLabel -> "", ImageSize -> 300, Method->"median"}

SyntaxInformation[ErrorPlot] = {"ArgumentsPattern" -> {_, _, _., OptionsPattern[]}};

ErrorPlot[dat_, xdat_, ops : OptionsPattern[]] := ErrorPlot[dat, xdat, 0, ops]

ErrorPlot[dat_, xdat_, range_, OptionsPattern[]] := Block[{color1, color2, title, label, fdat, mn, sd, er1, er2, sdr, m, s, plr},
	{color1, color2} = OptionValue[ColorValue];

	title = OptionValue[PlotLabel];
	title = If[title === "", None, title];
	label = OptionValue[AxesLabel];
	label = If[label === "", None, label];

	fdat = DeleteCases[N@Flatten[#], 0.]&/@dat;

	Switch[OptionValue[Method],
		"mean",
		{mn,sd} = Transpose[{Mean[#],StandardDeviation[#]}&/@fdat];
		{er1, er2} = {mn-sd,mn+sd};
		,"median",
		{er1, mn, er2} = Transpose[Quantile[#,{.25,.5,.75}]&/@fdat];
		,"fit",
		{mn, sd} = Transpose[ParameterFit[fdat]];
		{er1, er2} = {mn - sd, mn + sd} /. 0 -> Null;
		,_,
		{er1, mn, er2} = Transpose[Quantile[#,{.25,.5,.75}]&/@fdat];
	];

	plr = If[range === 0,
		Quantile[Flatten[fdat], {0.01, .99}],
		If[IntegerQ[range],
			sdr = range;
			{m, s} = {Mean[Flatten[fdat]], StandardDeviation[Flatten[fdat]]};
			{(m - sdr s), (m + sdr s)},
			range
		]
	];

	ListPlot[Transpose[{xdat, #}] & /@ {mn, er1, er2},
		PlotRange -> {MinMax[xdat], plr},
		PlotLabel -> title, FrameLabel -> label,
		Axes -> False, Frame -> {True, True, False, False},
		FrameStyle -> Thick, 
		PlotStyle -> {{color1, Thick}, {Dashed, Thick, color2}, {Dashed, 
		Thick, color2}},
		Joined -> {True, True, True}, Filling -> {2 -> {3}}, 
		FillingStyle -> Directive[Opacity[0.2], color2], LabelStyle -> labStyle, ImageSize->OptionValue[ImageSize]
	]
]


(* ::Subsection::Closed:: *)
(*SmartMask*)


Options[SmartMask]={Strictness->0.50, MaskCompartment->"Muscle", SmartMethod->"Continuous", SmartMaskOutput->"mask"};

SyntaxInformation[SmartMask] = {"ArgumentsPattern" -> {_, _., OptionsPattern[]}};

SmartMask[input_,ops:OptionsPattern[]] := SmartMask[input, 0, ops]

SmartMask[input_,maski_,OptionsPattern[]] := Module[{
	sol,func,range,map,mask,pmask,pars
	},

	(*get the parameter from the tensor else use input parameters*)
	pars = If[Length[input]==6,
		PrintTemporary["Caculating Parameters"];
		ParameterCalc[input],
		input];

	pmask = Mask[pars[[4]] , {0.1, 4}];

	(*find the histogram solution*)
	sol=If[maski===0,
		Switch[
			OptionValue[MaskCompartment],
			"Muscle",
			ParameterFit2[pars][[All,{3,5,7}]],
			"Fat",
			ParameterFit2[pars][[All,{2,4,6}]]
			]
			,
			ParameterFit[GetMaskData[#, maski pmask]&/@pars,FitOutput->"BestFitParameters"]
		];

	
	Switch[OptionValue[SmartMethod],
		"Catagorical",
		range = (func = SkewNormalDistribution[#2[[1]], #2[[2]], #2[[3]]]; Quantile[func, {.02, .98}]) & /@ sol;
		range = Clip[range, {0, Infinity}, {10^-3, 0.}];
		map = Total[MapThread[Mask[#1,#2]&,{pars,range}]]/5;
		mask = pmask * Mask[TotalVariationFilter[map,.15],{OptionValue[Strictness]}];
		,
		"Continuous",
		map = MapThread[PDF[SkewNormalDistribution[#2[[1]], #2[[2]], #2[[3]]], #1] &, {pars, sol}];
		map = Total[{1, 1, 1, 1, 2}*(#/Max[#] & /@ map)]/6;
		mask = pmask * Mask[TotalVariationFilter[map, .25], {OptionValue[Strictness]}];
		];

		If[OptionValue[SmartMaskOutput]==="mask",mask,{mask,map}]
	]


(* ::Subsection::Closed:: *)
(*B1MapCalc*)


Options[B1MapCalc] = {B1Output -> "Map", B1Masking->True, B1FilterData->True, ReferenceB1 -> None};

SyntaxInformation[B1MapCalc] = {"ArgumentsPattern" -> {_, _, _, OptionsPattern[]}};

B1MapCalc[dat_, {tr1_, tr2_}, a_, opts : OptionsPattern[]] := Block[{r, n, mask, b1, b1c, b1m, b1p, sc, data, refB1},
	refB1 = OptionValue[ReferenceB1];
	data = If[OptionValue[B1FilterData], HammingFilterData /@ dat, dat];

	(*mask out where s2<s1*)
	n = tr2/tr1;
	r = DivideNoZero @@ Abs[Reverse@data];
	mask = If[OptionValue[B1Masking], 1 - Mask[r, 1], 1];

	(*calculate the B1 map*)
	b1m = If[NumericQ[refB1], refB1, 100.] mask (Abs[ArcCos[DivideNoZero[(r n - 1), (n - r)]]]/(a Degree));
	b1p = Arg[Mean[data]];

	(*give output*)
	Switch[OptionValue[B1Output], "Map", b1m, "MagPhase", {b1m, b1p}, "Complex", b1m Exp[I b1p]]
]


(* ::Subsection::Closed:: *)
(*CombineB1*)


Options[CombineB1] = {B1Scaling -> "Relative"}

SyntaxInformation[CombineB1] = {"ArgumentsPattern" -> {_, _, _, OptionsPattern[]}};

CombineB1[b10_, b190_, {f1_?NumberQ, f2_?NumberQ, a_?NumberQ}, OptionsPattern[]] := Switch[OptionValue[B1Scaling],
	"Absolute", Total,
	"Relative", Mean
][{ f1 b10, f2 Exp[I (a Degree)] b190}]


(* ::Subsection:: *)
(*B1Shimming*)


(* ::Subsubsection::Closed:: *)
(*B1Shimming*)


Options[B1Shimming] = {B1ShimMethod -> "All", B1MaxPower -> 1.5, B1EqualPower -> False, B1Scaling -> "Relative"}

SyntaxInformation[B1Shimming] = {"ArgumentsPattern" -> {_, _, _, _., OptionsPattern[]}};

B1Shimming[c1_, c2_, mask_, opts : OptionsPattern[]] := B1Shimming[c1, c2, mask, 100, B1Scaling -> "Relative", opts]

B1Shimming[c1_, c2_, mask_, target_, OptionsPattern[]] := Block[{c1f, c2f, tarf, sol, f1, f2, f, a, fmax, cons, inp, vars, con, sc},
	(*define the constrains*)
	sc = OptionValue[B1Scaling];
	fmax = OptionValue[B1MaxPower];

	(*vectorize the data and target*)
	{c1f, c2f} = GetMaskData[#, mask, GetMaskOnly -> True] & /@ {c1, c2};
	tarf = Abs@If[NumberQ[target], target, GetMaskData[target, mask, GetMaskOnly -> True]];

	(*define minimization parameters*)
	cons = {-180 < a < 180, 0.0 < f1 < fmax, 0.0 < f2 < fmax, 0.0 < f < fmax};
	{inp, vars, con} = Switch[OptionValue[B1ShimMethod],
		"Phase", {{1, 1, a}, {a}, cons[[{1}]]},
		"Magnitude", {{ f1, f2, 0}, {f1, f2}, cons[[{2, 3}]]},
		_, {{f1, f2, a}, {f1, f2, a}, cons[[{1, 2, 3}]]}
	] /. If[OptionValue[B1EqualPower], {f1 -> f, f2 -> f}, {}];

	(*perform shimming*)
	sol = Last[NMinimize[Flatten[{B1MapErrorN[c1f, c2f, tarf, inp, sc], DeleteDuplicates[con]}], DeleteDuplicates[vars]]];
	inp /. sol /. {f -> 1, f1 -> 1., f2 -> 1., a -> 0.}
]


(* ::Subsubsection::Closed:: *)
(*B1MapErrorN*)


B1MapErrorN[c1_?VectorQ, c2_?VectorQ, target_, {f1_?NumberQ, f2_?NumberQ, a_?NumberQ}, sc_] := Block[{diff},
	diff = Abs@CombineB1[c1, c2, {f1, f2, a}, B1Scaling -> sc] - target;
	RootMeanSquare[diff] + StandardDeviation[diff]
]


(* ::Section:: *)
(*End Package*)


End[]

EndPackage[]
