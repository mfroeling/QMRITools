(* ::Package:: *)

(* ::Title:: *)
(*QMRITools LoggingTools*)


(* ::Subtitle:: *)
(*Written by: Martijn Froeling, PhD*)
(*m.froeling@gmail.com*)


(* ::Section:: *)
(*Begin Package*)


BeginPackage["QMRITools`LoggingTools`", Join[{"Developer`"}, Complement[QMRITools`$Contexts, {"QMRITools`LoggingTools`"}]]];


(* ::Section:: *)
(*Usage Notes*)


(* ::Subsection::Closed:: *)
(*Functions*)


QMRITools`$Log::usage = 
"QMRITools`$Log is the current log. Is a list of strings."

QMRITools`$LogFile::usage = 
"QMRITools`$LogFile is the current log file name."

SetLogFile::usage =
"SetLogFile[file] sets the log file name to file."

ResetLog::usage = 
"ResetLog[] resets the log to {}."

ShowLog::usage = 
"ShowLog[] shows the log in a popup window.
ShowLog[False] shows the log in the notebook."

ExportLog::usage = 
"ExportLog[file] exports the log as a plain text to file."

ImportLog::usage = 
"ImportLog[file] imports the log as a list of string from a plain text file."

AddToLog::usage = 
"AddToLog[list] add the list to the log at level 1. All elements of the list are converted to strings and joined with spaces.
AddToLog[list, level] add the list to the log at level.
AddToLog[list, True] add the list to the log at level 1 with a timestamp.
AddToLog[list, True, level] specifies both the level and the timestamp.
AddToLog[list, level, True] specifies both the level and the timestamp."


ExportDirectoryTree::usage = 
"ExportDirectoryTree[fol] make a DirectoryTree for the folder and exports it there as FileTree.txt.
ExportDirectoryTree[fol,name] make a DirectoryTree for the folder and exports it there as name .txt."

DirectoryTree::usage=
"DirectoryTree[dir] makes a directory tree from the dir."

PrintDirectoryTree::usage=
"PrintDirectoryTree[tree] prints the directory tree generated by DirectoryTree."


MakeCheckFile::usage = 
"MakeCheckFile[{fol, name, tag}, stat] makes a check json file in the fol with filename containing name and tag. Where stat is a list of rules that contain any information that needs to be put in the check file."

CheckFile::usage = 
"CheckFile[{fol, name, tag}, stat, ver] checs a checkfile for status stat and software version."


(* ::Subsection:: *)
(*Options*)


SaveLogFile::usage = "SaveLogFile is an option for AddToLog. If True the log is saved to the log file each time something is added."


(* ::Subsection::Closed:: *)
(*Error Messages*)


DirectoryTree::nofol = "The given directory does not exist."


(* ::Section:: *)
(*Functions*)


Begin["`Private`"] 


(* ::Subsection:: *)
(*Logging*)


(* ::Subsubsection::Closed:: *)
(*QMRITools`$Log*)


QMRITools`$Log = {};
QMRITools`$LogFile = "";


(* ::Subsubsection::Closed:: *)
(*ResetLog*)


SyntaxInformation[ResetLog] = {"ArgumentsPattern" -> {}};

ResetLog[] := QMRITools`$Log = {
"====================================================================",
"   ___  __  __ ____  ___   _____           _       _                ",
"  / _ \\|  \\/  |  _ \\|_ _| |_   _|__   ___ | |___  | |    ___   __ _ ",
" | | | | |\\/| | |_) || |    | |/ _ \\ / _ \\| / __| | |   / _ \\ / _` |",
" | |_| | |  | |  _ < | |    | | (_) | (_) | \\__ \\ | |__| (_) | (_| |",
"  \\__\\_\\_|  |_|_| \\_\\___|   |_|\\___/ \\___/|_|___/ |_____\\___/ \\__, |",
"                                                              |___/",
"",
"===================================================================="
};


(* ::Subsubsection::Closed:: *)
(*SetLogFile*)


SetLogFile[] := QMRITools`$LogFile = "";

SetLogFile[file_?StringQ] := QMRITools`$LogFile = file;


(* ::Subsubsection::Closed:: *)
(*ShowLog*)


SyntaxInformation[ShowLog] = {"ArgumentsPattern" -> {_.}};

ShowLog[] := ShowLog[True]

ShowLog[win_] := Block[{pane},
	pane = Dynamic@Pane[Style[StringRiffle[QMRITools`$Log, "\n"], Bold, White]];
	If[! win, pane,
		NotebookClose[logWindow];
		logWindow = CreateWindow@DialogNotebook[pane, Background ->Darker@Darker@Gray,
			WindowSize -> Automatic, WindowTitle -> "Logging window",
			WindowFrameElements -> {"CloseBox", "ZoomBox", "MinimizeBox", "ResizeArea"},
			WindowElements -> {"VerticalScrollBar", "HorizontalScrollBar"}
		];
	];
];


(* ::Subsubsection::Closed:: *)
(*ExportLog*)


SyntaxInformation[ExportLog] = {"ArgumentsPattern" -> {_, _.}};

ExportLog[]:=ExportLog[QMRITools`$LogFile]

ExportLog[tree_?BooleanQ]:=ExportLog[QMRITools`$LogFile, tree]

ExportLog[file_?StringQ]:=ExportLog[file, False]

ExportLog[file_?StringQ, tree_?BooleanQ] := (Export[file, QMRITools`$Log, "Text"];
	If[tree, Export[FileNameJoin[{DirectoryName[file],"FileTree.txt"}], DirectoryTree[DirectoryName[file]]];])


(* ::Subsubsection:: *)
(*ImportLog*)


SyntaxInformation[ImportLog] = {"ArgumentsPattern" -> {_.}};

ImportLog[]:=ImportLog[QMRITools`$LogFile]

ImportLog[file_] := If[FileExistsQ[file], 
	QMRITools`$Log = Append[
		Import[file, "Lines"],
		"===================================================================="
	], ResetLog[]];


(* ::Subsubsection::Closed:: *)
(*AddToLog*)


Options[AddToLog] = {SaveLogFile->True};

SyntaxInformation[AddToLog] = {"ArgumentsPattern" -> {_,_.,_.,OptionsPattern[]}};

AddToLog[logAdd_?ListQ, opt:OptionsPattern[]] := AddToLog[logAdd, 1, False, opt]

AddToLog[logAdd_?ListQ, date_?BooleanQ, opt:OptionsPattern[]] := AddToLog[logAdd, 1, date, opt]

AddToLog[logAdd_?ListQ, lev_?IntegerQ, opt:OptionsPattern[]] := AddToLog[logAdd, lev, False, opt]

AddToLog[logAdd_?ListQ, date_?BooleanQ, lev_?IntegerQ, opt:OptionsPattern[]] := AddToLog[logAdd, lev, date, opt]

AddToLog[logAdd_?ListQ, lev_?IntegerQ, date_?BooleanQ, OptionsPattern[]] := Block[{},
	AppendTo[QMRITools`$Log, 
		StringJoin[
			If[date, DateString[{"Day", "-", "Month", "-", "YearShort", " ","Time"}] <> " / ", "                  / "],
			If[lev == 0, "", StringJoin[ConstantArray[" ", 2 lev]] <> "- "],
			StringTrim[StringJoin[StringTrim[ToString[#]] <> " " & /@ logAdd]]
		]
	];
	If[OptionValue[SaveLogFile], ExportLog[]];
]

AddToLog[logAdd_, a___] := AddToLog[{logAdd}, a]


(* ::Subsection:: *)
(*DirectoryTree*)


(* ::Subsubsection::Closed:: *)
(*DirectoryTree*)


SyntaxInformation[DirectoryTree] = {"ArgumentsPattern" -> {_}};

DirectoryTree[dir_]:=Block[{tree,rule,prefix},
	If[!DirectoryQ[dir],Return[Message[DirectoryTree::nofol];$Failed]];

	(*get the directory tree*)
	tree = DirTree[dir];
	(*rule for acii render*)
	rule = {0->"  ",1->"\[VerticalLine] ",2->"\:2514\[HorizontalLine]",3->"\:251c\[HorizontalLine]"};
	prefix = ConstantArray[0,Depth[tree]];
	(*generate the styled tree*)
	Flatten[Reap[StyleTree[tree,{prefix,1,False},rule]][[2]]]
]


(* ::Subsubsection::Closed:: *)
(*DirTree*)


SyntaxInformation[DirTree] = {"ArgumentsPattern" -> {_}};

DirTree[dir_]:=Block[{all,dirs,files,childs},
	all = FileNames[All, dir];
	(*select dirs and files*)
	dirs = Select[all,DirectoryQ];
	files = FileNameTake/@Complement[all,dirs];
	(*if folder has dirs find childs*)
	childs = If[Length[dirs]>0,DirTree/@dirs,{}];
	(*output*)
	{FileNameTake@dir,childs,files}
]


(* ::Subsubsection::Closed:: *)
(*StyleTree*)


SyntaxInformation[StyleTree] = {"ArgumentsPattern" -> {_}};

StyleTree[tree_, {preFix_, level_, notlast_}, rule_]:=Block[{
		prefix, hasFiles, pre, notl, nfiles, fileNr, fileList
	},
	(*make prefix list editable*)
	prefix = preFix;

	(*change prefix base on if folder has files*)
	hasFiles=Unitize[Length[tree[[3]]]];
	prefix[[level+1]]=hasFiles;
	prefix[[level+2;;]]=0;

	(*style the directory with prefix*)
	pre=prefix[[;;level]];
	pre[[-1]]+=2;
	If[notlast,pre[[-1]]=3];
	If[notlast,prefix[[level]]=1];
	pre=pre/.rule;
	Sow[StringJoin[pre]<>tree[[1]]<>"/"];

	(*go into sub dirs if not empty*)
	If[tree[[2]]=!={},Table[
		notl=i=!=Length[tree[[2]]];
		StyleTree[tree[[2,i]],{prefix,level+1,notl},rule]
	, {i,1,Length[tree[[2]]]}];];

	(*style the files but not all*)
	pre=prefix[[;;level+1]];
	nfiles=Length[tree[[3]]];
	pre[[-1]]=3;
	fileNr=Range[nfiles];
	(*select first and last 3 else number string with left out*)
	fileList=If[nfiles>10, Flatten[{fileNr[[1;;3]],ToString[nfiles-6],fileNr[[-3;;]]}], fileNr];

	(*loop over selected files*)
	Table[If[StringQ[i],
		(*if string sow how many left lout*)
		Sow[StringJoin[pre/.rule]<>"..<<"<>i<>">>.."],
		(*Else sow filename*)
		If[i===nfiles,pre[[-1]]=2];
		Sow[StringJoin[pre/.rule]<>tree[[3,i]]]
	], {i,fileList}];
]


(* ::Subsubsection::Closed:: *)
(*PrintDirTree*)


SyntaxInformation[PrintDirectoryTree] = {"ArgumentsPattern" -> {_}};

PrintDirectoryTree[tree_]:=StringJoin[StringReplace[#,Thread[{"  ","\[VerticalLine] ","\:2514\[HorizontalLine]","\:251c\[HorizontalLine]"}->{"   ","|  ","\\- ","|- "}]]<>"\n"&/@tree]


(* ::Subsubsection::Closed:: *)
(*ExportDirectoryTree*)


SyntaxInformation[ExportDirectoryTree] = {"ArgumentsPattern" -> {_}};

ExportDirectoryTree[fol_]:=ExportDirectoryTree[fol, "FileTree"]

ExportDirectoryTree[fol_, name_]:=Export[FileNameJoin[{fol, ConvertExtension[name,"txt"]}], DirectoryTree[fol]]


(* ::Subsection:: *)
(*CheckFiles*)


(* ::Subsubsection::Closed:: *)
(*MakeCheckFile*)


SyntaxInformation[MakeCheckFile] = {"ArgumentsPattern" -> {{_, _, _}, _}};

MakeCheckFile[{fol_, name_, tag_}, stat_?ListQ] := MakeCheckFile[FileNameJoin[{fol, name <> "_" <> tag }], stat]

MakeCheckFile[nam_?StringQ, stat_?ListQ] := Export[
	nam <> "_check.json",
	Join[stat, {
		"ProcessingSoftware" -> "QMRITools.com",
		"Version" -> QMRITools`$InstalledVersion, 
		"Date" -> DateString[]
	}]
]


(* ::Subsubsection::Closed:: *)
(*CheckFile*)


SyntaxInformation[CheckFile] = {"ArgumentsPattern" -> {{_, _, _},_ ,_}};

CheckFile[{fol_,name_,tag_}, stat_, ver_]:=CheckFile[FileNameJoin[{fol,name<>"_"<>tag}], stat, ver]

CheckFile[nam_?StringQ, stat_, ver_]:=Block[{file, check},
	file = nam <> "_check.json";
	If[!FileExistsQ[file], False,
		check=Import[file,"RawJSON"];
		AllTrue[{check["Check"]===stat, If[ver,!CheckVersion[check["Version"]], True]},TrueQ]
	]
]


(* ::Subsubsection::Closed:: *)
(*CheckVersion*)


CheckVersion[ver_]:=AnyTrue[NestList[CheckVeri,{StringSplit[ver,"."],StringSplit[QMRITools`$InstalledVersion,"."],False},3][[All,-1]],TrueQ]
CheckVeri[{n1_,n2_,check_}]:={Drop[n1,1],Drop[n2,1],If[check,check,ToExpression[First[n1]]<ToExpression[First[n2]]]}


(* ::Section:: *)
(*End Package*)


End[]

EndPackage[]
