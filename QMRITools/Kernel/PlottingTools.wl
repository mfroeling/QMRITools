(* ::Package:: *)

(* ::Title:: *)
(*QMRITools PlottingTools*)


(* ::Subtitle:: *)
(*Written by: Martijn Froeling, PhD*)
(*m.froeling@gmail.com*)


(* ::Section:: *)
(*Begin Package*)


BeginPackage["QMRITools`PlottingTools`", Join[{"Developer`"}, Complement[QMRITools`$Contexts, {"QMRITools`PlottingTools`"}]]];


(* ::Section:: *)
(*Usage Notes*)


(* ::Subsection::Closed:: *)
(*Functions*)


PlotData::usage =
"PlotData[data] plots the data.
PlotData[data, vox] plots the data and for 3D and 4D data assumes the voxelsize vox (z,x,y).
PlotData[data1, data2] plots data1 and data2.
PlotData[data1, data2, vox] plots data1 and data2 and for 3D and 4D data assumes the voxelsize vox (z,x,y)."

PlotData3D::usage = 
"PlotData3D[data,vox] is a 3D dataviewer, data is the 3D dataset and voxsize the size of the voxels in mm (z,x,y)."

PlotDefGrid::usage =
"PlotDefGrid[data, phasemap, shiftpar] plots the dataset on the background with on top the non deformed and the deformed grid, or arrows or lines."


GetSlicePositions::usage =
"GetSlicePositions[data] finds the position of slices with the maximal signal in voxel index.
GetSlicePositions[data, vox] find the position of slices with the maximal signal in mm."

GetSliceData::usage =  
"GetSliceData[data, offsets] gets the slices from the data defined by offsets which are obtained by GetSlicePosisions.
GetSliceData[data, offsets, vox] gets the slices from the data defined by offsets which are obtained by GetSlicePosisions in mm.
The offsets can also be provided manually which is {{AX,..},{COR,..},{SAG,..}}."

MakeSliceImages::usage =  
"MakeSliceImages[imgData] generates images from the imgData which is obtained form GetSliceData.
MakeSliceImages[imgData, vox] generates images from the imgData which is obtained form GetSliceData, vox is used for the correct aspect ratio of the images.
MakeSliceImages[imgData, {labData, labels}] generates images from the imgData which is obtained form GetSliceData with an overlay of the segmentations in labData, which can also be obtained using GetSliceData on the segmentations.
labels should be the label numbers used in the original segmentation (to allow correct scaling between slices).
MakeSliceImages[imgData, {labData, labels},vox] generates images from the imgData which is obtained form GetSliceData with an overlay of the segmentations in labData, which can also be obtained using GetSliceData on the segmentations, vox is used for the correct aspect ratio of the images."


PlotContour::usage = 
"PlotContour[data, vox] creates a contour of the data."

PlotCorrection::usage = 
"PlotCorrection[w] plots deformation vectors w {w1,w2..} generated by Registration2D and Registration3D for multiple datasets or registration steps."

ListSpherePlot::usage =
"ListSpherePlot[points] plots 3D points as spheres."

GradientPlot::usage = 
"GradientPlot[bvec, bval] plots the given bvec with position of the gradients scaled according to the bval."

PlotDuty::usage = 
"PlotDuty[{grad, bval, ord}, mode] plot the gradient dutycycle."

PlotMoments::usage = 
"PlotMoments[{G(t),..}, te, t] plots the moments generated by CalculateMoments."

PlotIVIM::usage = 
"PlotIVIM[vals, data, bvals] plots the results of the IVIM fits from IVIMCalc or BayesianIVIMFit2 or Baye."

PlotSequence::usage = 
"PlotSequence[seq,var] where seq is the output from GradSeq."


ColorFAPlot::usage = 
"ColorFAPlot[tenor] create a color coded FA map from the tensor for l1, l2 and l3."


(* ::Subsection::Closed:: *)
(*Options*)


ContourColor::usage = 
"ContourColor is an option for PlotContour. It specifies the contour color and can be a single color or an array with the same dimensions as the data."

ContourOpacity::usage = 
"ContourOpacity is an option for PlotContour and specifies the opacity of the contour."

ContourColorRange::usage = 
"ContourColorRange is an option for PlotContour. If the ContourColor is an array this values gives the plot range."

ContourSize::usage = 
"ContourSize is an option for PlotContour. Default is is \"Dimensions\" and will plot the controur on the i,j,k grid. If set to \"Size\" it is plotted in world coordinates."


MakeCheckPlot::usage = 
"MakeCheckPlot is an option for GetSlicePositions and if set true gives a plot of the slices locations."

DropSlices::usage = 
"DropSlices is an option for GetSlicePositions and specifies how many slices from the beginning and and should be ignored."

PeakNumber::usage = 
"PeakNumber is an option of GetSlicePostitions and specifies how many slices per direction need to be found."

ImageLegend::usage = 
"ImageLegend is an option for MakeSliceImages, if set true a barlegend is added to the image."

ImageOrientation::usage = 
"ImageOrientation is an option for MakeSliceImages. Can be Automatic, \"Vertical\" or \"Horizontal\"."

PlotSpace::usage = 
"PlotSpace is an option for GradientPlot can be \"bspace\" or \"qspace\"."

PlotColor::usage = 
"PlotColor is an option for GradientPlot can be any color or gradient color name."

NormalizeIVIM::usage = 
"NormalizeIVIM is an option for IVIMplot. If True the signal at b=0 is 1."

SphereSize::usage = 
"SphereSize is an option for GradientPlot and ListSpherePlor. Sets the size of the spheres thar represent the gradients."

SphereColor::usage = 
"SphereColor ListSpherePlor. Default value is Automatic, If a color is given this color will be used for all spheres."

PositiveZ::usage = 
"PositiveZ is an options for GradientPlot. If True all Gradients are displayed with a positive z direction."

ContourQuality::usage = 
"ContourQuality is an option for PlotCountour. If set \"High\" it is slower but better quality."


(* ::Subsection::Closed:: *)
(*Error Messages*)


PlotData::data = "Error: Data must be a 2D, 3D or 4D numeric array."

PlotData::size = "Datasets must have the same number of slices. dataset1: `1` slices, dataset2: `2` slices. (Image dimensions may vary)."

PlotData::set = 
"Error: Not two valied datasest, posibilities:
- 2D and 2D
- 3D and 3D
- 4D and 4D
- 2D and 4D
- 2D and 4D
- 3D and 4D"

PlotData3D::data = "Data should be a 3D or 4D dataset."

PlotDefGrid::dir = "direction must be \"COL\" or \"ROW\", unknown direction: `1`."


(* ::Section:: *)
(*Functions*)


Begin["`Private`"]


(* ::Subsection:: *)
(*General Plot Functions and definitions*)


(* ::Subsubsection::Closed:: *)
(*Definitions*)


(*plot menu options*)
sizes    = {200,300,400,500,750,1000,1500,2000,2500,3000};
psizes   = {100,200,300,400,500,600,700,800,900,1000};
files    = {".pdf",".jpg",".gif",".tif",".png"};
colfuncs = {"Normal","Reverse","Symmetric","Reverse Symmetric"};
labStyle = Directive[Bold,FontFamily->"Helvetica",14,Black];
ncol     = 512;


(*3D color rules and settings*)
colors3D = {Automatic -> "Automatic", "XRay", "HighRange", 
	"LowRange","WhiteBlackOpacity", "SunsetColorsOpacity", "RainbowOpacity"};
views = Thread[2*{{0.65, -1.2, 1}, {1, 0, 0}, {-1, 0, 0}, {0, 1, 0}, {0, -1, 0}, {0, 0, 1}, {0, 0, -1}} -> {"Start", "Right", "Left", "Front", "Back", "Top", "Bottom"}];

(*default gradient color funtions*)
colorNames = {"GrayTones", "Rainbow", "DarkRainbow", "ThermometerColors", "SunsetColors", 
	"TemperatureMap", "LightTemperatureMap", "GrayYellowTones", "CherryTones", "SolarColors",
	"BlueGreenYellow", "AvocadoColors", "SouthwestColors"};

(*custom color functions and generate image of custom color*)
custColors = {
	"RedToWhite" -> (Blend[{RGBColor[1, 1, 1], RGBColor[.7, 0, 0]}, 1 - #]&),
	"BlackToWhite" -> (Blend[{RGBColor[1, 1, 1], RGBColor[0, 0, 0]}, 1 - #]&),
	"Flow" -> (Blend[{White, Blend[{Blue, Cyan}], Blue, Black, Red, Orange, White}, #]&),
	"Fire" -> (Blend[{Black, Blue, Purple, Red, Orange, Yellow, White}, #] &),
	"NIH" -> (Blend[{Black, Purple, Blue, Green, Yellow, Orange, Red, Darker@Darker@Red}, #] &),
	"Cardiac" -> (Blend[{Darker@Green, Cyan, Blue, Purple, Red, Yellow, Darker@Green}, #] &),
	"GEcol" -> (Blend[{Black, RGBColor[0, .22, .22], RGBColor[0, .45, .45], RGBColor[.4, .0, .9], RGBColor[.75, .25, .5], Orange, RGBColor[1, .7, .35],  White}, #] &)
	};

(*generate color list and functions*)
colorFunctions = Join[# -> ColorData[#] & /@ colorNames, custColors];
	
colors = Sort@Join[
	# -> Show[ColorData[#, "Image"], ImageSize -> 100] & /@ colorNames,
	#[[1]] -> CustCol[#[[2]]] & /@ custColors
];

CustCol[colf_] := Graphics[Raster[{Range[100]/100.}, {{0, 0}, {1, 1}}, ColorFunction -> colf], 
	AspectRatio -> 1/8, ContentSelectable -> False, ImageSize -> 100, PlotRange -> {{0, 1}, {0, 1}}]


(* ::Subsubsection::Closed:: *)
(*ToByte*)


ToByte = Compile[{{data, _Real, 0}, {range, _Real, 1}},(data - range[[1]])/(range[[2]] - range[[1]]), RuntimeAttributes -> {Listable}, RuntimeOptions -> "Speed"];


(* ::Subsubsection::Closed:: *)
(*Clip and lookup*)


ColSel[func_, cfunc_] := With[{
	fun = Switch[func, 
		"Normal", #1&, 
		"Reverse", 1 - #1&,
		"Symmetric", Abs[2 #1 - 1]&, 
		"Reverse Symmetric", Abs[Abs[2 #1 - 1] - 1] &
	],
	cfun = cfunc /. colorFunctions
	}, cfun[fun[#]]&
]


(*generate all the color lookup tables*)
ClearAll[ColorLookup]
ColorLookup[___] = ConstantArray[Col2List[Darker[Red]], ncol];
With[{ran = Range[0, 1., 1./(ncol - 1)]},
	Table[ColorLookup[j, i] = Col2List[ColSel[j, i][#] & /@ ran], {j, colfuncs}, {i, colorFunctions[[All, 1]]}]
];

(*color lookup function, presersing clipping and transparentcy. It converts integers to color values*)
(*returs the color function*)
LookUpTable[{lstyle_, color_}, {minclip_, maxclip_}] := With[{
		(*generate color lookup table with correct clipping colors for min and max,add opacity for Image function*)
		collist = Join[{Col2List[minclip]},(ColorLookup[lstyle, color]),{Col2List[maxclip]}]
	}, 
	Function[{x}, Which[NumberQ[x] || VectorQ[x], collist[[x]], MatrixQ[x], collist[[#]] & /@ x]]
  ]

Attributes[Col2List] = {Listable};
Col2List[RGBColor[c___]] := Round[255 PadRight[List[c], 4, 1.]]
Col2List[c_] := Col2List[RGBColor[c]]


(*converts numbers to integers for color lookup*)
ColorRound = With[{n = ncol}, Compile[{{x, _Real, 0}, {r, _Real, 1}},
	n + 2 - Ramp[n + 1 - Ramp[Round[(n - 1) ((x - r[[1]])/(r[[2]] - r[[1]]))] + 1]],
	RuntimeOptions -> "Speed", RuntimeAttributes -> {Listable}]
];


(* ::Subsubsection::Closed:: *)
(*ManPannel*)


ManPannel[name_,cont_,depl_:True]:= Module[{controls = DeleteCases[cont, Null]},
	OpenerView[{Style[name, Bold, Medium],
		Grid[If[ArrayDepth[controls] == 1, {controls}, controls],
			Alignment -> {{Right, Left}, Center}, ItemSize -> {{13, 30}}]
	},depl]
]


(* ::Subsubsection::Closed:: *)
(*Label Legend plot*)


LabLeg[im_, {fnts_,legs_}, label_, {legend_, color_, {min_,max_}}] := Block[{lab, bar},	
	(*generate label if needed*)
	lab = If[StringQ[label], Style[label, labStyle, TextAlignment -> Center, FontSize -> fnts]];
	
	(*generate legend if needed*)
	bar = If[legend,
		BarLegend[{(ColSel @@ color)[(# - min)/(max - min)] &, {min, max}}, 
			LabelStyle -> Directive[Bold, FontFamily -> "Helvetica", fnts, Black],
			LegendMarkerSize -> legs, LegendLayout -> "Column"]
    ];
    
    (*make the image grid*)
   Grid[Which[
    	StringQ[label] && legend, {{lab, ""}, {im, bar}},
    	legend, {{im, bar}},
    	StringQ[label], {{lab}, {im}},
    	True, {{im}}
    ],Spacings->{2,2}]
]


(* ::Subsubsection::Closed:: *)
(*Lengend plot*)


Labeli[im_,fnts_,label_]:=Block[{lab},
	(*generate label if needed*)
	If[StringQ[label], 
		lab = Style[label, labStyle, TextAlignment -> Center, FontSize -> fnts];
		Column[{lab,im}, Alignment->Center, Spacings->2],	
		im
	]
]
	


(* ::Subsubsection::Closed:: *)
(*LabelFunc*)


LabelFunc[label_,{x_:Null,y_:Null}]:=Block[{labout},
labout=If[x===Null&&y===Null,
	If[!StringQ[label],"",label],
	If[y===Null,
		If[label==" "||label==""||!StringQ[label],If[label==" "," ",""],label<>" - "]<>"Slice "<>ToString[x],
		If[label==" "||label==""||!StringQ[label],If[label==" "," ",""],label<>" - "]<>"Slice "<>ToString[x]<>"-"<>ToString[y]
		]
	];
	If[labout==="",None,labout]
	]


(* ::Subsubsection::Closed:: *)
(*LabelJoin*)


LabelJoin[label_]:=StringJoin[Riffle[DeleteCases[label[[{3, 1, 2}]]/. " " -> None, None], "\n"]] /. "" -> None


(* ::Subsubsection::Closed:: *)
(*PlotSize*)


PlotSize[data_, ps_, aspect_] := Block[{dsize,ratio},
	dsize = Dimensions[data]*aspect;
	ratio = N[Divide @@ dsize];
	{If[ratio>1, ps/ratio, ps], ratio}
]



(* ::Subsubsection::Closed:: *)
(*PlotSize*)


LabSize[size_,ratio_]:= { Max[12, Min[{25, Round[Max[{size, ratio size}]/15]}]], .95 ratio size }


(* ::Subsubsection::Closed:: *)
(*PlotRangeVals*)


PlotRangeVals[scale_, data_, {min_, max_}] := Block[{mindat, maxdat},
	{mindat, maxdat} = If[scale, N@Quantile[Flatten[data], {0.005, 0.995}], {min, max}];
	(*only use valid scale which is max>min*)
	If[mindat >= maxdat, {mindat, mindat + 0.001}, {mindat, maxdat}]
];


(* ::Subsubsection::Closed:: *)
(*ClipColor*)


ClipColor[{clipMin_, clipMax_}, {minCol_, maxCol_}, {lstyle_, color_}] := {
	Switch[clipMin, "Auto", ColSel[lstyle, color][0], "Custom", minCol, "Transparent", Transparent],
	Switch[clipMax, "Auto", ColSel[lstyle, color][1], "Custom", maxCol, "Transparent", Transparent]
};
   



(* ::Subsubsection::Closed:: *)
(*MakeImage*)


MakeImage[data_, color_, ccolor_, ran_] := Image[
	NumericArray[LookUpTable[color, ccolor][ColorRound[data, ran]], "UnsignedInteger8"], "Byte",
	ColorSpace -> "RGB"]



(* ::Subsubsection::Closed:: *)
(*PlotTicks*)


PlotTicks[dimy_, dimx_] := Block[{tkx, tky},
	tkx = Table[tx, {tx, 0, dimx, Which[dimx < 10, 1, dimx < 50, 5, True, Ceiling[dimx/10, 10]]}];
	tky = Table[{ty, dimy - ty}, {ty, dimy, 0, -Which[dimx < 10, 1, dimx < 50, 5, True, Ceiling[dimx/10, 10]]}];
	{{tky, tky}, {tkx, tkx}}
];



(* ::Subsubsection::Closed:: *)
(*JoinResc*)


JoinResc[data1_,data2_]:=
Module[{dim1,dim2},
	dim1=Dimensions[data1];
	dim2=Dimensions[data2];
	If[dim1==dim2,
		{data1,data2},
		If[Max[dim1]<Max[dim2],
			{RescaleImg[data1,dim2],data2},
			{data1,RescaleImg[data2,dim1]}
			]
		]
	]

RescaleImg[data_, dim_] := Block[{type},
	type = If[ArrayQ[data, _, IntegerQ], "Bit16","Real32"];
	ImageData[ImageResize[Image[data, type], Reverse[dim], Resampling -> "Gaussian"], type]
]


(* ::Subsubsection::Closed:: *)
(*DataString*)


DataString[dim_]:=ReleaseHold[{
	Hold["one image with a dimension of "<>ToString[dim[[1]]]<>"x"<>ToString[dim[[2]]]<>" voxels"],
	Hold[ToString[dim[[1]]]<>" slices with a dimensions of "<>ToString[dim[[2]]]<>"x"<>ToString[dim[[3]]]<>" voxels"],
	Hold[ToString[dim[[1]]]<>"x"<>ToString[dim[[2]]]<>" slices with a dimensions of "<>ToString[dim[[3]]]<>"x"<>ToString[dim[[4]]]<>" voxels"]
}[[Length[dim]-1]]]


(* ::Subsection:: *)
(*Export Functions*)


(* ::Subsubsection::Closed:: *)
(*MultiFileSave*)


MultiFileSave[plot_,label_,range_,type_,size_]:=
Module[{input,lab},
	input=SystemDialogInput["Directory", Directory[]];
	If[input===$Canceled,Return[Print["Export multiple files was canceled!"]]];
	
	Switch[Length[range],
		2,(* one 3D datasest *)
		Table[
			lab=ReleaseHold[label]/. None->"";
			pl=ReleaseHold[plot];
			SaveImage[pl,input<>lab<>type,FileType->type,ImageSize -> size];
			,{xs,range[[1]],range[[2]]}];,
		4,(* one 4D datasest *)
		Table[
			lab=ReleaseHold[label]/. None->"";
			pl=ReleaseHold[plot];
			SaveImage[pl,input<>lab<>type,FileType->type,ImageSize -> size];
			,{xs,range[[1]],range[[2]]},{ys,range[[3]],range[[4]]}];
		];

	Print["Multiple fiels were saved to: "<>input<>" as "<>type<>" files."];
]


(* ::Subsubsection::Closed:: *)
(*MovieSave*)


MovieSave[plot_,dur_,loop_,size_,range_]:=
Module[{input,movie},
	input=SystemDialogInput["FileSave", Directory[] <> $PathnameSeparator<>"*.gif"];
	If[input===$Canceled,Return[Print["Export movie was canceled!"]]];
	
	movie=Flatten[Switch[Length[range],
		2,(* one 3D datasest *)
		Table[Rasterize[ReleaseHold[plot],RasterSize->size],{xs,range[[1]],range[[2]]}],
		4,(* one 4D datasest *)
		Table[Rasterize[ReleaseHold[plot],RasterSize->size],{xs,range[[1]],range[[2]]},{ys,range[[3]],range[[4]]}]
		]];
	Export[input,movie,"DisplayDurations"->dur,"AnimationRepetitions"->loop,RasterSize->size, ImageResolution->150];
	Print["Movie was saved to: "<>input];
	]


(* ::Subsection:: *)
(*Plot Functions*)


(* ::Subsubsection::Closed:: *)
(*Ploti*)


Ploti[data_, ran_, label_, ps_, color_, legend_, frame_, ccolor_, aspect_] := Block[
	{size, ratio, tks, im},
	
	(*get range and sizes*)
	{size, ratio} = PlotSize[data, ps, aspect];
	tks = PlotTicks@@Dimensions[data];
	(*make the image*)
	im = MakeImage[data, color, ccolor, ran];
	(*Apply labes and styling*)
	LabLeg[
		Show[im, ImageSize -> size, AspectRatio -> ratio, Frame -> frame, FrameTicks -> tks], 
		LabSize[size,ratio], label, {legend, color, ran}]
]


(* ::Subsubsection::Closed:: *)
(*Plot2i*)


Plot2i[data_, minmax_, label_, ps_, color_, legend_, frame_, join_, ccolor_, aspect_, leg_]:=Block[
	{plot,fnts,legs},
	
	Switch[join[[1]],
		1,(*Normal side by side*)
		{fnts, legs} = Min/@Transpose[LabSize@@PlotSize[#, ps, aspect]&/@data];
		plot={
			Ploti[data[[1]], minmax[[1]], label[[1]], ps, color[[1]], legend, frame, ccolor[[1]], aspect],
			Ploti[data[[2]], minmax[[2]], label[[2]], ps, color[[2]], legend, frame, ccolor[[2]], aspect]
			};
		Labeli[Grid[{plot},Spacings->3], fnts, label[[3]]]
		,
		2(*CheckboardPlot*),
		CheckPlot[data, minmax, label, ps, color, frame, join[[2]], join[[3]], ccolor, aspect],
		3(*Opacity overlay plot*),
		OpacityPlot[data, minmax, label, ps, color, legend, frame, join[[3]], join[[4]], ccolor, aspect, leg],
		4(*Difference Plot*),
		DifferencePlot[data, minmax, label, ps, color, legend, frame, join[[3]], join[[5]], ccolor, aspect]
	]
]


(* ::Subsubsection::Closed:: *)
(*CheckPlot*)


CheckPlot[data_, ran_, label_, ps_, color_, frame_, size_, flip_, ccolor_, aspect_]:= Block[
	{a, b, pdata, pdatb, psize, ratio, ima, imb, im, check, tks},
	
	{a,b}=If[flip,{2,1},{1,2}];
	{pdata,pdatb}=JoinResc[data[[a]],data[[b]]];
	
	{psize,ratio}=PlotSize[pdata, ps,aspect];
	tks = PlotTicks@@Dimensions[pdata];
			
	ima = MakeImage[pdata, color[[a]], ccolor[[a]], ran[[a]]];
	imb = MakeImage[pdatb, color[[b]], ccolor[[b]], ran[[b]]];
	check = CheckBoard[Dimensions[pdata], size];
	
	(*make the image*)
	im = ImageCompose[ima,SetAlphaChannel[imb, check AlphaChannel[imb]]];
	(*add label and legend*)
	LabLeg[
		Show[im, ImageSize -> psize, AspectRatio -> ratio, Frame -> frame, FrameTicks -> tks], 
		LabSize[psize,ratio], LabelJoin[label], {False, color[[a]], ran[[a]]}
	]
]


(* ::Subsubsection::Closed:: *)
(*CheckBoard*)


CheckBoard[dim_, check_] := Image[Table[If[
	(OddQ[Ceiling[(i - 0.5 dim[[1]])/check]] && OddQ[Ceiling[(j - 0.5 dim[[2]])/check]]) ||
	(EvenQ[Ceiling[(i - 0.5 dim[[1]])/check]] && EvenQ[Ceiling[(j - 0.5 dim[[2]])/check]])
	, 1., 0.
], {i, 1, dim[[1]], 1}, {j, 1, dim[[2]]}]]



(* ::Subsubsection::Closed:: *)
(*OpacityPlot*)


OpacityPlot[data_, ran_, label_, ps_, color_, legend_, frame_, flip_, op_, ccolor_, aspect_, leg_]:=Block[
	{a, b, pdata, pdatb, psize, ratio, ima, imb, im, lc, lr, tks},
	
	{a,b}=If[flip,{2,1},{1,2}];
	{pdata,pdatb} = JoinResc[data[[a]],data[[b]]];
	
	{psize,ratio} = PlotSize[pdata, ps,aspect];
	tks = PlotTicks@@Dimensions[pdata];
	
	{rana, ranb} = ran;
		
	ima = MakeImage[pdata, color[[a]], ccolor[[a]], ran[[a]]];
	imb = MakeImage[pdatb, color[[b]], ccolor[[b]], ran[[b]]];
		
	(*make the image*)
	im = ImageCompose[ima,SetAlphaChannel[imb, op AlphaChannel[imb]]];
	(*add label and legend*)
	{lc,lr} = If[leg == 1, {color[[b]],ran[[b]]}, {color[[a]],ran[[a]]}];
	LabLeg[
		Show[im, ImageSize -> psize, AspectRatio -> ratio, Frame -> frame, FrameTicks -> tks], 
		LabSize[psize, ratio], LabelJoin[label], {legend, lc, lr}
	]
]


(* ::Subsubsection::Closed:: *)
(*DifferencePlot*)


DifferencePlot[data_,minmax_,label_,ps_,color_,legend_,frame_,flip_,range_,ccolor_,aspect_]:=Block[
	{pdat,a,b,min1,max1,min2,max2},
	
	{a,b} = If[flip,{2,1},{1,2}];
	{min1,max1} = minmax[[a,1;;2]];
	{min2,max2} = minmax[[b,1;;2]];
	
	pdat=(Subtract@@(JoinResc[data[[a]],data[[b]]]));
	
	(*make plot*)
	Ploti[pdat, {-1,1}range, LabelJoin[label], ps, color[[a]], legend, frame, ccolor[[a]], aspect]
]




(* ::Subsection:: *)
(*check and rewrite*)


(* ::Subsubsection::Closed:: *)
(*PlotDefi*)


PlotDefi[data_,shift_,{dim_,dir_},{min_,max_},lab_,ps_,color_,clip_,{gs_,gf_,ncol_,dcol_,lcol_,acol_},{def_,norm_,defl_,arr_,pl_}]:=
Module[{normGrid,deffGrid,pos,dcor,ncor,points,lines,arrows,head,plot},
	
	normGrid=Table[{j-0.5,-(i-dim[[2]])+0.5},{i,1,dim[[2]],gs},{j,1,dim[[3]],gs}];
	
	deffGrid=Table[
		If[dir=="ROW",{j-shift[[i,j]]-0.5,-(i-dim[[2]])+0.25},
		If[dir=="COL",{j-0.5,-(i-shift[[i,j]]-dim[[2]])+0.25}]]
		,{i,1,dim[[2]],gs},{j,1,dim[[3]],gs}];
	
	pos=Ceiling[DeleteCases[Flatten[Table[If[shift[[i,j]]==0.,{i,j},Null],{i,1,dim[[2]],gs},{j,1,dim[[3]],gs}],1],Null]/gs];
	
	dcor=Flatten[Delete[deffGrid,pos],1];
	ncor=Flatten[Delete[normGrid,pos],1];
	
	points=
	If[def&&norm,Graphics[{{PointSize[gf[[2]]],ncol,Point[ncor]},{PointSize[gf[[2]]],dcol,Point[dcor]}}],
		If[def,Graphics[{PointSize[gf[[2]]],dcol,Point[dcor]}],
			If[norm,Graphics[{PointSize[gf[[2]]],ncol,Point[ncor]}],
				Graphics[]
				]
			]
		];
	
	lines=If[defl,
		If[dir=="COL",Graphics[{Thickness[gf[[1]]],lcol,Map[BSplineCurve[#]&,deffGrid]}],
			If[dir=="ROW",Graphics[{Thickness[gf[[1]]],lcol,Map[BSplineCurve[#]&,Transpose[deffGrid]]}]]
			],
		Graphics[]
		];
	
	arrows=If[arr,
		head=Graphics[Line[{{-1/2,1/4},{0,0},{-1/2,-1/4}}]];
		Graphics[{Thickness[gf[[1]]],acol,Arrowheads[{{0.008,Automatic,head}}],Arrow[#]&/@ Transpose[{dcor,ncor}]}],
		Graphics[]
		];
	
	plot=If[pl,
		Ploti[data, {min, max}, None, ps, {1, color}, False, False, clip, {1, 1}],Graphics[]
		];
	
	Show[plot,lines,points,arrows,ImageSize->ps,PlotLabel->Style[lab,Bold,FontFamily->"Arial",FontSize->Round[ps/20]]]
	]


(* ::Subsubsection::Closed:: *)
(*MultiFileSaveDef*)


MultiFileSaveDef[data_,shift_,range_,type_,size_,settings_]:=
Module[{input,dim,dir,min,max,label,ps,color,gs,gf,ncol,dcol,lcol,acol,def,norm,defl,arr,pl,lab,exp,name},
	input=SystemDialogInput["Directory",Directory[]];
	If[input===$Canceled,Print["Export multiple files was canceled!"],	
		{dim,dir}=settings[[1]];
		{min,max}=settings[[2]];
		label=settings[[3]];
		ps=settings[[4]];
		color=settings[[5]];
		{gs,gf,ncol,dcol,lcol,acol}=settings[[6]];
		{def,norm,defl,arr,pl}=settings[[7]];
		
		Table[
			lab=If[!StringQ[label],"",label<>" - "]<>"Slice - "<>ToString[x];
			exp=PlotDefi[data[[x]],shift[[x]],{dim,dir},{min,max},lab,ps,color,{gs,gf,ncol,dcol,lcol,acol},{def,norm,defl,arr,pl}];
			name=input<>lab<>type;
			Export[name,exp,ImageSize->size];
			,{x,range[[1]],range[[2]]}
			];
		Print["Multiple fiels were saved to: "<>input<>" as "<>type<>" files."];
		]
	]


(* ::Subsubsection::Closed:: *)
(*MovieSaveDef*)


MovieSaveDef[data_,shift_,dur_,loop_,size_,range_,settings_]:=
Module[{movie,input,dim,dir,min,max,label,ps,color,gs,gf,ncol,dcol,lcol,acol,def,norm,defl,arr,pl,lab},
	input=SystemDialogInput["FileSave", Directory[] <> $PathnameSeparator <>"*.gif"];
	If[input===$Canceled,Print["Export multiple files was canceled!"],
		{dim,dir}=settings[[1]];
		{min,max}=settings[[2]];
		label=settings[[3]];
		ps=settings[[4]];
		color=settings[[5]];
		{gs,gf,ncol,dcol,lcol,acol}=settings[[6]];
		{def,norm,defl,arr,pl}=settings[[7]];
		
		movie=Flatten[Table[
			lab=If[!StringQ[label],"",label<>" - "]<>"Slice - "<>ToString[x];
			PlotDefi[data[[x]],shift[[x]],{dim,dir},{min,max},lab,ps,color,{gs,gf,ncol,dcol,lcol,acol},{def,norm,defl,arr,pl}]
			,{x,range[[1]],range[[2]]}
			]];
		
		Export[input,movie,"DisplayDurations"->dur,"AnimationRepetitions"->loop,ImageSize->size];
		Print["Movi was saved to: "<>input];
		]
	]


(* ::Subsection:: *)
(*Plot Data*)


(* ::Subsubsection::Closed:: *)
(*General*)


Options[PlotData]={PlotRange->"Auto",ColorFunction->"BlackToWhite"};

SyntaxInformation[PlotData] = {"ArgumentsPattern" -> {_, _., _., OptionsPattern[]}};


(* ::Subsubsection::Closed:: *)
(*PlotData 1 dataset*)


PlotData[dat_?ArrayQ,vox:{_?NumberQ, _?NumberQ, _?NumberQ}:{1,1,1},OptionsPattern[]]:= Module[{
	data,dim,n,control,str,exp,clipMin, clipMax,reverse,start1,end1,start2,end2,dur,loop,tab1,tab2,depth,
	x,xp,yp,min,max,minclip,maxclip,label,ps,color,lstyle,legend,fileType,size,pannel,aspect,or,rangex,rangey,frame,
	mind,maxd,plab,plot,pdata,cfs,lab,pcol,ccol, ran
	},
	
	NotebookClose[plotwindow];
	
	(*Check if data is numeric array, if not exit*)
	data = ToPackedArray[N[Normal[dat]]];
	If[!ArrayQ[data,_,RealQ],Return[Message[PlotData::data]]];
	
	(*See what kind of data: 2D,3D or 4D (n=1,2,3). If not one of those exit*)
	If[(depth = ArrayDepth[data])>4, Return[Message[PlotData::set]], n = depth-1];
		
	(*Determine data dimensions en make string displaying data dimensions*)
	dim = Dimensions[data];
	str = "Displaying "<>DataString[dim];
	
	(*Initialize slice ranges and data range*)
	rangex = dim[[1]];
	rangey = dim[[2]];

	(*Define the initial plot range*)
	{mind,maxd} = If[ListQ[OptionValue[PlotRange]] && Length[OptionValue[PlotRange]]==2, OptionValue[PlotRange], MinMax[data]];
	If[mind === maxd, maxd = mind + 0.01];
	
	pcol = If[MemberQ[colorFunctions[[All,1]],OptionValue[ColorFunction]], OptionValue[ColorFunction] , "BlackToWhite"];
	
	(*Define the tabs of the control pannel*)
	(*T1: first tabs, plotting controls*)
	tab1 = Column[{
		(*Slice selction controls, depends on data dimensions*)
		{"",
		ManPannel["Slice Selection",{
			{Dynamic["Slice (1-"<>ToString[rangex]<>")"],Control@{{x,Round[rangex/2],""},1,Dynamic[rangex],1, Appearance -> "Labeled"}},
			{"Orientation",Control@{{or,1,""},{1->"Transversal",2->"Sagital",3->"Coronal"}}},
			{"Reverse Slice Order",Control@{{reverse,False,""},{True,False}}}
		}],
		ManPannel["Slice Selection",{
			{Dynamic["Slice 1 (1-"<>ToString[rangex]<>")"],Control@{{x,Round[rangex/2],""},1,Dynamic[rangex],1, Appearance -> "Labeled"}},
			{"Slice 2 (1-"<>ToString[rangey]<>")",Control@{{yp,1,""},1,rangey,1, Appearance -> "Labeled"}},
			{"Orientation",Control@{{or,1,""},{1->"Transversal",2->"Sagital",3->"Coronal"}}},
			{"Reverse Slice Order",Control@{{reverse,False,""},{True,False}}}
			}]
		}[[n]]
		,(*Plot range controls*)
		ManPannel["Plot Range",{
			{"Auto Scaling", Control@{{cfs,False,""},{True -> "On", False -> "Off"}}},
			{"Min value",Control@{{min,mind,""},mind,max-(maxd-mind)/250,(maxd-mind)/250, Appearance -> "Labeled"}},
			{"Max value",Control@{{max,maxd,""},min+(maxd-min)/250,maxd,(maxd-mind)/250, Appearance -> "Labeled"}},
			{"Min Clipping", Row[{
	        	Control@{{clipMin,"Custom",""}, {"Auto", "Transparent", "Custom"->"Custom: "}}," ",
	        	Control@{{minclip, Black, ""},  
Button[
Dynamic[Graphics[{minclip, Rectangle[]}, ImageSize -> {20, 20}]],
new = SystemDialogInput["Color", #];
minclip = If[new === $Canceled, minclip, new]
, Background -> White, Method -> "Queued", FrameMargins -> 0, Appearance -> "Frameless"]&
						(*ColorSetter[#, ImageMargins->-5, ImageSize->{50, 50}]&*)}
	        }]},
	        {"Max Clipping", Row[{
	        	Control@{{clipMax,"Custom",""}, {"Auto", "Transparent", "Custom"->"Custom: "}}," ",
	        	Control@{{maxclip, White, "" },  
Button[
Dynamic[Graphics[{maxclip, Rectangle[]}, ImageSize -> {20, 20}]],
new = SystemDialogInput["Color", #];
maxclip = If[new === $Canceled, maxclip, new]
, Background -> White, Method -> "Queued", FrameMargins -> 0, Appearance -> "Frameless"]&
						(*ColorSetter[#, ImageMargins->-5, ImageSize->{50, 50}]&*)}
	        }]}
		}]
		,(*Plot style controls*)
		ManPannel["Plot Style",{
			{"Plot Title",Control@{{label,"",""},InputField[#,String]&}},
			{"Plot Size",Control@{{ps,400,""},psizes,ControlType->PopupMenu}},
			{"Color function",Control@{{color,pcol,""},colors,ControlType->PopupMenu}},
			{"Color style",Control@{{lstyle,"Normal",""},colfuncs}},
			{"Layout",Row@{
				"  Legend:",Control@{{legend,False,""},{True,False}},
				"  Frame:",Control@{{frame,False,""},{True,False}},
				"  Label:",Control@{{lab,True,""},{True,False}}}}
		}]
	}];
	
	(*T2: second tab, exporting controls*)
	tab2 = Column[{
		(*Export parameters controls*)
		ManPannel["Export plot",{
			{"File Type",Control@{{fileType,".jpg",""},files}},
			{"Export Size",Control@{{size,400,""},sizes,ControlType->PopupMenu}},
			{"Export",Button["Save Plot", SaveImage[Dynamic[exp], FileType->fileType, ImageSize -> size],Method->"Queued",ImageSize->150]}
		}]
		,(*Multiple image export controls, depends on data dimensions 2D-off, 3D-on 2 sliders, 4D-on 4 sliders*)
		{"",
		ManPannel["Export multiple plots as files",{
			{"Start slice",Control@{{start1,1,""},1,Dynamic[end1],1, Appearance -> "Labeled"}},
			{"End slice",Control@{{end1,Length[data],""},Dynamic[start1],Dynamic[rangex],1, Appearance -> "Labeled"}},
			{"Export Files",
				Button["Save Plots",MultiFileSave[Hold[plot[xs,ys,xs]],Hold[plab[xs,ys,True]],{start1,end1},fileType,size],
				Method->"Queued",ImageSize->150]}
		}],
		ManPannel["Export multiple plots as files",{
			{"Start slice 1",Control@{{start1,1,""},1,Dynamic[end1],1, Appearance -> "Labeled"}},
			{"End slice 1",Control@{{end1,1,""},Dynamic[start1],Dynamic[rangex],1, Appearance -> "Labeled"}},
			{"Start slice 2",Control@{{start2,1,""},1,Dynamic[end2],1, Appearance -> "Labeled"}},
			{"End slice 2",Control@{{end2,Length[data[[1]]],""},Dynamic[start2],Length[data[[1]]],1, Appearance -> "Labeled"}},
			{"Export Files",
				Button["Save Plots",MultiFileSave[Hold[plot[xs,ys,xs]],Hold[plab[xs,ys,True]],{start1,end1,start2,end2},fileType,size],
				Method->"Queued",ImageSize->150]}
			}]
		}[[n]]
		,(*Animated gif export controls, depends on data dimensions 2D-off, 3D/4D-on*)
		{"",
		ManPannel["Export multiple plots as animated gif",{
			{"Display Duration (s)",Control@{{dur,.5,""},0.1,2,0.1, Appearance -> "Labeled"}},
			{"Animation Repetitions",Control@{{loop,Infinity,""},{Infinity,1,2,3,4,5},ControlType->PopupMenu}},
			{"Export Movie",
				Button["Save Movie",MovieSave[Hold[plot[xs,ys,xs]],dur,loop,size,{start1,end1,start2,end2}[[1;;2(n-1)]]],
				Method->"Queued",ImageSize->150]}
			}]
		}[[Unitize[n-1]+1]](*outputt 0 or 1 thus showing menu or not*)
	}];
		
	(*Build the control pannel, allows for easy addition of more tabs*)
	control = {str,Delimiter,
		{{pannel,1,""},{1->"Plotting options",2->"Exporting options"}},Delimiter
		,PaneSelector[{1->tab1,2->tab2},Dynamic[pannel]]};
	
	(*Deploy plot window*)
	pan = Manipulate[
		If[!ListQ[data],Return[];];
		
		(*updata slice range for 3D and 4D plots when switching between axial and sagital*)
		rangex={dim[[1]],dim[[n]],dim[[n+1]]}[[or]];
	
		(*reverse slices if needed and constrain ranges*)
		x=If[NumericQ[x],Clip[x,{1,rangex}],1];
		xp=If[reverse,(-x+rangex)+1,x];
		yp=If[NumericQ[yp],Clip[yp,{1,rangey}],1];
		
		(*determine the aspect ration based on the voxelsize and dimensions*)
		aspect=Drop[vox,{or}];

		(*based on the data dimensions or how the data is showed determine how the data selection looks*)
		pdata={
			data&,
			{data[[#1]]&,Reverse[data[[All,#1]]]&,Reverse[data[[All,All,#1]]]&}[[or]],
			{data[[#1,#2]]&,Reverse[data[[All,#2,#1]]]&,Reverse[data[[All,#2,All,#1]]]&}[[or]]
		}[[n]];
		
		(*Make plot label*)
		plab=If[#3,
			LabelFunc[label,{{},{#1},{#1,#2}}[[n]]],
			LabelFunc[label,{}]
		]&;
		
		(*fix the plot range*)
		ran = PlotRangeVals[cfs, pdata[xp, yp], {min, max}];
		
		(*make the clipping colors*)
		ccol = ClipColor[{clipMin, clipMax}, {minclip, maxclip}, {lstyle, color}];	
	
		(*create Plot, is on hold so it can be used for exporting multiple files and movie*)
		plot = Ploti[
			pdata[#1, #2],		(*the data*)
			ran,				(*the plot range*)
			plab[#3 ,#2, lab],	(*the plot label*)
			ps,					(*the plot size*)
			{lstyle, color},	(*style (1-4),colorfunction*)
			legend,				(*show plot legend*)
			frame,				(*show the frame*)
			ccol,				(*the plot clip color*)
			aspect				(*the aspect ratio*)
		]&;
			
		(*insert data in plot and show*)
		(*Make sure that the x an y slice selection indices cant exceed the data dimensions*)
		exp=plot[xp,yp,x]
		
		,##(*Insertion of control pannel*),
		(*Manipulate function options*)
		ControlPlacement->Right,
		Initialization:>{or=1,reverse=False,legend=False},
		Deployed->False, 
		SynchronousInitialization -> False
		]&@@control;
		
		NotebookClose[plotwindow];
		plotwindow=CreateWindow[DialogNotebook[{CancelButton["Close", Clear[data];DialogReturn[]], pan}, 
			WindowSize -> All, WindowTitle -> "Plot data window"]];
	];


(* ::Subsubsection::Closed:: *)
(*PlotData 2 datasets*)


PlotData[dat1_?ArrayQ, dat2_?ArrayQ,vox:{_?NumberQ, _?NumberQ, _?NumberQ}:{1,1,1},OptionsPattern[]]:=
Module[{data1=N[dat1],data2=N[dat2],label,label1,label2,str,n,rangex,rangey,tab1,tab2,ccol,
	x,xp,yp,min1,max1,min2,max2,mind1,maxd1,mind2,maxd2,reverse,or,plabs,plab,plot,aspect,cfs1,cfs2,
	minclip1,maxclip1,minclip2,maxclip2,clipMax1,clipMin1,clipMax2,clipMin2,ps,legend,color1,color2,lstyle1,lstyle2,control,
	pannel,pdata1,pdata2,flip,overlay,checksize,opac,diffr,fileType,size,leftright,lab,mpdim,leg, ran,
	start1,end1,start2,end2,dur,loop,exp,dim1,dim2,prange,frame,adep1,adep2,maxabs,pcol,pcol1,pcol2},
	
	NotebookClose[plotwindow];
		
	(*Check if data is numeric array, if not exit*)
	data1 = ToPackedArray[N@Normal@dat1];
	data2 = ToPackedArray[N@Normal@dat2];
	If[(! ArrayQ[data1, _, RealQ]) || (! ArrayQ[data2, _, RealQ]),Return[Message[PlotData::data]]];

	(*See what kind of data: 2D,3D or 4D (n=1,2,3). If not one of those exit*)
	(*Determine data dimensions en make string displaying data dimensions*)
	adep1=ArrayDepth[data1];
	adep2=ArrayDepth[data2];
	dim1=Dimensions[data1];
	dim2=Dimensions[data2];
	
	mpdim=Max[Join[Take[dim1,-2],Take[dim2,-2]]];

	If[!(2<=adep1<=4 || 2<=adep2<=4), Return[Message[PlotData::set]]];
	If[(!(adep1==2 || adep2==2)),
		If[((adep1==3 || adep2==3) && dim1[[1]]!=dim2[[1]]) || (adep1==adep2==4 && dim1[[{1,2}]]!=dim2[[{1,2}]]),
			Return[Message[PlotData::size,dim1,dim2]]
		]
	];
	str="Displaying 2 dataset:\nLeft: "<>DataString[dim1]<>"\nRight: "<>DataString[dim2];
	n=Max[{adep1,adep2}]-1;
	leftright=1;

	(*determine the slider range for slice slection*)
	rangex=If[ArrayQ[data1,2],Length[data2],Length[data1]];
	rangey=If[ArrayQ[data1,4],Length[data1[[1]]],Length[data2[[1]]]];

	(*Rescale data between 0 and 1*)
	prange=OptionValue[PlotRange];

	{mind1,maxd1,mind2,maxd2}=If[ListQ[OptionValue[PlotRange]] && (Dimensions[prange] == {2} || Dimensions[prange] == {2,2}),
		If[Dimensions[prange]=={2},Flatten[{prange,prange}],If[Dimensions[prange]=={2,2},Flatten[prange]]],
		{Min[data1],Max[data1],Min[data2],Max[data2]}
		];
	If[mind1===maxd1,maxd1=mind1+0.01];
	If[mind2===maxd2,maxd2=mind2+0.01];

	maxabs=Max[Abs[{mind1,maxd1,mind2,maxd2}]];
	
	pcol = OptionValue[ColorFunction];
	If[Length[OptionValue[ColorFunction]]==2 && MemberQ[colorFunctions[[All,1]],pcol[[1]]] && MemberQ[colorFunctions[[All,1]],pcol[[2]]],
		{pcol1,pcol2} = OptionValue[ColorFunction],
		pcol1 = pcol2 = If[MemberQ[colorFunctions[[All,1]],pcol], pcol, "BlackToWhite"]
	];

	(*Define the different tabs of the control pannel*)
	(*first tabs, plotting controls*)
	tab1 = Column[{
		{"",
		ManPannel["Slice Selection",{
			{"Slice",Control@{{x,Round[rangex/2],""},1,Dynamic[rangex],1, Appearance -> "Labeled"}},
			{"Reverse Slice Order", Control@{{reverse, False, ""}, {True, False}}},
			{##} & @@ If[dim1 == dim2, {"Orientation",Control@{{or, 1, ""}, {1->"Transversal",2->"Sagital",3->"Coronal"}}},or=1; Null]
			}],
		ManPannel["Slice Selection",{
			{"Slice 1",Control@{{x,Round[rangex/2],""},1,Dynamic[rangex],1, Appearance -> "Labeled"}},
			{"Slice 2",Control@{{yp,1,""},1,rangey,1, Appearance -> "Labeled"}},
			{"Reverse Slice Order", Control@{{reverse, False, ""}, {True, False}}},
			{##} & @@ If[(Take[dim1, -2] == Take[dim2, -2])&&(Length[dim1]>=3)&&(Length[dim2]>=3), {"Orientation",Control@{{or, 1, ""}, 
				{1->"Transversal",2->"Sagital",3->"Coronal"}}}, or=1;Null]
			}]
			}[[n]]
		,
		ManPannel["Plot Range",{
			{"Data set",Control@{{leftright,1,""},{1->"Left",2->"Right"}}},
			{Style[Dynamic[{"Left dataset","Right dataset"}[[leftright]]],Bold],""},
			{"Auto Scaling",PaneSelector[{
				1->Control@{{cfs1,False,""},{True -> "On", False -> "Off"}},
				2->Control@{{cfs2,False,""},{True -> "On", False -> "Off"}}
			},Dynamic[leftright]]},
			{"Min value",PaneSelector[{
				1->Control@{{min1,mind1,""},mind1,max1-(maxd1-mind1)/250,(maxd1-mind1)/250, Appearance -> "Labeled"},
				2->Control@{{min2,mind2,""},mind2,max2-(maxd2-mind1)/250,(maxd2-mind1)/250, Appearance -> "Labeled"}
			},Dynamic[leftright]]},
			{"Max value",PaneSelector[{
				1->Control@{{max1,maxd1,""},(maxd1-mind1)/250+ min1,maxd1,(maxd1-mind1)/250, Appearance -> "Labeled"},
				2->Control@{{max2,maxd2,""},(maxd2-mind2)/250+ min2,maxd2,(maxd2-mind2)/250, Appearance -> "Labeled"}
			},Dynamic[leftright]]},
			
			{"Min Clipping", PaneSelector[{
				1->Row[{
					Control@{{clipMin1,"Custom",""}, {"Auto", "Transparent", "Custom"->"Custom: "}}," ",
					Control@{{minclip1, Black, ""}, 
Button[
Dynamic[Graphics[{minclip1, Rectangle[]}, ImageSize -> {20, 20}]],
new = SystemDialogInput["Color", #];
minclip1 = If[new === $Canceled, minclip1, new]
, Background -> White, Method -> "Queued", FrameMargins -> 0, Appearance -> "Frameless"]&
						(*ColorSetter[#, ImageMargins->-5, ImageSize->{50, 50}]&*)}
				}],
				2->Row[{
					Control@{{clipMin2,"Custom",""}, {"Auto", "Transparent", "Custom"->"Custom: "}}," ",
					Control@{{minclip2, Black, ""},  
Button[
Dynamic[Graphics[{minclip2, Rectangle[]}, ImageSize -> {20, 20}]],
new = SystemDialogInput["Color", #];
minclip2 = If[new === $Canceled, minclip2, new]
, Background -> White, Method -> "Queued", FrameMargins -> 0, Appearance -> "Frameless"]&
						(*ColorSetter[#, ImageMargins->-5, ImageSize->{50, 50}]&*)}
				}]
	        },Dynamic[leftright]]},
	        {"Max Clipping", PaneSelector[{
	        	1->Row[{
					Control@{{clipMax1,"Custom",""}, {"Auto", "Transparent", "Custom"->"Custom: "}}," ",
					Control@{{maxclip1, White, "" },  
Button[
Dynamic[Graphics[{maxclip1, Rectangle[]}, ImageSize -> {20, 20}]],
new = SystemDialogInput["Color", #];
maxclip1 = If[new === $Canceled, maxclip1, new]
, Background -> White, Method -> "Queued", FrameMargins -> 0, Appearance -> "Frameless"]&
						(*ColorSetter[#, ImageMargins->-5, ImageSize->{50, 50}]&*)}
				}],
				2->Row[{
					Control@{{clipMax2,"Custom",""}, {"Auto", "Transparent", "Custom"->"Custom: "}}," ",
					Control@{{maxclip2, White, "" },  
Button[
Dynamic[Graphics[{maxclip2, Rectangle[]}, ImageSize -> {20, 20}]],
new = SystemDialogInput["Color", #];
maxclip2 = If[new === $Canceled, maxclip2, new]
, Background -> White, Method -> "Queued", FrameMargins -> 0, Appearance -> "Frameless"]&
						(*ColorSetter[#, ImageMargins->-5, ImageSize->{50, 50}]&*)}
				}]
	        },Dynamic[leftright]]}
		}, False],
		ManPannel["Plot Style",{
			{"Plot Title",Control@{{label,"",""},InputField[#,String]&}},
			{"Plot Size",Control@{{ps,400,""},psizes,ControlType->PopupMenu}},
			{"Layout",Row@{
				"  Legend:",Control@{{legend,False,""},{True,False}},
				"  Frame:",Control@{{frame,False,""},{True,False}},
				"  Label:",Control@{{lab,True,""},{True,False}}}},
			{"Data set",Control@{{leftright,1,""},{1->"Left",2->"Right"}}},
			{Style[Dynamic[{"Left dataset","Right dataset"}[[leftright]]],Bold],""},
			{"PlotTitle",PaneSelector[{
				1->Control@{{label1,"",""},InputField[#,String]&},
				2->Control@{{label2,"",""},InputField[#,String]&}},Dynamic[leftright]]},
			{"Color function",PaneSelector[{
				1->Control@{{color1,pcol1,""},colors,ControlType->PopupMenu},
				2->Control@{{color2,pcol2,""},colors,ControlType->PopupMenu}},Dynamic[leftright]]},
			{"Color style",PaneSelector[{
				1->Control@{{lstyle1,"Normal",""},colfuncs},
				2->Control@{{lstyle2,"Normal",""},colfuncs}},Dynamic[leftright]]}
			},True],
		ManPannel["Overlay/Checkboard Plot Options",{
			{"Merge Plots",Control@{{overlay,1,""},{1->"None",2->"Checkboard",3->"Overlay",4->"Difference"}}},
			{"Flip",Control@{{flip,False,""},{True,False}}},
			{"Legend",Control@{{leg,1,""},{1->"First","Second"}}},
			{
				PaneSelector[{1 -> Null, 2 -> "Check Size (pix)",3 -> "Overlay Opacity", 4 -> "Difference plot range"},Dynamic[overlay]],
 				PaneSelector[{
 					1 -> Null,
 					2 -> Control@{{checksize, Ceiling[0.1*mpdim], ""}, 1, Ceiling[.5*mpdim], 1},
 					3 -> Control@{{opac, 0.4, ""}, 0, 1},
 					4 -> Control@{{diffr, .5*maxabs, ""}, Dynamic[0.00001*maxabs], Dynamic[2*maxabs] /. 0. -> 1., Dynamic[(1.5*maxabs /. 0. -> 1.)/1000]}}
 					,Dynamic[overlay]]
 			}},False]}];
	
	(*second tab, exporting controls*)
	tab2 = Column[{
		ManPannel["Export plot",{
			{"File Type",Control@{{fileType,".jpg",""},files}},
			{"Export Size",Control@{{size,400,""},sizes,ControlType->PopupMenu}},
			{"Export",Button["Save Plot",SaveImage[Dynamic[exp],FileType->fileType,ImageSize -> size],Method->"Queued",ImageSize->150]}
			}]
		,
		{"",
			ManPannel["Export multiple plots as files",{
				{"Start slice",Control@{{start1,1,""},1,Dynamic[end1],1, Appearance -> "Labeled"}},
				{"End slice",Control@{{end1,rangex,""},Dynamic[start1],rangex,1, Appearance -> "Labeled"}},
				{"Export Files",Button["Save Plots",MultiFileSave[Hold[plot[xs,ys,xs]],Hold[plab[xs,ys,True]],{start1,end1},fileType,size],
					Method->"Queued",ImageSize->150]}
				}],
			ManPannel["Export multiple plots as files",{
				{"Start slice 1",Control@{{start1,1,""},1,Dynamic[end1],1, Appearance -> "Labeled"}},
				{"End slice 1",Control@{{end1,rangex,""},Dynamic[start1],rangex,1, Appearance -> "Labeled"}},
				{"Start slice 2",Control@{{start2,1,""},1,Dynamic[end2],1, Appearance -> "Labeled"}},
				{"End slice 2",Control@{{end2,rangey,""},Dynamic[start2],rangey,1, Appearance -> "Labeled"}},
				{"Export Files",Button["Save Plots",MultiFileSave[Hold[plot[xs,ys,xs]],Hold[plab[xs,ys,True]],{start1,end1,start2,end2},fileType,size],
					Method->"Queued",ImageSize->150]}
				}]
			}[[n]],
		{"",
			ManPannel["Export multiple plots as animated gif",{
				{"Display Duration (s)",Control@{{dur,.5,""},0.1,2,0.1, Appearance -> "Labeled"}},
				{"Animation Repetitions",Control@{{loop,Infinity,""},{Infinity,1,2,3,4,5},ControlType->PopupMenu}},
				{"Export Movie",Button["Save Movie",MovieSave[Hold[plot[xs,ys,xs]],dur,loop,size,{start1,end1,start2,end2}[[1;;2(n-1)]]], Method->"Queued",ImageSize->150]}
				}]
			}[[Unitize[n-1]+1]]
		}];
		
	(*Build the control pannel, allows for easy addition of more tabs*)
	control={
		str,
		Delimiter,
		{{pannel,1,""},{1->"Plotting options",2->"Exporting options"}},
		Delimiter,
		PaneSelector[{1->tab1,2->tab2}, Dynamic[pannel]]
	};

	(*Deploy plot window*)
	pan = Manipulate[
		If[!ListQ[data1]||!ListQ[data2],Return[]];
		
		(*updata slice range for 3D and 4D plots when switching between axial and sagital*)
		If[(Take[dim1,-2] == Take[dim2,-2] && ArrayDepth[data1] >= 3 && ArrayDepth[data2] >= 3),
			rangex={dim1[[1]],Take[dim1,{-2}][[1]],Take[dim1,{-1}][[1]]}[[or]]
		];
		
		(*reverse slices if needed*)
		x=If[NumericQ[x],Clip[x,{1,rangex}],1];
		xp=If[reverse,(-x+rangex)+1,x];
		yp=If[NumericQ[yp],Clip[yp,{1,rangey}],1];
		
		(*determine the aspect ration based on the voxelsize and dimensions*)
		aspect=Drop[vox,{or}];
		
		(*based on the data dimensions or how the data is showed determine how the data selection looks*)
		pdata1={
			data1&,
			{data1[[#1]]&,Reverse[data1[[All,#1]]]&,Reverse[data1[[All,All,#1]]]&}[[or]],
			{data1[[#1,#2]]&,Reverse[data1[[All,#2,#1]]]&,Reverse[data1[[All,#2,All,#1]]]&}[[or]]
			}[[ArrayDepth[data1]-1]];		
		
		pdata2={data2&,
			{data2[[#1]]&,Reverse[data2[[All,#1]]]&,Reverse[data2[[All,All,#1]]]&}[[or]],
			{data2[[#1,#2]]&,Reverse[data2[[All,#2,#1]]]&,Reverse[data2[[All,#2,All,#1]]]&}[[or]]
			}[[ArrayDepth[data2]-1]];

		(*Make plot label*)
		plabs={{},{#1},{#1,#2}}[[#3-1]]&;
		plab=If[adep1 == adep2,
			(*if both are no label set bot to zero*)
			If[label1!=""||label2!="", {label1,label2} = {label1,label2} /. ""->" "];
			{
				If[label1==="",None,label1],
				If[label2==="",None,label2],
				If[#3,LabelFunc[label,plabs[#1,#2, adep1]],LabelFunc[label,{}]]
			}
			,
			If[label1!=""||label2!="",{label1,label2}={label1,label2} /. ""->" "];
			{
				If[#3,LabelFunc[label1,plabs[#1,#2, adep1]],LabelFunc[label1,{}]],
				If[#3,LabelFunc[label2,plabs[#1,#2, adep2]],LabelFunc[label2,{}]],
				If[label==="",None,label]
			}
			]&;
		
		(*get the plot ranges*)
		ran = {
			PlotRangeVals[cfs1, pdata1[xp, yp], {min1,max1}],
			PlotRangeVals[cfs2, pdata2[xp, yp], {min2,max2}]
		};
		
		(*get the clip colors*)
		ccol = {
			ClipColor[{clipMin1, clipMax1}, {minclip1, maxclip1}, {lstyle1, color1}],
			ClipColor[{clipMin2, clipMax2}, {minclip2, maxclip2}, {lstyle2, color2}]
		};
		
		plot = Plot2i[
			{pdata1[#1,#2],pdata2[#1,#2]},			(*the data*)
			ran,									(*the plot range*)
			plab[#3,#2,lab],						(*the plot label*)
			ps,										(*the plot size*)
			{{lstyle1,color1},{lstyle2,color2}},	(*style (1-4),colorfunction*)
			legend,									(*show plot legend*)
			frame,									(*show the frame*)
			{overlay,checksize,flip,opac,diffr},	(*the overlay options*)
			ccol,									(*the plot clip color*)
			aspect,									(*the aspect ratio*)
			leg										(*chose the legend bar*)
			]&;
			
		(* Create and show plot*)
		exp=plot[xp,yp,x]
	
		,##,
		Initialization:>{or=1,reverse=False,legend=False,leftright->1},
		ControlPlacement->Right,
		(*Deployed->True,*) 
		SynchronousInitialization -> False
		]&@@control;
		
		NotebookClose[plotwindow];
		plotwindow=CreateWindow[DialogNotebook[{CancelButton["Close", Clear[data1,data2];DialogReturn[]], pan}, 
			WindowSize -> All, WindowTitle -> "Plot data window"]];
	];


(* ::Subsection::Closed:: *)
(*Plot Data 3D*)


SyntaxInformation[PlotData3D] = {"ArgumentsPattern" -> {_, _.}};

PlotData3D[dat_?ArrayQ, v:{_?NumberQ, _?NumberQ, _?NumberQ}:{1,1,1}] := DynamicModule[{data, vox, dep},
	NotebookClose[plotwindow];
	
	(*get data to dynamic*)
	data = ToPackedArray[N[Normal[dat]]];
	If[!ArrayQ[data, _, RealQ], Return[Message[PlotData::data]]];
	If[(dep = ArrayDepth[data])>4, Return[Message[PlotData::set]], n = dep-1];
	vox = v;
	
	(*start the manipulation*)
	pan = Manipulate[
			
		(*first part is data management, pdat is the data to be plotted*)
		t1 = (
			(*determine scaling and dimensions*)
			{sets, size1} = If[trans, dimd[[{2, 1}]], dimd[[{1, 2}]]];
			dim = {size1, size2, size3};
			size = Reverse[vox*dim];
			ratio = size/Max[size];
			
			(*correctly clip the slice numbers and mirror slices if needed*)
			set = If[NumericQ[set], Clip[set, {1, sets}], 1];
			slice = If[NumericQ[slice], Clip[slice, {1, size1}], 1];
			column = If[NumericQ[column], Clip[column, {1, size2}], 1];
			row = If[NumericQ[row], Clip[row, {1, size3}], 1];
			
			(*reverse dimenion index for correct data selection*)
			{slicep, columnp, rowp} = {size1 - slice + 1, size2 - column + 1, row};
			
			(*determine to draw lines and adjust pot scaling for all pannels*)
			scal = If[show != 4, scale, 0.6 scale];
			
			(*rescale 3D values for 3D image and select correct dataset*)
			dats = If[depth == 4, If[trans, data[[set]], data[[All, set]]], data];
			pdat = If[reverse, dats, Reverse[dats]];
			
			(*Check which 3D view to use*)
			If[MemberQ[views[[All, 1]], vp], vv = {0, 0, 1}; va = 25. Degree];
		) // AbsoluteTiming // First;
		
		(*get datarange and clip colors*)
		t2 = (
			(*get the plotrange*)
			ran = PlotRangeVals[cfs, pdat, {min, max}];
			(*make the clipping colors*)
			ccol = ClipColor[{clipMin, clipMax}, {minclip, maxclip}, {lstyle, color}];
		) // AbsoluteTiming // First;
		
		(*create the lices for the pannel all view*)
		t3 = (
			{linax, lincor, linsag} = If[show == 4 && lines,{
				Graphics[{Thickness[Large], Red, Line[{{row, 0}, {row, size2 + 1}} - 0.5], Green, Line[{{0, column}, {size3 + 1, column}} - 0.5]}],
				Graphics[{Thickness[Large], Red, Line[{{row, 0}, {row, size1 + 1}} - 0.5], Blue,  Line[{{0, slice}, {size3 + 1, slice}} - 0.5]}],
				Graphics[{Thickness[Large], Green, Line[{{column, 0}, {column, size1 + 1}} - 0.5], Blue, Line[{{0, slice}, {size2 + 1, slice}} - 0.5]}]
				},
				{Graphics[], Graphics[], Graphics[]}
			];
		) // AbsoluteTiming // First;
		
		(*create the axial coronal and sagital images*)
		t4 = (
			If[MemberQ[If[planez, {1, 4, 5, 7}, {1, 4}], show],
				imax = MakeImage[pdat[[slicep]], {lstyle, color}, ccol, ran];
				plax = Show[imax, linax, ImageSize -> scal {ratio[[1]], ratio[[2]]}, AspectRatio -> Full];
			];
			If[MemberQ[If[planey, {2, 4, 5, 7}, {2, 4}], show],
				imcor = MakeImage[pdat[[All, columnp]], {lstyle, color}, ccol, ran];
				plcor = Show[imcor, lincor, ImageSize -> scal {ratio[[1]], ratio[[3]]}, AspectRatio -> Full];
			];
			If[MemberQ[If[planex, {3, 4, 5, 7}, {3, 4}], show],
				imsag =  MakeImage[Reverse[pdat[[All, All, rowp]],2], {lstyle, color}, ccol, ran];
				plsag = Show[imsag, linsag, ImageSize -> scal {ratio[[2]], ratio[[3]]}, AspectRatio -> Full];
			];
		) // AbsoluteTiming // First;
		
		(*create the pannel all view with event handles to click and select*)
		t5 = (
			If[show == 4, 
				imall = Grid[{{
					EventHandler[plax, {"MouseDown" :> ({row, column} = Abs[Round[MousePosition["Graphics"]] - {-1, -1}])}]
					},{
					EventHandler[plcor, {"MouseDown" :> ({row, slice} = Abs[Round[MousePosition["Graphics"]] - {-1, 1}])}],
					EventHandler[plsag, {"MouseDown" :> ({column, slice} = (Abs[Round[MousePosition["Graphics"]] - {-1, 1}]))}]
				}},	Background -> White, Spacings -> {0, 0}, Frame -> All, FrameStyle -> Directive[{Thickness[6], White}]]
			];
		) // AbsoluteTiming // First;
		
		(*create the 3d slice view*)
		t6 = (
			If[show == 5 || show == 7,
				sel = DeleteCases[{If[planez, 1], If[planey, 2], If[planex, 3]}, Null];
				slices3D = If[sel == {},
					{},
					{
						Opacity[{opz, opy, opx}[[#]]],
						Texture[{imax, imcor, imsag}[[#]]],
						Polygon[{
							{{1, 1, slice}, {size3, 1, slice}, {size3, size2, slice}, {1, size2, slice}},
							{{1, column, 1}, {size3, column, 1}, {size3, column, size1}, {1, column, size1}},
							{{row, 1, 1}, {row, size2, 1}, {row, size2, size1}, {row, 1, size1}}}[[#]],
						VertexTextureCoordinates -> {{0.025, 0.025}, {0.975, 0.025}, {0.975, 0.975}, {0.025, 0.975}}]
					} & /@ sel
				];
				
				plsl3D = Show[Graphics3D[{EdgeForm[None], slices3D},
					BoxRatios -> ratio, ImageSize -> scale, RotationAction -> "Clip", SphericalRegion -> True, 
					Background -> back, Lighting -> "Neutral", ViewPoint -> Dynamic[vp], ViewVertical -> Dynamic[vv],  ViewAngle -> Dynamic[va],
					Boxed -> box, Axes -> axes, AxesStyle -> Thread[List[{Red, Green, Blue}, Thick]]
				], PlotRange -> {{-1, size3 + 1}, {-1, size2 + 1}, {-1, size1 + 1}}, PerformanceGoal -> "Quality"]
			];
		) // AbsoluteTiming // First;
		
		(*Create the 3D image using Image3D*)
		t7 = (
			If[show == 6 || show == 7,
				plim3D = Image3D[ToByte[pdat, ran], ColorFunction -> col3D, Method -> {"SampleLayers" -> 100}, 
					BoxRatios -> ratio, ImageSize -> scale, SphericalRegion -> True,  ViewPoint -> Dynamic[vp], ViewVertical -> Dynamic[vv],  ViewAngle -> Dynamic[va],
					Background -> back, Boxed -> box, Axes -> axes, AxesStyle -> Thread[List[{Red, Green, Blue}, Thick]]
				]
			];
		) // AbsoluteTiming // First;
		
		(*If the Hybrid 3D slice and image3D veiuw is selected join the two images*)
		If[show == 7,
			merge = Show[Graphics3D[{EdgeForm[None], slices3D}], plim3D,
				BoxRatios -> ratio, ImageSize -> scale, RotationAction -> "Clip", SphericalRegion -> True, 
				Background -> back, Lighting -> "Neutral", ViewPoint -> Dynamic[vp], ViewVertical -> Dynamic[vv], ViewAngle -> Dynamic[va],
				Boxed -> box, Axes -> axes, AxesStyle -> Thread[List[{Red, Green, Blue}, Thick]],
				PlotRange -> {{-1, size3 + 1}, {-1, size2 + 1}, {-1, size1 + 1}}, PerformanceGoal -> "Quality"
			]
		];
		
		(*select the correct plot*)
		Column[{
			(*{t1,t2,t3,t4,t5,t6,t7},*)
			Switch[show, 1, plax, 2, plcor, 3, plsag, 4, imall, 5, plsl3D, 6, plim3D, 7, merge]
		}]
		
	    (*start control pannel*)
	    ,
	    (*--------------clean from here---------------------*)
	    Row[{str}],
	    Delimiter,
	    (*The menu that selects what to show*)
	    {{show, 4, "Plot Mode"}, {1 -> "Axial", 2 -> "Coronal", 3 -> "Sagital", 4 -> "All Planes", 5 -> "Planes 3D", 6 -> "Volume 3D", 7 -> "Planes + 3D"}},
	    (*slice selection menu and *)
	    Delimiter,
	    Column[{
	      ManPannel["Slice Selection", {
	        {Dynamic["Axial (1-" <> ToString[size1] <> ")"], Control@{{slice, Round[size1/2], ""}, 1, size1, 1}},
	        {Dynamic[ "Coronal (1-" <> ToString[size2] <> ")"], Control@{{column, Round[size2/2], ""}, 1, size2, 1}},
	        {Dynamic["Sagital (1-" <> ToString[size3] <> ")"], Control@{{row, Round[size3/2], ""}, 1, size3, 1}},
	        {"Data order", Row[{
	        	Control@{{trans, False, ""}, {True, False}},"  Transpose 4D   ", 
	        	Control@{{reverse, False, ""}, {True, False}}, "  Reverse slices"
	        }]},
	        {Dynamic["Set (4D)  (1-" <> ToString[sets] <> ")"], Control@{{set, 1, ""}, 1, Dynamic[sets], 1}}, 
	        {"Clip 3D", Row[{Control@{{clip3D, False, ""}, {True, False}}, "  Clip   ", CheckboxBar[Dynamic[flip], {1 -> "Flip LR", 2 -> "Flip AP",3 -> "Flip FH"}]}]} 
	        }]
	      }],
	    Delimiter,
	    Column[{
	      ManPannel["Plot Range", {
	        {"Auto Scaling", Control@{{cfs, False, ""}, {True -> "On", False -> "Off"}}},
	        {"Min value", Control@{{min, mind, ""}, mind, Dynamic[0.9 max]}},
	        {"Max value", Control@{{max, maxd, ""}, Dynamic[1.1 min], maxd}},
	        {"Min Clipping", Row[{
	        	Control@{{clipMin,"Custom",""}, {"Auto", "Transparent", "Custom"->"Custom: "}}," ",
	        	Control@{{minclip, Black, ""}, ColorSlider[#, ImageSize -> {20, 20}, AppearanceElements->"Swatch"] &}
	        }]},
	        {"Max Clipping", Row[{
	        	Control@{{clipMax,"Custom",""}, {"Auto", "Transparent", "Custom"->"Custom: "}}," ",
	        	Control@{{maxclip, White, "" }, ColorSlider[#, ImageSize -> {20, 20}, AppearanceElements->"Swatch"] &}
	        }]}
	        }]
	      }],
	    Delimiter,
	    (*menu for plot style*)
	    Column[{
	      ManPannel["Plot Style", {
	        {"Plot Title", Control@{{label, "", ""}, InputField[#, String] &}},
	        {"Plot Size", Control@{{scale, 500, "" }, psizes}},
	        {"Color function", Control@{{color, "BlackToWhite", ""}, colors, ControlType -> PopupMenu}},
	        {"Color style", Control@{{lstyle, "Normal", ""}, colfuncs}},
	        {"Layout", Row[
	          {"  Show box:", Control@{{box, True, ""}, {True, False}},
	           "  Show axis:", Control@{{axes, True, ""}, {True, False}},
	           "  Show lines:", Control@{{lines, True, ""}, {True, False}}
	           }]},
	        {"BackGround", Control@{{back, Gray, ""}, ColorSlider[#, ImageSize -> {Automatic, 20}] &}}
	        }]
	      }],
	    (* menu for 3D plot options*)
	    Delimiter,
	    Column[{
	      ManPannel["3D options", {
	        { "Colorfunction 3D", Control@{{col3D, "WhiteBlackOpacity", ""}, colors3D}},
	        {"Viewpoint", Control@{{vp, 3.5 {0.384, 0.709, 0.591}, ""}, views, ControlType -> SetterBar}},
	        {"Show Planes", Row[{
	           "Axial:  ", Control@{{planez, True, ""}, {True, False}},
	           "  Coronal:  ", Control@{{planey, True, ""}, {True, False}},
	           "  Sagital:  ", Control@{{planex, True, ""}, {True, False}}
	           }]},
	        {"Opacity Axial", Control@{{opz, 1, ""}, 0, 1, 0.1}},
	        {"Opacity Coronal", Control@{{opy, 1, ""}, 0, 1, 0.1}},
	        {"Opacity Sagital", Control@{{opx, 1, ""}, 0, 1, 0.1}}
	        }, False]
	      }],
	    
	    (*Hidden parameters*)
	    (*for controls*)
	    {slice, ControlType -> None}, {column, ControlType -> None}, {row, ControlType -> None}, 
	    {trans, ControlType -> None}, {reverse, ControlType -> None}, {set, ControlType -> None}, 
	    {clip, ControlType -> None}, {flip, ControlType -> None},
	    
	    {{cfs, False}, ControlType -> None}, {min, ControlType -> None}, {max, ControlType -> None}, {ran, ControlType -> None}, 
	    {{minclip, RGBColor[{0, 0, 0, 1}]}, ControlType -> None}, {{maxclip, RGBColor[{255, 255, 255}]}, ControlType -> None}, 
	    {{transp, False}, ControlType -> None}, {col3D, ControlType -> None},
	    
	    {label, ControlType -> None}, {scale, ControlType -> None}, {color, ControlType -> None}, {lstyle, ControlType -> None},
	    {{box, True}, ControlType -> None}, {{axes, True}, ControlType -> None}, {{lines, True}, ControlType -> None}, {{back, Gray}, ControlType -> None},
	    
	    {{planez, True}, ControlType -> None}, {{planey, True}, ControlType -> None}, {{planex, True}, ControlType -> None},
	    {{opz, 1}, ControlType -> None}, {{opy, 1}, ControlType -> None}, {{opx, 1}, ControlType -> None},
	    
	    (*3d volume view*)
	    {{vp, 2{0.65, -1.2, 1}, "ViewPoint"}, Dynamic[vp] &, ControlType -> None},
	    {{vv, {0, 0, 1}, "ViewVertical"}, Dynamic[vv] &, ControlType -> None},
	    {{va, 25. Degree, "ViewAngle"}, Dynamic[va] &, ControlType -> None},
	    
	    (*for calculations*)
	    {mind, ControlType -> None}, {maxd, ControlType -> None}, {depth, ControlType -> None},
	    {dimd, ControlType -> None}, {sets, ControlType -> None}, {size1, ControlType -> None}, 
	    {size2, ControlType -> None}, {size3, ControlType -> None}, {slicep, ControlType -> None}, 
	    {columnp, ControlType -> None}, {rowp, ControlType -> None},
	    
	    {dim, ControlType -> None}, {size, ControlType -> None}, {scal, ControlType -> None}, {ratio, ControlType -> None},
	    
	    {dats, ControlType -> None}, {pdat, ControlType -> None},
	     
	    {linax, ControlType -> None}, {lincor, ControlType -> None}, {linsag, ControlType -> None},
	    {plax, ControlType -> None}, {plcor, ControlType -> None}, {plsag, ControlType -> None},
	    {imax, ControlType -> None}, {imcor, ControlType -> None}, {imsag, ControlType -> None}, {imall, ControlType -> None},
	    {sel, ControlType -> None}, {slices3D, ControlType -> None}, {plsl3D, ControlType -> None}, {plim3D, ControlType -> None},
	    
	    (*initialization*)
	    Initialization :> {
		  {mind, maxd} = {min, max} = MinMax[data],
		  depth = ArrayDepth[data], 
		  dimd = If[ArrayDepth[data] != 4, Prepend[Dimensions@data, 1], Dimensions@Transpose[data]], 
		  {sets, size1, size2, size3} = dimd,
		  {slice, column, row} = Round[{size1, size2, size3}/2],
		  str = "Displaying " <> DataString[dimd]
	  	},
	    
	    ContentSize -> 1.15 {scale, scale},
	    Alignment -> {Center, Center},
	    ControlPlacement -> Right,
	    ContinuousAction -> True,
	    AppearanceElements -> None,
	    AutorunSequencing -> {1},
	    SynchronousInitialization -> False
	];
	
	NotebookClose[plotwindow];
	plotwindow = CreateWindow[DialogNotebook[{CancelButton["Close", Clear[data]; DialogReturn[]], pan}, 
		WindowSize -> All, WindowTitle -> "Plot data window"]];
];

(*
SyntaxInformation[PlotData3D] = {"ArgumentsPattern" -> {_, _.}};

PlotData3D[data_, vox:{_, _, _}:{1, 1, 1}] := Module[{
   tran, depth, mind, maxd, dimd, ratio, dim, setp, slicep, columnp, rowp, line,
  scal, dats, pdat, im3D,colf, linax, lincor, linsag, plax, plcor, plsag, imall, sel, slices3D, plsl3D, plim3D, dat,
  imax, imcor, imsag, size1, size2, size3, size1b, mins,
     maxs
  },
 
 NotebookClose[plotwindow3D];
 ClearTemporaryVariables[];
 
 tran = False;
 depth = ArrayDepth[data];
 mind = Min[data];
 maxd = Max[data];
 dat = If[depth == 4, Reverse@ToByte[data, {mind, maxd}], 
    Reverse@ToByte[data, {mind, maxd}]];
 dimd = Dimensions[dat];
 
   size1b = 1;
   
   pan = Manipulate[
     
     t0 = (
         (*determine scaling and dimensions*)
         dim = {size1, size2, size3} = If[depth == 4, 
            If[trans, 
            	size1b = dimd[[1]]; dimd[[{2, 3, 4}]],
            	size1b = dimd[[2]]; dimd[[{1, 3, 4}]]
            	], 
            dimd];
         ratio = Reverse[vox*dim]/Max[(vox*dim)];
         
         (*correctly clip the slice numbers and mirror slices if needed*)
         If[depth == 4 && trans != tran, {tran, slice, set} = {trans, set, slice}];
         
         set = If[NumericQ[set], Clip[set, {1, size1b}], 1];
         slice = If[NumericQ[slice], Clip[slice, {1, size1}], 1];
         column = If[NumericQ[column], Clip[column, {1, size2}], 1];
         row = If[NumericQ[row], Clip[row, {1, size3}], 1];
         
         {setp, slicep, columnp, rowp} = If[trans && depth == 4, 
         	{size1b - set + 1, slice, column, size3 - row + 1}, 
         	{set, size1 - slice + 1, column, size3 - row + 1}];
         
         (*determine to draw lines and adjust pot scaling for all pannels*)
         {line, scal} = 
          If[show != 4, {False, scale}, {lines, 0.5 scale}];
         ) // AbsoluteTiming // First;
     
     (*create im3D*)
     t1 = (
         (*rescale 3D values for 3D image and select correct dataset*)

         
         dats = 
          If[depth == 4, 
           If[trans, {dat[[setp]]}, {dat[[All, setp]]}], {dat}];
         mins = Min[dats];
         maxs = Max[dats];
         min3D = Clip[min3D, {mins, 1}];
         max3D = Clip[max3D, {0, 2 maxs}];
         
         (*create im3D*)
         pdat = 
          If[show == 6, ToByte[##, {min3D, max3D}], ##] & @@
            dats;
         im3D = 
          Image3D[##, ColorFunction -> col3D] & @@ 
           If[reverse, {Reverse[pdat]}, {pdat}];
         ) // AbsoluteTiming // First;
     
     (*Create dynamic color function, 1000 values, 
     with clipping for min and max vals*)
     t2 = (
         If[show != 6,
         	(*colf = LookUpTable3[cfs, {lstyle, color}, {minclip, maxclip},If[cfs,{mind,maxd,mind,maxd},{mind,maxd,min,max}]]*)
         	colf = LookUpTable[{lstyle, color}, {minclip, maxclip}]         	
         	]
         ) // AbsoluteTiming // First;
     
     (*create the lices for the pannel all view*)
     t3 = (If[show == 4 && lines,
          
          linax = Graphics[{Red, Thickness[.01], 
             Line[{{column, 0}, {column, size2}}], Green, 
             Thickness[.01], Line[{{0, row}, {size3, row}}]}];
          
          lincor = 
           Graphics[{Red, Thickness[.01], 
             Line[{{column, 0}, {column, size3}}], Blue, 
             Thickness[.01], Line[{{0, slice}, {size3, slice}}]}];
          
          linsag = 
           Graphics[{Green, Thickness[.01], 
             Line[{{row, 0}, {row, size3}}], Blue, Thickness[.01], 
             Line[{{0, slice}, {size3, slice}}]}];
          ]
         ) // AbsoluteTiming // First;
     
     (*create the axial coronal and sagital images*)
     t4 = (
         If[MemberQ[If[planez, {1, 4, 5}, {1, 4}], show],
          
          imax = Colorize[Image3DSlices[im3D, {slicep}, 1][[1]], 
            ColorFunction -> colf, ColorFunctionScaling -> cfs];
          
          plax = Show[##, ImageSize -> scal {ratio[[1]], ratio[[2]]}, 
              AspectRatio -> Full] & @@ 
            If[line, {imax, linax}, {imax}];
          ];
         If[MemberQ[If[planey, {2, 4, 5}, {2, 4}], show],
          
          imcor = Colorize[Image3DSlices[im3D, {rowp}, 2][[1]], 
            ColorFunction -> colf, ColorFunctionScaling -> cfs];
          
          plcor = Show[##, ImageSize -> scal {ratio[[1]], ratio[[3]]},
               AspectRatio -> Full] & @@ 
            If[line, {imcor, lincor}, {imcor}];
          ];
         If[MemberQ[If[planex, {3, 4, 5}, {3, 4}], show],
          
          imsag = ImageReflect[
            Colorize[Image3DSlices[im3D, {columnp}, 3][[1]], 
             ColorFunction -> colf, ColorFunctionScaling -> cfs], 
            Left -> Right];
          
          plsag = Show[##, ImageSize -> scal {ratio[[2]], ratio[[3]]},
               AspectRatio -> Full] & @@ 
            If[line, {imsag, linsag}, {imsag}];
          ];
         ) // AbsoluteTiming // First;
     
     (*create the pannel all view with event handles to click and \
select*)
     t5 = (
         If[show == 4,
           imall = Grid[{{
               
               EventHandler[
                plax, {"MouseDown" :> ({column, row} = 
                    Abs[Round[
                    MousePosition["Graphics"]] - {-1, -1}])}]}, {
               
               EventHandler[
                plcor, {"MouseDown" :> ({column, slice} = 
                    Abs[Round[MousePosition["Graphics"]] - {-1, 1}])}],
               
               EventHandler[
                
                plsag, {"MouseDown" :> ({row, 
                    slice} = (Abs[
                    Round[MousePosition["Graphics"]] - {-1, 1}]))}]
               }}, Background -> White, Spacings -> {0, 0}, 
             Frame -> All, 
             FrameStyle -> Directive[{Thickness[6], White}]]];
         ) // AbsoluteTiming // First;
     
     If[MemberQ[views[[All, 1]], vp], vv = {0, 0, 1}];
     
     t6 = (If[show == 5,
           
           sel = DeleteCases[{If[planez, 1], If[planey, 2], 
              If[planex, 3]}, Null];
           
           slices3D = 
            If[sel == {}, {}, {Opacity[{opz, opy, opx}[[#]]], 
                Dynamic[Texture[{imax, imcor, imsag}[[#]]]], Polygon[{
                   {{1, 1, slice}, {size3, 1, slice}, {size3, size2, 
                    slice}, {1, size2, slice}},
                   {{1, row, 1}, {size2, row, 1}, {size2, row, 
                    size1}, {1, row, size1}},
                   {{column, 1, 1}, {column, size3, 1}, {column, 
                    size3, size1}, {column, 1, size1}}
                   }[[#]], 
                 VertexTextureCoordinates -> {{0, 0}, {1, 0}, {1, 
                    1}, {0, 1}}]} & /@ sel
             ];
           plsl3D = Show[Graphics3D[slices3D,
              BoxRatios -> ratio, ImageSize -> scale, 
              SphericalRegion -> True, Background -> back, 
              Lighting -> "Neutral",
              ViewPoint -> Dynamic[vp], ViewVertical -> Dynamic[vv], 
              ViewAngle -> Dynamic[va],
              Boxed -> box, Axes -> axes, 
              AxesStyle -> Thread[List[{Red, Green, Blue}, Thick]]
              ], 
             PlotRange -> {{-1, size3 + 1}, {-1, size2 + 1}, {-1, 
                size1 + 1}}]
           ];
         ) // AbsoluteTiming // First;
     
     If[show == 6, plim3D = Show[
         im3D,
         BoxRatios -> ratio, ImageSize -> scale, 
         SphericalRegion -> True, Background -> back, 
         Lighting -> "Neutral",
         ViewPoint -> Dynamic[vp], ViewVertical -> Dynamic[vv], 
         ViewAngle -> Dynamic[va],
         Boxed -> box, Axes -> axes, 
         AxesStyle -> Thread[List[{Red, Green, Blue}, Thick]],
         PlotRange -> {{-1, size3 + 1}, {-1, size2 + 1}, {-1, 
            size1 + 1}}
         ];
      ];
     
     Switch[show,
      1, plax,
      2, plcor,
      3, plsag,
      4, imall,
      5, plsl3D,
      6, plim3D
      ]
     
     ,
     
     (*show what*)
     {{show, 4, "Plot Mode"}, {1 -> "Axial", 2 -> "Coronal", 
       3 -> "Sagital", 4 -> "All Planes", 5 -> "Planes 3D", 
       6 -> "Volume 3D"}},
     {{scale, 500, "Plot Size"}, psizes},
     {{back, Gray, "BackGround"}, 
      ColorSlider[#, ImageSize -> {Automatic, 15}] &},
     
     (*general 4D*)
     {{set, 1, "Set (4D)"}, 1, Dynamic[size1b], 1},
     (*general 3D 4D*)
     {{trans, False, "Transpose 4D"}, {True, False}},
     {{reverse, False, "Reverse slices"}, {True, False}},
     {{slice, Round[size1/2], "Axial"}, 1, Dynamic[size1], 1},
     {{row, Round[size2/2], "Coronal"}, 1, Dynamic[size2], 1},
     {{column, Round[size3/2], "Sagital"}, 1, Dynamic[size3], 1},
     
     (*all planes 4*)
     {{lines, True, "Show lines"}, {True -> "On", False -> "Off"}},
     
     (*planes color 1-5*)
     {{color, "BlackToWhite", "ColorFunction"}, colors},
     {{lstyle, 1, "lstyle"}, colfuncs},
     {{cfs, False, "Auto Scaling"}, {True -> "On", False -> "Off"}},
     (*on or off by auto scale*)
     {{min, mind, "Min"}, mind, 0.9 max},
     {{minclip, RGBColor[{0, 0, 0}], "MinClip"}, 
      ColorSlider[#, ImageSize -> {Automatic, 15}] &},
     {{max, maxd, "Max"}, 1.1 min, maxd},
     {{maxclip, RGBColor[{255, 255, 255}], "MaxClip"}, 
      ColorSlider[#, ImageSize -> {Automatic, 15}] &},
     
     (*3D general 5-6*)
     {{box, True, "Show box"}, {True, False}},
     {{axes, True, "Show axis"}, {True, False}},
     {{vp, 3.5 {0.384, 0.709, 0.591}, "Viewpoint"}, views, 
      ControlType -> SetterBar},
     
     (*3D planes 5*)
     {{planex, True, "Show plane x"}, {True, False}},
     {{opx, 1, "Opacity plane x"}, 0, 1, 0.1},
     {{planey, True, "Show plane y"}, {True, False}},
     {{opy, 1, "Opacity plane y"}, 0, 1, 0.1},
     {{planez, True, "Show plane z"}, {True, False}},
     {{opz, 1, "Opacity plane z"}, 0, 1, 0.1},
     
     (*3Dvol 6*)
     {{col3D, Automatic, "Colorfunction 3D"}, colors3D},
     {{min3D, mins, "min 3D"}, Dynamic[mins], max3D},
     {{max3D, maxs, "max 3D"}, min3D, Dynamic[2 maxs]},
     
     {{vp, 3.5 {0.384, 0.709, 0.591}, "ViewPoint"}, Dynamic[vp] &, 
      ControlType -> None},
     {{vv, {0, 0, 1}, "ViewVertical"}, Dynamic[vv] &, 
      ControlType -> None},
     {{va, 25 Degree, "ViewAngle"}, Dynamic[va] &, 
      ControlType -> None},
     
     ControlPlacement -> Right,
     SynchronousInitialization -> False
     ];

   plotwindow3D = 
    CreateWindow[
     DialogNotebook[{CancelButton["Close",Clear[data]; DialogReturn[]], pan}, 
      WindowSize -> All, WindowTitle -> "Plot data window"]];
 ]
*)

(*
PointsFunc = 
  Compile[{{qual, _Real, 0}, {dx, _Integer, 0}, {dy, _Integer, 
     0}, {dz, _Integer, 0}, {size, _Integer, 0}, {alpha, _Real, 
     0}, {beta, _Real, 0}, {or, _Real, 1}},
   Block[{pts, pt = {1, 1, 1}, ptls, blank = {{1, 1, 1}}, test = 0, 
     step = Round[size/(qual*size)]},
    pts = Table[
      Round[(({{1, 0, 0}, {0, Cos[alpha], -Sin[alpha]}, {0, 
              Sin[alpha], Cos[alpha]}}.{{Cos[beta], 0, Sin[beta]}, {0,
               1, 0}, {-Sin[beta], 0, Cos[beta]}}).({x, y, or[[3]]} - 
            or)) + or],
      {y, -Round[(size - dy)/2], Round[(size - dy)/2] + dy, step},
      {x, -Round[(size - dx)/2], Round[(size - dx)/2] + dx, step}];
    Do[pts = DeleteCases[(
          ptls = #;
          blank = ConstantArray[0, Dimensions[ptls]];
          
          test = Total[(pt = #; 
               If[1 - step <= pt[[1]] <= dx + step && 
                 1 - step <= pt[[2]] <= dy + step && 
                 1 - step <= pt[[3]] <= dz + step, 1, 0]) & /@ ptls];
          If[test > 0, ptls, blank]
          ) & /@ pts, blank];
     pts = Transpose[DeleteCases[(
           ptls = #;
           blank = ConstantArray[0, Dimensions[ptls]];
           
           test = Total[(pt = #; 
                If[1 - step <= pt[[1]] <= dx + step && 
                  1 - step <= pt[[2]] <= dy + step && 
                  1 - step <= pt[[3]] <= dz + step, 1, 0]) & /@ ptls];
           If[test > 0, ptls, blank]
           ) & /@ Transpose[pts], blank]];
     , {2}];
    pts
    ]];

AngCor = Function[{ang, cor}, 
   If[-45 <= ang <= 45, ang*(cor/45), 
     If[Positive[ang], 
      cor + (ang - 45)*(90 - cor)/45, -cor + (ang + 45)*(90 - cor)/
         45]] Degree];


SyntaxInformation[PlotData3D] = {"ArgumentsPattern" -> {_, _.}};

PlotData3D[data_, vox : {_, _, _} : {1, 1, 1}] := 
 Module[{tab1, tab2, tab3, tab4, control, dim, dz, dx, dy, planes, 
   qual, xx, yy, zz, planex, opx, planey, opy, planez, opz, ratio, or,
    clip, slicex, slicey, slicez, 
   slicea, sliceao, surf, vp, va, vv, plot, exp, diag, dorig, dqual, 
   opd, diagx, diagy, diagz, alpha, beta, box, axes, label, ps, color,
    lstyle, bcol, legend, min, max, minclip, maxclip, 
   pxmin, pxmax, pymin, pymax, pzmin, pzmax, iso, isoval, surfqual, 
   surfop, surfcol, fileType, size, pannel, dimq, pts, pol, gr, vec, 
   a, b, c, ang, angx, angy}, 
  If[(! ArrayQ[data, _, NumericQ]) || (! ArrayDepth[data] == 3), Return[Message[PlotData3D::data]]];
  
  dim = {dz, dy, dx} = Dimensions[data];
  size = Round[Sqrt[Total[#^2 & /@ Drop[Sort[dim], 1]]] // N];
  
  tab1 = Column[{ManPannel[
      "Planes", {
      	{"Show Planes",Control@{{planes, True, ""}, {True, False}}}, 
      	{"Plane Quality (%)", Control@{{qual, .5, ""}, .2, 1, .2}}, 
      	{Style["Plane Navigation", Bold], ""}, 
        {"Corronal Slice (x)",Control@{{xx, Round[dx/2], ""}, 1, dx, 1}}, 
        {"Saggital Slice (y)",Control@{{yy, Round[dy/2], ""}, 1, dy, 1}}, 
        {"Axial Slice (z)",Control@{{zz, Round[dz/2], ""}, 1, dz, 1}}, 
        {Style["Plane Settings", Bold], ""}, 
        {"Show Corronal (x)",Control@{{planex, True, ""}, {True, False}}}, 
        {"Plane Opacity (x)",Control@{{opx, 1, ""}, 0, 1, 0.1}}, 
        {"Show Saggital (y)",Control@{{planey, True, ""}, {True, False}}}, 
        {"Plane Opacity (y)",Control@{{opy, 1, ""}, 0, 1, 0.1}}, 
        {"Show Axial (z)",Control@{{planez, True, ""}, {True, False}}}, 
        {"Plane Opacity (z)",Control@{{opz, 1, ""}, 0, 1, 0.1}}}], 
     ManPannel[
      "Diagonal plane", {
      	{"Show Diagonal",  Control@{{diag, False, ""}, {True,False}}}, 
        {"Show Plane Origin",Control@{{dorig, False, ""}, {True,False}}}, 
        {"Plane Quality (%)", Control@{{dqual, .5, ""},.2,1,.2}}, 
        {"Plane Opacity", Control@{{opd, 1, ""}, 0, 1, 0.1}}, 
        {Style["Position", Bold], ""}, 
        {"Diagonal x Position", Control@{{diagx, Round[dx/2], ""}, 1, dx, 1}}, 
        {"Diagonal y Position", Control@{{diagy, Round[dy/2], ""}, 1, dy,1}}, 
        {"Diagonal z Position",  Control@{{diagz, Round[dz/2], ""}, 1, dz, 1}}, 
        {Style["Rotation", Bold], ""}, 
        {"Rotation x-axis (\[Degree])", Control@{{alpha, 15, ""}, -90, 90,  1}}, 
        {"Rotation y-axis (\[Degree])",  Control@{{beta, 15, ""}, -90, 90, 1}}}, False]}];
  tab2 = Column[{ManPannel[
      "Plot Style", {
      	{"Show Box", Control@{{box, False, ""}, {True, False}}}, 
        {"Show Axes", Control@{{axes, False, ""}, {True, False}}}, 
        {"Plot Title", Control@{{label, "", ""}, InputField[#, String] &}}, 
        {"Plot Size", Control@{{ps, 400, ""}, sizes, ControlType -> PopupMenu}},
        {"Color function", Control@{{color, "GrayTones", ""}, colors, ControlType -> PopupMenu}}, 
        {"Color style", Control@{{lstyle, 1, ""}, colfuncs}}, 
        {"Background Color", Control@{{bcol, Gray, ""}, ColorSlider[#,  ImageSize -> {Automatic, 15}] &}}, 
        {"Legend on/off", Control@{{legend, False, ""}, {True, False}}}}], 
     ManPannel[
      "Plot Range", {
      	{"Min value", Control@{{min, Min[data], ""}, Min[data], max, (max - Min[data])/100}}, 
        {"Max value",  Control@{{max, Max[data], ""}, min, Max[data], (Max[data] - min)/100}}, 
        (*{"Transparent Clipping", Control@{{transclip, False, ""}, {True, False}}},*) 
        {"Min Clipping",  Control@{{minclip, Black, ""},  ColorSlider[#,  ImageSize -> {Automatic, 15}] &}}, 
        {"Max Clipping", Control@{{maxclip, White, ""},   ColorSlider[#, ImageSize -> {Automatic, 15}] &}}}], 
     ManPannel[
      "Slice Range", {
      	{"Minimal x value", Control@{{pxmin, 1, ""}, 1, pxmax, 1}}, 
        {"Maximal x value", Control@{{pxmax, dx, ""}, pxmin + 1, dx,1}}, 
        {"Minimal y value", Control@{{pymin, 1, ""}, 1, pymax, 1}}, 
        {"Maximal y value", Control@{{pymax, dy, ""}, pymin + 1, dy, 1}}, 
        {"Minimal z value", Control@{{pzmin, 1, ""}, 1, pzmax, 1}}, 
        {"Maximal z value", Control@{{pzmax, dz, ""}, pzmin + 1, dz, 1}}}]}];
  tab3 = Column[{ManPannel[
      "Iso Surface", {
      	{"Show IsoSurface", Control@{{iso, False, ""}, {True, False}}}, 
        {"Iso Value",  Control@{{isoval, {Round[Max[data]/2]}, ""}, InputField[#] &}}, 
        {"Surface Quality (%)", Control@{{surfqual, 50, ""}, 20, 125, 1}}, 
        {"Surface Opacity", Control@{{surfop, 1, ""}, 0, 1, 0.1}}, 
        {"Surface Color", Control@{{surfcol, Darker[Red], ""}, ColorSlider[#, ImageSize -> {Automatic, 15}] &}}}]}];
  tab4 = Column[{ManPannel[
      "Export plot", {
      	{"File Type", Control@{{fileType, ".jpg", ""}, files}}, 
        {"Export Size", Control@{{size, 400, ""}, sizes, ControlType -> PopupMenu}}, 
        {"Export", Button["Save Plot", FileSave[exp, fileType, size],  Method -> "Queued", ImageSize -> 150]}}]}
        ];
  control = {{{pannel, 1, ""}, {1 -> "Planes", 
      2 -> "Plotting Options", 3 -> "IsoSurface", 4 -> "Export"}}, 
    Delimiter, 
    PaneSelector[{1 -> tab1, 2 -> tab2, 3 -> tab3, 4 -> tab4}, 
     pannel]};
  
  (*mind=If[Min[data//N]==0.,0.0001 Max[data],0.];*)
  PrintTemporary["Initializing plot window, please wait"];
  
  Manipulate[If[! ListQ[data], Return[]];
    If[! ArrayQ[data], Return[]];
    (*define box ratio*)
    
    ratio = {(pxmax - pxmin), (pymax - pymin), (pzmax - 
         pzmin)} Reverse[vox];
    ang = {angx, angy} = 
      N[{ArcTan[(ratio[[3]]/vox[[1]])/(ratio[[3]]/vox[[2]])], 
         ArcTan[(ratio[[3]]/vox[[1]])/(ratio[[3]]/vox[[3]])]}/Degree];
    
    (*diagonal slice parameters*)
    
    or = {diagx, diagy, diagz};
    vec = {a, b, c} = 
      Normalize[
       Reverse[vox] {Sin[
          AngCor[beta, angy]], -Cos[AngCor[beta, angy]] Sin[
           AngCor[alpha, angx]], 
         Cos[AngCor[alpha, angx]] Cos[AngCor[beta, angy]]}];
    
    clip = {minclip,maxclip};
     (*If[transclip, {Transparent, Transparent}, {minclip, maxclip}];*)
    With[{
      
      (*slice plot function*)
      
      SlicePlot = 
       Function[{n, op}, 
        dimq = Round[qual*dim[[Drop[{1, 2, 3}, {n}]]]];
        {Opacity[op], 
          Texture[Graphics[
            Raster[Clip[
              Rescale[
               RescaleImg[{data[[zz]], data[[All, yy, All]], 
                  data[[All, All, xx]]}[[n]], dimq], {min, max}], {0, 
               1}, {-1, -2}], 
             ColorFunction -> (ColSelC[#, clip, {lstyle, color}] &)], 
            PlotRange -> {{0, dimq[[2]]}, {0, dimq[[1]]}}]], 
          Polygon[{{{1, 1, zz}, {dx, 1, zz}, {dx, dy, zz}, {1, dy, 
               zz}}, {{1, yy, 1}, {dx, yy, 1}, {dx, yy, dz}, {1, yy, 
               dz}}, {{xx, 1, 1}, {xx, dy, 1}, {xx, dy, dz}, {xx, 1, 
               dz}}}[[n]], 
           VertexTextureCoordinates -> {{0, 0}, {1, 0}, {1, 1}, {0, 
              1}}]}]
      
     (*, SlicePlotAng = 
       Function[{col, op}, 
        pts = PointsFunc[dqual, dx, dy, dz, size, AngCor[alpha, angx],
           AngCor[beta, angy], {diagx, diagy, diagz}];
        pol = {First[First[pts]], First[Last[pts]], Last[Last[pts]], 
          Last[First[pts]]};
          
        gr = 
         Graphics[
          Raster[Clip[
            Rescale[
             Map[data[[Clip[#[[3]], {1, dz}], Clip[#[[2]], {1, dy}], 
                Clip[#[[1]], {1, dx}]]] &, pts, {2}], {min, max}], {0,
              1}, {-1, -2}], 
           ColorFunction -> (ColSelC[#, clip, {lstyle, col}] &)], 
          PlotRange -> {{0, Length[pts[[1]]]}, {0, Length[pts]}}];
        {Opacity[op], Texture[gr], 
          Polygon[pol, 
           VertexTextureCoordinates -> {{0, 0}, {0, 1}, {1, 1}, {1, 
              0}}]}]*)},
     
     (*Draw planes*)
     
     slicex = If[#1 && #2, SlicePlot[2, opx], {}] &;
     slicey = If[#1 && #2, SlicePlot[3, opy], {}] &;
     slicez = If[#1 && #2, SlicePlot[1, opz], {}] &;
     slicea = If[#, 
     	pts = PointsFunc[dqual, dx, dy, dz, size, AngCor[alpha, angx],
           AngCor[beta, angy], {diagx, diagy, diagz}];
        pol = {First[First[pts]], First[Last[pts]], Last[Last[pts]], 
          Last[First[pts]]};
        gr = Graphics[Raster[Clip[Rescale[
             Map[data[[Clip[#[[3]], {1, dz}], Clip[#[[2]], {1, dy}], 
                Clip[#[[1]], {1, dx}]]] &, pts, {2}], {min, max}], {0,
              1}, {-1, -2}], 
           ColorFunction -> (ColSelC[#, clip, {lstyle, color}] &)], 
          PlotRange -> {{0, Length[pts[[1]]]}, {0, Length[pts]}}];
        {Opacity[opd], Texture[gr], 
          Polygon[pol, 
           VertexTextureCoordinates -> {{0, 0}, {0, 1}, {1, 1}, {1, 
              0}}]}
  , {}] &;];
    
    (*Draw diagonal slice marker*)
    
    sliceao = 
     If[#, Dynamic[{Red, 
         Scale[Sphere[or, (1/20 Min[dim*vox])], Min[vox]/Reverse[vox],
           or], Green, Thick, Arrowheads[0.05], 
         Scale[Arrow[
           Tube[{or, 
             or + (.5 Min[dim*vox]) (Normalize[vec/Reverse[vox]])}, 
            0.8]], Min[vox]/Reverse[vox], or]}], {}] &;
    
    (*Draw iso surface*)
    
    surf = 
     If[#, Dynamic[
        ListContourPlot3D[data, Contours -> Cases[isoval, _?NumberQ], 
          Mesh -> False, Axes -> False, 
          ContourStyle -> Directive[Opacity[surfop], surfcol], 
          MaxPlotPoints -> Round[0.75 surfqual], 
          BoundaryStyle -> None][[1]]], {}] &;
    
    (*Generate Plot*)
    
    plot = 
     Dynamic[Graphics3D[{sliceao[dorig], surf[iso], slicez[planes, planez], 
       slicey[planes, planey], slicex[planes, planex], slicea[diag]}, 
      Lighting -> "Neutral", BoxRatios -> ratio, 
      ViewPoint -> Dynamic[vp], ViewVertical -> Dynamic[vv], 
      ViewAngle -> Dynamic[va], ImageSize -> ps, Background -> bcol, 
      SphericalRegion -> True, Boxed -> box, Axes -> axes, 
      AxesStyle -> Thread[List[{Red, Green, Blue}, Thick]], 
      BaseStyle -> {FontWeight -> Bold, FontFamily -> "sans-serif", 
        28}, LabelStyle -> 14, AxesLabel -> {"X", "Y", "Z"}, 
      PlotRange -> {{pxmin - 1, pxmax + 1}, {pymin - 1, 
         pymax + 1}, {pzmin - 1, pzmax + 1}}, 
      ContentSelectable -> True, PlotLabel -> label, 
      ImagePadding -> {{5, 5}, {5, 5}}]];
    
    (*Display Plot*)
    
    exp = If[legend, Legendi[plot, {lstyle, color, bcol}, min, max, ps], plot]
    
    (*Insert control pannels*)
    , ## ,
    (*Hidden manipulation parameters*)
    {{vp, {1.3, -2.4, 2}, "ViewPoint"}, Dynamic[vp] &, ControlType -> None}, 
    {{vv, {0, 0, 1}, "ViewVertical"}, Dynamic[vv] &, ControlType -> None}, 
    {{va, 25 Degree, "ViewAngle"}, Dynamic[va] &, ControlType -> None}, 
    Deployed -> False, 
    SynchronousInitialization -> False, 
    SynchronousUpdating -> False, 
    ContinuousAction -> False,
    ControlPlacement -> Right
    ]&@@ control]
*)


(*
PlotData3D[data_, vox:{_,_,_}:{1,1,1}] := 
 Module[{tab1, tab2, tab3, tab4, control, dim, dz, dx, dy,
   planes, qual, xx, yy, zz, planex, opx, planey, opy, planez, opz,
   ratio,or,clip,CR=Clip[Round[#1], {1, #2}]&,
   slicex,slicey,slicez,slicea,sliceao,surf,vp,va,vv,plot,exp,
   diag, dorig, dqual, opd, diagx, diagy, diagz, alpha, beta,
   box, axes, label, ps, color, lstyle, bcol, legend,
   min, max, transclip, minclip, maxclip,
   pxmin, pxmax, pymin, pymax, pzmin, pzmax,
   iso, isoval, surfqual, surfop, surfcol,
   fileType, size, pannel,dimq,
   vec, a, b, c, ang, angx, angy, afunc, arang, asel, v1, v2
   },
  
  If[(! ArrayQ[data, _, NumericQ]) || (! ArrayDepth[data] == 3),Return[Message[PlotData3D::data]]];
  
  dim = {dz, dy, dx} = Dimensions[data];
  
  tab1 = Column[{
     ManPannel["Planes", {
       {"Show Planes", Control@{{planes, True, ""}, {True, False}}},
       {"Plane Quality (%)", Control@{{qual, .5, ""}, .1, 1, .1}},
       {Style["Plane Navigation", Bold], ""},
       {"Corronal Slice (x)", 
        Control@{{xx, Round[dx/2], ""}, 1, dx, 1}},
       {"Saggital Slice (y)", 
        Control@{{yy, Round[dy/2], ""}, 1, dy, 1}},
       {"Axial Slice (z)", Control@{{zz, Round[dz/2], ""}, 1, dz, 1}},
       {Style["Plane Settings", Bold], ""},
       {"Show Corronal (x)", 
        Control@{{planex, True, ""}, {True, False}}},
       {"Plane Opacity (x)", Control@{{opx, 1, ""}, 0, 1, 0.1}},
       {"Show Saggital (y)", 
        Control@{{planey, True, ""}, {True, False}}},
       {"Plane Opacity (y)", Control@{{opy, 1, ""}, 0, 1, 0.1}},
       {"Show Axial (z)", Control@{{planez, True, ""}, {True, False}}},
       {"Plane Opacity (z)", Control@{{opz, 1, ""}, 0, 1, 0.1}}
       }]
     ,
     ManPannel["Diagonal plane", {
       {"Show Diagonal", Control@{{diag, False, ""}, {True, False}}},
       {"Show Plane Origin", 
        Control@{{dorig, False, ""}, {True, False}}},
       {"Plane Quality (%)", Control@{{dqual, .5, ""}, .1, 1, .1}},
       {"Plane Opacity", Control@{{opd, 1, ""}, 0, 1, 0.1}},
       {Style["Position", Bold], ""},
       {"Diagonal x Position", 
        Control@{{diagx, Round[dx/2], ""}, 1, dx, 1}},
       {"Diagonal y Position", 
        Control@{{diagy, Round[dy/2], ""}, 1, dy, 1}},
       {"Diagonal z Position", 
        Control@{{diagz, Round[dz/2], ""}, 1, dz, 1}},
       {Style["Rotation", Bold], ""},
       {"Rotation x-axis (\[Degree])", 
        Control@{{alpha, 15, ""}, -90, 90, 1}},
       {"Rotation y-axis (\[Degree])", 
        Control@{{beta, 15, ""}, -90, 90, 1}}
       }, False]
     }];
  
  tab2 = Column[{
     ManPannel["Plot Style", {
       {"Show Box", Control@{{box, False, ""}, {True, False}}},
       {"Show Axes", Control@{{axes, False, ""}, {True, False}}},
       {"Plot Title", 
        Control@{{label, "", ""}, InputField[#, String] &}},
       {"Plot Size", 
        Control@{{ps, 400, ""}, sizes, ControlType -> PopupMenu}},
       {"Color function", 
        Control@{{color, "GrayTones", ""}, colors, 
          ControlType -> PopupMenu}},
       {"Color style", Control@{{lstyle, 1, ""}, colfuncs}},
       {"Background Color", 
        Control@{{bcol, Gray, ""}, 
          ColorSlider[#, ImageSize -> {Automatic, 15}] &}},
       {"Legend on/off", Control@{{legend, False, ""}, {True, False}}}
       }]
     ,
     ManPannel["Plot Range", {
       {"Min value", 
        Control@{{min, Min[data], ""}, Min[data], 
          max, (max - Min[data])/100}},
       {"Max value", 
        Control@{{max, Max[data], ""}, min, 
          Max[data], (Max[data] - min)/100}},
       {"Transparent Clipping", 
        Control@{{transclip, False, ""}, {True, False}}},
       {"Min Clipping", 
        Control@{{minclip, Black, ""}, 
          ColorSlider[#, ImageSize -> {Automatic, 15}] &}},
       {"Max Clipping", 
        Control@{{maxclip, White, ""}, 
          ColorSlider[#, ImageSize -> {Automatic, 15}] &}}
       }]
     ,
     ManPannel["Slice Range", {
       {"Minimal x value", Control@{{pxmin, 1, ""}, 1, pxmax, 1}},
       {"Maximal x value", 
        Control@{{pxmax, dx, ""}, pxmin + 1, dx, 1}},
       {"Minimal y value", Control@{{pymin, 1, ""}, 1, pymax, 1}},
       {"Maximal y value", 
        Control@{{pymax, dy, ""}, pymin + 1, dy, 1}},
       {"Minimal z value", Control@{{pzmin, 1, ""}, 1, pzmax, 1}},
       {"Maximal z value", Control@{{pzmax, dz, ""}, pzmin + 1, dz, 1}}
       }]
     }];
  
  tab3 = Column[{
     ManPannel["Iso Surface", {
       {"Show IsoSurface", Control@{{iso, False, ""}, {True, False}}},
       {"Iso Value", 
        Control@{{isoval, {Round[Max[data]/2]}, ""}, InputField[#] &}},
       {"Surface Quality (%)", 
        Control@{{surfqual, 50, ""}, 20, 125, 1}},
       {"Surface Opacity", Control@{{surfop, 1, ""}, 0, 1, 0.1}},
       {"Surface Color", 
        Control@{{surfcol, Darker[Red], ""}, 
          ColorSlider[#, ImageSize -> {Automatic, 15}] &}}
       }]
     }];
  
  tab4 = Column[{
     ManPannel["Export plot", {
       {"File Type", Control@{{fileType, ".jpg", ""}, files}},
       {"Export Size", 
        Control@{{size, 400, ""}, sizes, ControlType -> PopupMenu}},
       {"Export", 
        Button["Save Plot", FileSave[exp, fileType, size], 
         Method -> "Queued", ImageSize -> 150]}
       }]
     }];
  
  control = {
    {{pannel, 1, ""}, {1 -> "Planes", 2 -> "Plotting Options", 
      3 -> "IsoSurface", 4 -> "Export"}},
    Delimiter,
    PaneSelector[{1 -> tab1, 2 -> tab2, 3 -> tab3, 4 -> tab4}, pannel]
    };
  
  (*mind = If[Min[data // N] == 0., 0.0001 Max[data], 0.];*)
  
  PrintTemporary["Initializing plot window, please wait"];
  
  Manipulate[
  	
  	If[!ArrayQ[data],Return[]];
     
     (*define box ratio*)
     ratio = {(pymax - pymin), (pxmax - pxmin), (pzmax - pzmin)} Reverse[vox];
     
     (*diagonal slice parameters*)
     or = {diagx, diagy, diagz};
     vec = {a, b, c} = Normalize[Reverse[vox] {Sin[alpha Degree] Cos[beta Degree], Sin[alpha Degree] Sin[beta Degree], Cos[alpha Degree]}];
     If[diag, 
     	ang = {angx, angy} = N[{ArcTan[dz/dx], ArcTan[dx/dy]}/Degree];
      	asel = If[Abs[alpha] > angx && Abs[beta] > angy, 1, If[Abs[alpha] > angx, 2, 3]];
      	afunc = {
      		{v1,(-a (v1 - diagx) - b (-diagy) - c (v2 - diagz))/If[b == 0 || b == 0., 1, b], v2}, 
          	{(-a (-diagx) - b (v1 - diagy) - c (v2 - diagz))/If[a == 0 || a == 0., 1, a], v1, v2}, 
          	{v1, v2, (-a (v1 - diagx) - b (v2 - diagy) - c (-diagz))/If[c == 0 || c == 0., 1, c]}
          	}[[asel]]// N;
      	arang = {{dx, dz}, {dy, dz}, {dx, dy}}[[asel]];
      	;
      ];
     
     clip=If[transclip, {Transparent,Transparent}, {minclip,maxclip}];
     
     With[{
        (*slice plot function*)
        SlicePlot = Function[{vecf, rang, op, qualf},
        	ParametricPlot3D[vecf, {v1, 1, rang[[1]]}, {v2, 1, rang[[2]]},
        		PlotStyle -> Opacity[op], PlotPoints -> Round[qualf rang], Mesh -> False, ColorFunctionScaling -> False,
        		ColorFunction -> (ColSelC[Clip[Rescale[data[[CR[#3,dz],CR[#1,dx],CR[#2,dy]]],{min,max}],{0,1},{-1,2}],clip,{lstyle,color}]&)
        	]]
        ,
    	SlicePlot2 = 
  Function[{n, op}, dimq = Round[qual*dim[[Drop[{1, 2, 3}, {n}]]]];
   Graphics3D[{Opacity[op], 
     Texture[Graphics[
       Raster[Clip[
         Rescale[RescaleImg[{data[[zz]], data[[All, All, yy]], 
             data[[All, xx, All]]}[[n]], dimq], {min, max}], {0, 
          1}, {-1, -2}], 
        ColorFunction -> (ColSelC[#, clip, {lstyle, color}] &)], 
       PlotRange -> {{0, dimq[[2]]}, {0, dimq[[1]]}}, 
       AspectRatio -> (Divide @@ (dimq*Drop[vox, {n}]))]],
     Polygon[{
        {{1, 1, zz}, {dim[[2]], 1, zz}, {dim[[2]], dim[[3]], zz}, {1, 
          dim[[3]], zz}},
        {{1, xx, 1}, {dim[[2]], xx, 1}, {dim[[2]], xx, dim[[1]]}, {1, 
          xx, dim[[1]]}},
        {{yy, 1, 1}, {yy, dim[[3]], 1}, {yy, dim[[3]], dim[[1]]}, {yy,
           1, dim[[1]]}}
        }[[n]], 
      VertexTextureCoordinates -> {{{0, 0}, {0, 1}, {1, 1}, {1, 
           0}}, {{0, 0}, {1, 0}, {1, 1}, {0, 1}}, {{0, 0}, {1, 0}, {1,
            1}, {0, 
           1}}}[[n]]]}]]},
           (*Draw planes*)
		(*slicex=If[#1&&#2,SlicePlot[{v1,xx,v2},{dy,dz},opx,qual],Graphics3D[]]&;
		slicey=If[#1&&#2,SlicePlot[{yy,v1,v2},{dx,dz},opy,qual],Graphics3D[]]&;
		slicez=If[#1&&#2,SlicePlot[{v1,v2,zz},{dx,dy},opz,qual],Graphics3D[]]&;*)
		slicex = If[#1 && #2, SlicePlot2[2, opx], Graphics3D[]] &;
		slicey = If[#1 && #2, SlicePlot2[3, opy], Graphics3D[]] &;
		slicez = If[#1 && #2, SlicePlot2[1, opz], Graphics3D[]] &;
      slicea = If[#, SlicePlot[afunc, arang, opd, dqual], Graphics3D[]]&;
      ];
     
     (*Draw diagonal slice marker*)
     sliceao = If[#, Graphics3D[{Red,Scale[Sphere[or, 3], Min[vox]/Reverse[vox], or], Green, Thick, Arrowheads[0.05], 
         Scale[Arrow[Tube[{or, or + (1/5 Min[dim*vox]) (Normalize[vec/Reverse[vox]])}, 0.8]], Min[vox]/Reverse[vox], or]}],
       Graphics3D[]]&;
     
     (*Draw iso surface*)
     surf = If[#, ListContourPlot3D[Transpose[data, {1, 3, 2}], Contours -> Cases[isoval, _?NumberQ],Mesh -> False, Axes -> False,
        ContourStyle -> Directive[Opacity[surfop], surfcol], MaxPlotPoints -> Round[0.75 surfqual], BoundaryStyle -> None],
       Graphics3D[]]&;
     
     (*Generate Plot*)
     plot = Show[
       sliceao[dorig], surf[iso], slicez[planes,planez], slicey[planes,planey], slicex[planes,planex], slicea[diag],
       Lighting -> "Neutral", BoxRatios -> ratio, 
       ViewPoint -> Dynamic[vp], ViewVertical -> Dynamic[vv], 
       ViewAngle -> Dynamic[va], ImageSize -> ps, Background -> bcol, 
       SphericalRegion -> True, Boxed -> box, Axes -> axes, 
       AxesStyle -> Thread[List[{ Green, Red, Blue}, Thick]], 
       BaseStyle -> {FontWeight -> Bold, FontFamily -> "sans-serif", 
         28}, LabelStyle -> 14, AxesLabel -> { "Y", "X", "Z"}, 
       PlotRange -> {{pymin - 1, pymax + 1}, {pxmin - 1, 
          pxmax + 1}, {pzmin - 1, pzmax + 1}}, 
       ContentSelectable -> True, PlotLabel -> label, 
       ImagePadding -> {{5, 5}, {5, 5}}
       ];
     
     (*Display Plot*)  
     exp=If[legend,Dynamic[Legendi[plot,{lstyle,color,bcol},min,max,ps]],Dynamic[plot]]
       
     (*Insert control pannels*)  
     , ##,
     (*Hidden manipulation parameters*)
     {{vp, {1.3, -2.4, 2}, "ViewPoint"}, Dynamic[vp] &, ControlType -> None},
     {{vv, {0, 0, 1}, "ViewVertical"}, Dynamic[vv] &, ControlType -> None},
     {{va, 25 Degree, "ViewAngle"}, Dynamic[va] &, ControlType -> None},
     
     Deployed->True,
     SynchronousInitialization -> False,
     ControlPlacement -> Right,
     SynchronousUpdating -> False,
     ContinuousAction -> False] & @@ control
  ]
*)

(*CreateWindow[DialogNotebook[
    {CancelButton["Close", DialogReturn[]],*) 



(* ::Subsection::Closed:: *)
(*Plot Deformed Grid*)


PlotDefGrid[dat_?ArrayQ,phase_?ArrayQ,shiftpar_?ListQ]:=
Module[{dim,exp,data,shift,dir,label,settings,z,min,max,ps,color,maxclip,fileType,size,depth,n,str,
	minclip,transclip,gs,gf,ncol,dcol,lcol,acol,def,norm,defl,arr,pl,tab1,tab2,pannel,control,mind,maxd},
	data=N[dat];
	dim=Dimensions[data];
	shift=N[phase]*shiftpar[[1]];
	dir=shiftpar[[2]];
	
	(*Check if data is numeric array, if not exit*)
	data=dat//N;
	If[!ArrayQ[data,_,NumericQ],Return[Message[PlotData::data]]];
	
	(*See what kind of data: 2D,3D or 4D (n=1,2,3). If not one of those exit*)
	depth=ArrayDepth[data];
	If[depth>4, Return[Message[PlotData::set]]];
	n=depth-1;
		
	(*Determine data dimensions en make string displaying data dimensions*)
	dim=Dimensions[data];
	str="Displaying "<>DataString[dim];
	
	(*Initialize slice ranges and data range*)
	rangex = dim[[1]];
	rangey = dim[[2]];

	(*Rescale data between 0 and 1*)
	{mind,maxd}=If[ListQ[OptionValue[PlotRange]] && Length[OptionValue[PlotRange]]==2,OptionValue[PlotRange],{Min[data],Max[data]}];
	If[mind==maxd,maxd=mind+0.01];
	(*data=(##[data,{mind,maxd}])&@@{{ToByte2,ToByte3,ToByte4}[[n]]};*)
	
	tab1=Column[{
		ManPannel["Slice Selection",{
			{"Slice (1-"<>ToString[dim[[1]]]<>")",Control@{{z,Round[dim[[1]]/2],""},1,dim[[1]],1}}
			}]
		,
		ManPannel["Plot Range",{
			{"Show background image",Control@{{pl,True,""},{True,False}}},
			{"Min value",Control@{{min,mind,""},mind,max-0.0001,(max-mind)/100, Appearance -> "Labeled"}},
			{"Max value",Control@{{max,maxd,""},min+0.0001,maxd,(maxd-min)/100, Appearance -> "Labeled"}},
			{"Min Clipping",Control@{{minclip,Black,""},ColorSlider[#,ImageSize->{Automatic,15}]&}},
			{"Max Clipping",Control@{{maxclip,White,""},ColorSlider[#,ImageSize->{Automatic,15}]&}},
			{"Transparent Clipping",Control@{{transclip,False,""},{True,False}}}
			}]
		,
		ManPannel["Plot Options",{
			{"Grid spacing",Control@{{gs,3,""},1,10,1}},
			{"Grid size",Control@{{gf,{0.003,Medium},""},{{0.001,Tiny}->"Thin",{0.003,Medium}->"Normal",{0.005,Large}->"Thick"}}},
			{"Plot Size",Control@{{ps,400,""},psizes,ControlType->PopupMenu}},
			{"Color function",Control@{{color,"BlackToWhite",""},colors,ControlType->PopupMenu}},
			{"Plot Title",Control@{{label,"",""},InputField[#,String]&}}
			}]
		,
		ManPannel["Grid Options",{
			{"Normal grid",Control@{{norm,False,""},{True,False}}},
			{"Normal grid color",Control@{{ncol,Blue,""},ColorSlider[#,ImageSize->{Automatic,15}]&}},
			{"Deformed grid",Control@{{def,False,""},{True,False}}},
			{"Deformed grid color",Control@{{dcol,Red,""},ColorSlider[#,ImageSize->{Automatic,15}]&}},
			{"Deformation gridlines",Control@{{defl,True,""},{True,False}}},
			{"Grid color",Control@{{lcol,Green,""},ColorSlider[#,ImageSize->{Automatic,15}]&}},
			{"Deformation arrows",Control@{{arr,False,""},{True,False}}},
			{"Arrow color",Control@{{acol,Black,""},ColorSlider[#,ImageSize->{Automatic,15}]&}}
			}]
		}];
	
	tab2=Column[{
		ManPannel["Export plot",{
			{"File Type",Control@{{fileType,".jpg",""},files}},
			{"Export Size",Control@{{size,400,""},sizes,ControlType->PopupMenu}},
			{"Export",Button["Save Plot",SaveImage[Dynamic[exp],FileType->fileType,ImageSize -> size],Method->"Queued",ImageSize->150]}
			}]
		}];
	
	control={{{pannel,1,""},{1->"Plotting options",2->"Exporting options"}},Delimiter,PaneSelector[{1->tab1,2->tab2},Dynamic[pannel]]};
	
	Manipulate[
		If[!ListQ[data],Return[]];
		
		settings={{dim,dir},{min,max},label,ps,color,{gs,gf,ncol,dcol,lcol,acol},{def,norm,defl,arr,pl}};
		exp=PlotDefi[data[[z]],shift[[z]],{dim,dir},{mind,maxd,min,max},LabelFunc[label,{z}],ps,color,If[transclip,Transparent,{minclip,maxclip}],{gs,gf,ncol,dcol,lcol,acol},{def,norm,defl,arr,pl}]
		,##,
		(*Manipulate function options*)
		ControlPlacement->Right,
		Deployed->True
		]&@@control
	]


(* ::Subsection:: *)
(*MakeSliceImages*)


(* ::Subsubsection::Closed:: *)
(*MakeSliceImages*)


Options[MakeSliceImages]={
	PlotRange->Automatic, 
	ColorFunction->"GrayTones", 
	ImageLegend->False,
	ImageOrientation->Automatic,
	ImageSize->300
};

SyntaxInformation[MakeSliceImages]={"ArgumentsPattern"->{_,_.,_.,OptionsPattern[]}};

MakeSliceImages[selData_,opts:OptionsPattern[]]:=MakeSliceImages[selData,{1,1,1},opts]

MakeSliceImages[selData_,{selMask_,vals_?ListQ},opts:OptionsPattern[]]:=MakeSliceImages[selData,{selMask,vals},{1,1,1},opts]

MakeSliceImages[selData_,vox:{_,_,_},opts:OptionsPattern[]]:=MakeSliceImages[selData,{0,{}},vox,opts]

MakeSliceImages[selData_,{selMask_,vals_?ListQ},vox:{_,_,_},OptionsPattern[]]:=Block[{
	colo, pdat,ran,ratio,datf,size,colF,mdat,rule,bar,pl1,pl2, 
	dim, dim1, dim2, d1, d2, pl ,ml, sz, n, imSize
	},
	
	rule=Thread[N[vals]->Range[Length[vals]]];
	colo=OptionValue[ColorFunction];
	
	colF = If[MemberQ[colorFunctions[[All,1]], colo],colo,"GrayTones"]/.colorFunctions;
	
	Table[
		(*get the data*)
		pdat=N@selData[[n]];
		mdat=N@If[selMask=!=0,N[selMask[[n]]]/.rule,0 pdat];
		
		(*find the range*)
		datf=DeleteCases[Flatten[pdat][[;;;;10]],0.];
		ran=If[OptionValue[PlotRange]===Automatic,If[datf==={},{0,1},{0,Quantile[DeleteCases[Flatten[pdat][[;;;;10]],0.],.99]}],OptionValue[PlotRange]];
		
		size=vox[[{{2,3},{1,2},{1,3}}[[n]]]];
		bar=BarLegend[{colF/@Range[0,1,.01],ran},LabelStyle->Directive[{Black,Bold,12}]];
		
		imSize=OptionValue[ImageSize];

		(*loop over the slices, 1 axial, 2 cor, 3 sag*)
		MapThread[(
			dim = {dim1,dim2} =  Dimensions[#1];
			{d1,d2} = (dim size);
			ratio = N[Divide@@(dim size)];

			{pl, ml, ratio, sz} = Switch[OptionValue[ImageOrientation],
				"Horizontal", 
				If[d2 <= d1, {Reverse@Transpose@#1,Reverse@Transpose@#2,1/ratio, {imSize, Automatic}}, {#1,#2,ratio, {imSize, Automatic}}], 
				"Vertical", 
				If[d1 <= d2, {Reverse@Transpose@#1,Reverse@Transpose@#2,1/ratio, {Automatic,imSize}}, {#1,#2,ratio, {Automatic,imSize}}],
				_,
				If[d1 <= d2, {#1,#2,ratio, {imSize, Automatic}}, {#1,#2,ratio, {Automatic, imSize}}] 
			];
			
			pl1 = ArrayPlot[pl, AspectRatio->ratio,Frame->False,ImageSize->sz, PlotRangePadding->1, PlotRange->ran,ColorFunction->colF,ClippingStyle->(colF/@{0,1})];
			pl2 = ArrayPlot[ml, ColorFunction->(Directive[{Opacity[0.4],ColorData["Rainbow"][#]}]&),ColorRules->{0.->Transparent}];
			If[OptionValue[ImageLegend],Legended[Show[pl1,pl2],bar],Show[pl1,pl2]]
		)&,{pdat,mdat}]
	,{n,1,3}]
]


(* ::Subsubsection::Closed:: *)
(*GetSliceData*)


SyntaxInformation[GetSliceData]={"ArgumentsPattern"->{_,_,_.}};

GetSliceData[data_,offsets_]:=GetSliceData[data,offsets,{1,1,1}]

GetSliceData[data_,offsets_,vox_]:=Block[{off},
	off=Round[offsets/vox];
	{data[[off[[1]]]],
	Reverse/@Transpose@data[[All,off[[2]]]],
	Reverse/@Transpose[data[[All,All,off[[3]]]],{2,3,1}]
	}
]


(* ::Subsubsection::Closed:: *)
(*GetSlicePosision*)


Options[GetSlicePositions]={ MakeCheckPlot->False, DropSlices->{1,1,1}, PeakNumber->{1,1,2}};

SyntaxInformation[GetSlicePositions]={"ArgumentsPattern"->{_,_.,OptionsPattern[]}};

GetSlicePositions[data_, opts:OptionsPattern[]]:=GetSlicePositions[data, {1,1,1},opts]

GetSlicePositions[data_,vox_,OptionsPattern[]]:=Block[{
	dat,peaks,len,fil,ran,pers,min,max,result,num,s1,s2,s3,mid,mn,tot},
	(*get the max intensity slice*)
	pers={{2,3},{1,3},{1,2}};
	{s1,s2,s3}=OptionValue[DropSlices];
	
	(*find slice positions*)
	result=(
		(*get the range and max number of locations*)
		ran=OptionValue[DropSlices][[#]];
		num=OptionValue[PeakNumber][[#]];
		
		(*remove slices if needed*)
		dat=Switch[#,
			1,data[[All,s2;;-s2,s3;;-s3]],
			2,data[[s1;;-s1,All,s3;;-s3]],
			3,data[[s1;;-s1,s2;;-s2,All]]
		];
		
		(*get the data profile*)
		(*dat=MeanNoZero@Flatten[dat,pers[[#,1;;2]]];*)
		
		mn = MeanNoZero@Flatten[dat, pers[[#,1;;2]]];
		tot = Total@Flatten[dat, pers[[#,1;;2]]];
		dat = Rescale[mn] + 0.5 Rescale[tot];
		
		(*constrain and filter data*)
		len = Length[dat];
		dat[[;;ran]] = 0;
		dat[[-ran;;]] = 0;
		fil = Clip[len/50., {2, Infinity}];
		dat = Rescale@GaussianFilter[dat, fil];

		(*find the peak locations and select the ones above treshhold*)
		peaks = FindPeaks[dat, fil];
		peaks = Select[peaks, #[[2]]>0.5&];
		
		(*select peaks closes to center*)
		mid = {len,1}/2.;
		num=Min[{Length[peaks],num}];
		Join[{dat, peaks, mid},If[num===0,
				{{},{}},
				peaks=Nearest[peaks,mid,num];
				{peaks,peaks[[All,1]]}
			]
		]
	)&/@{1,2,3};
	
	(*make chekc plot if needed*)
	If[OptionValue[MakeCheckPlot],Print[Row[Show[
		ListLinePlot[#[[1]],PlotStyle->Black],ListPlot[#[[2]],PlotStyle->Directive[{PointSize[Large],Red}]],
		ListPlot[#[[4]],PlotStyle->Directive[{PointSize[Large],Green}]],
		ListPlot[{#[[3]]},PlotStyle->Directive[{PointSize[Large],Blue}]]
	,Axes->True,ImageSize->200
	]&/@result]]];
	
	(*give te location in mm*)
	vox result[[All,-1]]
]


(* ::Subsection::Closed:: *)
(*PlotContour*)


Options[PlotContour] = {
   ContourColor -> Gray,
   ContourOpacity -> 0.5,
   ContourColorRange -> Automatic,
   ColorFunction -> "SunsetColors",
   ContourSmoothing -> None
   };

SyntaxInformation[PlotContour] = {"ArgumentsPattern" -> {_, _., OptionsPattern[]}};

PlotContour[dati_, opts:OptionsPattern[]]:=PlotContour[dati, {1,1,1}, opts]

PlotContour[dati_, vox_, opts:OptionsPattern[]] := Block[{
		data, smooth, color, opac, dim , pad, col, style, crp,
		ran, coldat, colfunc
	},

	If[ArrayDepth[dati]===4, 
		Show[PlotContour[#, vox, opts]&/@Transpose[dati]]
		,
		smooth = OptionValue[ContourSmoothing];
		color = OptionValue[ContourColor];
		opac = OptionValue[ContourOpacity];

		dim = Dimensions@dati;
		pad = 10;
		data = ArrayPad[dati, pad];
		If[IntegerQ[smooth], data = GaussianFilter[data, smooth]];

		{data, crp} = AutoCropData[data];

		col = If[ColorQ[color], color, If[color==="Random", RandomColor[], GrayLevel[1.]]];
		style = Directive[{Opacity[opac], col, Specularity[Lighter@Lighter@col, 5]}];

		colfunc = If[! ArrayQ[color],
			Automatic,
			ran = OptionValue[ContourColorRange];
			ran = If[ran === Automatic,
				Quantile[DeleteCases[N@Flatten[color], 0.], {0.02, 0.98}],
				ran];
			coldat = Rescale[color, ran];
			Function[{z, y, x},
				ColorData[OptionValue[ColorFunction]][
				coldat[[Clip[Round[x], {1, dim[[3]]}], 
				Clip[Round[y], {1, dim[[2]]}], Clip[Round[z], {1, dim[[1]]}]]]]
			]
		];

		ListContourPlot3D[data,
			Contours -> {0.5},
			Mesh -> False, BoundaryStyle -> None, Axes -> True, 
			SphericalRegion -> True,
			ColorFunctionScaling -> False, ColorFunction -> colfunc,
			ContourStyle -> style, Lighting -> "Neutral",

			ImageSize -> 300,
			DataRange -> Reverse[Partition[crp, 2]] - pad,(*Transpose[{{0, 0, 0} - pad, Reverse[dim + pad]}],*)
			BoxRatios -> Reverse[vox dim],
			PlotRange -> Transpose[{{0, 0, 0}, Reverse[dim]}]
		]
	]
]


(* ::Subsection:: *)
(*General Plot Functions*)


(* ::Subsubsection::Closed:: *)
(*PlotCorrection*)


SyntaxInformation[PlotCorrection] = {"ArgumentsPattern" -> {_}};

PlotCorrection[w_]:=Module[{sel},
	Switch[
		Dimensions[w][[2]],
		6,
		GraphicsGrid[Partition[MapThread[
		ListPlot[#1,PlotRange->Full,Joined->True,PlotLabel->Style[#2,Bold],AspectRatio->.5,PlotStyle->Thick]&,
		{
			(({1,1,1,1,1,1}*Transpose[w])+{0,0,0,0,0,0})[[#]]&/@{1,2;;3,4;;5,6},
			{"Rotation [Degree]","Translation [mm]","Scale","Scew "},
			{{-3,3},{-4,4},{.95,1.05},{-.05,.05}}
			}],2],ImageSize->600]
		,
		12,
		sel=If[Mean[w][[7;;12]]==={1.,1.,1.,0.,0.,0.},2,4];
		
		Grid[Partition[
			MapThread[
				ListLinePlot[#1, PlotLabel -> Style[#2, Bold], PlotLegends -> #3,
					PlotRange -> {{1,Length[#1[[1]]]},Full},AxesOrigin->{1,Mean[#4]}, AspectRatio -> .5, PlotStyle -> (Directive[{Thick,#}]&/@{Red,Green,Blue}),
					AxesStyle->Directive[{Thick,Black}],LabelStyle->Directive[{Bold,Black,FontFamily->"Helvetica"}],
					ImageSize -> 400, AxesOrigin -> #5
					] &, {
						({1, 1, 1, 1}*Partition[Transpose[w], 3]) + {0, 0, 0, 0},
						{"Rotation [Degree]", "Translation [mm]", "Scale", "Scew "},
						{{"Coronal axis (roll)", "Sagital axis (pitch)","Axial axis (yaw)"},
						{"Coronal direction", "Sagital direction", "Axial direction"},
						{"Coronal direction", "Sagital direction", "Axial direction"},
						{"Coronal direction", "Sagital direction", "Axial direction"}},
						{{-3, 3}, {-4, 4}, {.95, 1.05}, {-.05, .05}},
						{{0, 0}, {0, 0}, {0, 1}, {0, 0}}
					}[[All,;;sel]]], 2]]
		]
]


(* ::Subsubsection::Closed:: *)
(*ListSpherePlot*)


Options[ListSpherePlot] = {SphereSize->2, SphereColor->Automatic}

SyntaxInformation[ListSpherePlot] = {"ArgumentsPattern" -> {_, OptionsPattern[]}};  

ListSpherePlot[ptsi_, OptionsPattern[]] := Module[{cols, graphics, pt, pc, ran, len,coli,size},
 	coli = OptionValue[SphereColor];
 	size = OptionValue[SphereSize];
 	
  len = Length[ptsi];
  ran = RandomSampleFix[len];
  cols = If[coli === Automatic,
    (ColorData[1] /@ N[Range[1, len]])[[ran]],
    ConstantArray[coli, len]
    ];

  graphics = MapThread[(pt = #1; pc = #2;
      If[ArrayDepth[pt] == 1,
       {pc, Sphere[pt, size]},
       {pc, Sphere[#, size]} & /@ pt
       ]) &, {ptsi, cols}];
  Graphics3D[Flatten[graphics], Lighting -> "Neutral"]
  ]

RandomSampleFix[len_] := RandomSampleFix[len] = RandomSample[Range[len]];


(* ::Subsubsection::Closed:: *)
(*PlotDuty*)


SyntaxInformation[PlotDuty] = {"ArgumentsPattern" -> {{_,_,_},_.}};

PlotDuty[{grad_, bval_, ord_}, mode_:True] := 
 Module[{grads, order, testgr, mn, ran},
  grads = Abs[grad*Sqrt[bval]];
  grads = If[NumberQ[bval], grads, Flatten[grads, 1]];
  grads = (grads - Min[grads])/(Max[grads] - Min[grads]);
  ran = MinMax[grads];
  order = If[! mode, Range[Length[grads]], ord];
  testgr = Mean[Transpose[Partition[#, 10, 1]]] & /@ Transpose[grads[[order]]];
  mn = Max /@ Transpose@testgr;
  Show[
   ListLinePlot[testgr, PlotLabel -> "Average Gradient Load", 
    AxesStyle -> Directive[{Thick, Black}],
    LabelStyle -> 
     Directive[{Black, Bold, 12, FontFamily -> "Helvetica"}],
    Ticks -> {Automatic, {{0.1, "Min G"}, {.55, "Avrg. G"}, {1, 
        "Max G"}}}, PlotRange -> {0, 1},
    GridLines -> {None, {00.1, 0.55, 
       1, {Max@mn, Directive[Red, Thick]}}}
    ],
   ListLinePlot[mn, PlotStyle -> Directive[Black, Dashed, Thick]]
   ]
  ]
  



(* ::Subsubsection::Closed:: *)
(*GradientPlot*)


Options[GradientPlot] = {PlotSpace -> "bspace", PlotColor -> "Auto", SphereSize -> 0.05 , PositiveZ -> False};

SyntaxInformation[GradientPlot] = {"ArgumentsPattern" -> {_, _., OptionsPattern[]}};

(*GradientPlot[bmat_,opts:OptionsPattern[]]:=Block[{vec,val},
	{val,vec}=BmatrixInv[bmat];
	GradientPlot[vec,val,opts]]*)

GradientPlot[veci_, val_, OptionsPattern[]] := 
 Block[{pts, range, norm, mnorm, cnorm, col, pcol, vec}, 
 	
  vec = If[OptionValue[PositiveZ],
  	SignNoZero[#[[3]]]#&/@veci,
  	veci
  ];
  
  pts = Switch[OptionValue[PlotSpace], 
  	"bspace", vec val, 
  	"qspace", vec Sqrt[val]
  	];
  norm = Norm /@ pts;
  mnorm = Max[Abs[pts]];
  cnorm = norm/(1.25 Max[norm]);
  
  range = ConstantArray[{-1.1, 1.1} mnorm, 3];
  col = OptionValue[PlotColor];
  
  pcol = If[MemberQ[ColorData["Gradients"], col],
    ColorData[col],
    If[ColorQ[col],
     col &,
     ColorData["SunsetColors"]
     ]
    ];
  
  Graphics3D[MapThread[
    {pcol[#2], Sphere[#1, OptionValue[SphereSize] mnorm]} &,
    {pts, cnorm}], ImageSize -> 400, BoxStyle -> Thick, 
   SphericalRegion -> True, Lighting -> "Neutral", BoxRatios -> 1, 
   PlotRange -> range]]



(* ::Subsubsection::Closed:: *)
(*PlotMoments*)


SyntaxInformation[PlotMoments] = {"ArgumentsPattern" -> {_, _, _}};

PlotMoments[fmom_, te_, t_] := Module[{
   plab, rlab, cols, alabs, grnr, fun, max, len, sc, lens
   },
  
  plab = {"Gx", "Gy", "Gz"};
  rlab = {"Gradients", "Zeroth order moment", "First order moment", "Second order moment", "Third order moment"};
  cols = {Black, Red, Purple, Blue, Green};
  alabs = {
    "mT \!\(\*SuperscriptBox[\(m\), \(-1\)]\)",
    "mT \!\(\*SuperscriptBox[\(m\), \(-1\)]\) \!\(\*SuperscriptBox[\(ms\), \(-1\)]\)",
    "mT \!\(\*SuperscriptBox[\(m\), \(-1\)]\) \!\(\*SuperscriptBox[\(ms\), \(-2\)]\)",
    "mT \!\(\*SuperscriptBox[\(m\), \(-1\)]\) \!\(\*SuperscriptBox[\(ms\), \(-3\)]\)",
    "mT \!\(\*SuperscriptBox[\(m\), \(-1\)]\) \!\(\*SuperscriptBox[\(ms\), \(-4\)]\)"
    };
  
  plots = MapIndexed[(
     grnr = #2[[1]];
     Column[
      Prepend[MapIndexed[(
          fun = #1;
          max = Max[Abs[Table[fun, {t, 0, te, .25}]]];
          len = IntegerLength[Round[max]] - 1;
          
          If[len <= 1,
           sc = 1;
           lens = "";
           ,
           sc = 10^len;
           lens = ToString[Superscript[10, len], StandardForm];
           ];
          
          Plot[fun/sc, {t, -.1 te, 1.5 te}, 
           PlotRange -> {{0, te}, 1.1 {-max, max}/sc}, 
           Exclusions -> None,
           AspectRatio -> .15, ImageSize -> 800, 
           PlotStyle -> Directive[{cols[[grnr]], Thick}],
           AxesLabel -> {"ms", lens <> " " <> alabs[[grnr]]}, 
           PlotLabel -> plab[[#2[[1]]]], 
           LabelStyle -> Directive[Black, Bold, FontFamily -> "Arial"]]
          ) &, #1],
       Style[rlab[[grnr]], Directive[Black, Bold, FontFamily -> "Arial"]]],
      Alignment -> Center]
     ) &, fmom];
     
     Manipulate[
     	pl=plots[[(n+1)]],
     	
     	 {{n,0,"Moment"}, 0, Length[plots]-1, 1},
     	 Button["Save Image",SaveImage[pl], Method -> "Queued"]
     	 ]
  ]


(* ::Subsubsection::Closed:: *)
(*PlotIVIM*)


Options[PlotIVIM] = {Method -> "", PlotColor -> {Red, Green, Blue, Black}, NormalizeIVIM->"Fit",PlotRange->"Auto",ImageSize->400}

SyntaxInformation[PlotIVIM] = {"ArgumentsPattern" -> {_, _, _, OptionsPattern[]}};

PlotIVIM[val_, data_, bvals_, OptionsPattern[]] := 
 Module[{pdat, pdatL, rule, stdash, stsol, lstyle, pl, vals = val, 
   func, cols, s0, f1, dc, pdc1, f2,f3, pdc2, bm,plr},
  DynamicModule[{plot},
   cols = OptionValue[PlotColor];
   cols = If[Length[cols] != 4, {Red,Darker@ Green, Blue, Black}, cols];
   
   If[OptionValue[NormalizeIVIM]==="Fit",
   pdatL = {bvals, Log[data/vals[[1]]]} // Transpose;
   pdat = {bvals, data/vals[[1]]} // Transpose;
   vals[[1]] = 1;
   ,
   pdatL = {bvals, Log[data/data[[1]]]} // Transpose;
   pdat = {bvals, data/data[[1]]} // Transpose;
   vals[[1]] = vals[[1]]/data[[1]];
   ];
   
   stdash = Directive[{Thick, #, Dashed}] &;
   stsol = Directive[{Thick, #}] &;
   lstyle = Directive[Black, Bold, If[OptionValue[ImageSize]<=200,Small,Medium], FontFamily -> "Helvetica"];
   
   Switch[Length[vals],
   	2,
    func = s0(f3*Exp[-bm*dc]);
 	rule = Flatten@Append[Thread[{s0, dc} -> vals], {f2 -> 0,f1->0}];,
    4,
    func = s0(f3*Exp[-bm*dc] + f1*Exp[-bm*pdc1]);
 	rule = Append[Thread[{s0, f1, dc, pdc1} -> vals], f2 -> 0];,
    6,
    func = s0(f3*Exp[-bm*dc] + f1*Exp[-bm*pdc1] + f2*Exp[-bm*pdc2]);
    rule = Thread[{s0, f1, f2, dc, pdc1, pdc2} -> vals];,
    _,
    Return[Message[PlotIVIM::vals]]];
   
   plr=If[OptionValue[PlotRange]==="Auto",{1.2 Min[pdatL[[All,2]]], 0.1},OptionValue[PlotRange]];
   
   pl = Plot[#6 /. {f1 -> #1, f2 -> #2, f3->#3} /. rule, {bm, -0.1, #5}, 
      PlotStyle -> ({stdash[#4[[1]]], stsol[#4[[1]]]}[[#4[[2]]]]), 
      PlotRange -> ({{0, 1.1}, plr }[[#7]]), 
      LabelStyle -> lstyle, Frame -> {{True, False}, {True, False}}, 
      FrameStyle -> Thick, ImageSize -> OptionValue[ImageSize], 
      FrameLabel -> {"b-value [\!\(\*SuperscriptBox[\(mm\), \(2\)]\)/s]", {"Signal", "Log[Signal]"}[[#7]]}] &;
      
   plot = GraphicsRow[{
       Show[
        pl[f1, f2, 1-f1-f2, {cols[[4]], 2}, #, func, 1],
        pl[1-f2, 0, 0, {cols[[1]], 1}, #, func, 1],
        pl[0, 1, 0, {cols[[2]], 1}, #, func, 1],
        pl[0, 0,  1-f1-f2, {cols[[3]], 1}, #, func, 1],
        ListPlot[pdat, PlotStyle -> {cols[[4]], PointSize[0.02]}]
       ],
       Show[
        pl[f1, f2, 1-f1-f2, {cols[[4]], 2}, #, Log[func], 2],
        pl[1-f2, 0, 0, {cols[[1]], 1}, #, Log[func], 2],
        pl[0, 1, 0, {cols[[2]], 1}, #, Log[func], 2],
        pl[0, 0, 1-f1-f2, {cols[[3]], 1}, #, Log[func], 2],
        ListPlot[pdatL, PlotStyle -> {cols[[4]], PointSize[0.02]}]
        ]
       }] &;
   
   If[OptionValue[Method] === "Dynamic",
    Manipulate[plot[bran],{{bran, 1.1 Max[bvals], "Plot Range"}, 10, 1.5 Max[bvals], 10},SaveDefinitions -> True],
    plot[Max[bvals]]
    ]
   ]
  ]


(* ::Subsubsection::Closed:: *)
(*PlotSequence*)


SyntaxInformation[PlotSequence] = {"ArgumentsPattern" -> {_, _}};

PlotSequence[(*{seq_,hw_,te_}*)inp_, t_] := DynamicModule[{
	hw1, Gx, Gy, Gz, seq2, len, pdat, seq, te, start, stop, x, clip, plots
	},
  
  {len, pdat} = If[Dimensions[inp] === {3}, {1, {inp}}, {Length[inp], inp}];
  te = Last@First@pdat;
  hw1 = Piecewise[{{1, t <= te}, {0, t > te}}];
  seq = {PiecewiseExpand[#[[1]]], PiecewiseExpand[hw1 #[[1]]]} & /@ pdat;
  
  plots = Map[(
      seq2 = #;
      Plot[seq2[[#]],
         {t, -0.5 te, 1.5 te}, PlotRange -> {-100, 100}, 
         PlotStyle -> {Thick, Black}, Exclusions -> None,
         AspectRatio -> .15, ImageSize -> 1000, 
         PlotPoints -> Round[te/.25],
         Axes -> False, Frame -> True, 
         FrameTicks -> {{None, None}, {Range[0, 150, 10], None}},
         PlotLabel -> {"Gx", "Gy", "Gz"}[[#]], 
         LabelStyle -> {FontFamily -> "Helvetica", Bold},
         GridLines -> {{{0, Directive[Red, Thick]}, {te/2, 
             Directive[Red, Thick]}, {te, 
             Directive[Red, Thick]}}, {0}}] & /@ Range[3]
      ) &, seq, {2}];
  
  Manipulate[
   
   Column[(Show[plots[[x, clip, #]], PlotRange -> ({{start, stop}, {{-Gx, Gx}, {-Gy, Gy}, {-Gz, Gz}}[[#]]})]) & /@ Range[3]],
   
   {{x, 1, "Sequence"}, 1, len, 1, Appearance -> "Labeled"},
   {{clip, 1, "Clip the te"}, {1 -> "False", 2 -> "True"}},
   
   {{Gx, 90, "Gx"}, 5, 100, 10, Appearance -> "Labeled"},
   {{Gy, 90, "Gy"}, 5, 100, 10, Appearance -> "Labeled"},
   {{Gz, 90, "Gz"}, 5, 100, 10, Appearance -> "Labeled"},
   
   {{start, Round[-0.07 te], "Time start"}, Round[-0.07 te], Round[.5 te], Appearance -> "Labeled"},
   {{stop, Round[1.15 te], "Time end"}, Round[0.5 te], Round[1.20 te], Appearance -> "Labeled"}
   ]
]


(* ::Subsection::Closed:: *)
(*ColorFAPlot*)


SyntaxInformation[ColorFAPlot] = {"ArgumentsPattern" -> {_}};  
  
ColorFAPlot[tens_] := Block[{FA, eig, eigv, mid, eigFA, mask},
	{eig, eigv} = EigensysCalc[tens];
	mask = Mask[tens[[1]], 10^-6];
	
	eigv = mask Abs[eigv];
	FA = FACalc[eig];
	eigFA = mask FA eigv;
	
	DynamicModule[{colEigFA, colEig, im},
		colEigFA = Table[Image[eigFA[[j, All, All, i]], ColorSpace -> "RGB"], {j, 1, Length[eigv]}, {i, 1, 3}];
		colEig = Table[Image[eigv[[j, All, All, i]], ColorSpace -> "RGB"], {j, 1, Length[eigv]}, {i, 1, 3}];
		
		Manipulate[
			im = GraphicsRow[{colEig, colEigFA}[[i, j, sel]], ImageSize -> Length[sel]*size],
				
			{{j, Round[Length[colEig]/2], "slice"}, 1, Length[colEig], 1},
			{{i, 2, "method"}, {1 -> "raw", 2 -> "FA"}},
			{{sel, {1, 2, 3}, "eigenvectors"}, {1 -> "first", 2 -> "second", 3 -> "third"}, ControlType -> TogglerBar},
			Button["save image", SaveImage[im], Method -> "Queued"],
			{{size, 300, "image size"}, {200, 300, 400, 600, 1000}}
		]
	]
]


(* ::Section:: *)
(*End Package*)


End[]

EndPackage[]
