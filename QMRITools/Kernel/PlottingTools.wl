(* ::Package:: *)

(* ::Title:: *)
(*QMRITools PlottingTools*)


(* ::Subtitle:: *)
(*Written by: Martijn Froeling, PhD*)
(*m.froeling@gmail.com*)


(* ::Section:: *)
(*Begin Package*)


BeginPackage["QMRITools`PlottingTools`", Join[{"Developer`"}, Complement[QMRITools`$Contexts, {"QMRITools`PlottingTools`"}]]];


(* ::Section:: *)
(*Usage Notes*)


(* ::Subsection::Closed:: *)
(*Functions*)


PlotData::usage =
"PlotData[data] plots the data.
PlotData[data, vox] plots the data and for 3D and 4D data assumes the voxelsize vox (z,x,y).
PlotData[data1, data2] plots data1 and data2.
PlotData[data1, data2, vox] plots data1 and data2 and for 3D and 4D data assumes the voxelsize vox (z,x,y)."

PlotData3D::usage = 
"PlotData3D[data,vox] is a 3D dataviewer, data is the 3D dataset and voxsize the size of the voxels in mm (z,x,y)."

PlotDefGrid::usage =
"PlotDefGrid[data, phasemap, shiftpar] plots the dataset on the background with on top the non deformed and the deformed grid, or arrows or lines."


GetSlicePositions::usage =
"GetSlicePositions[data] finds the position of slices with the maximal signal in voxel index.
GetSlicePositions[data, vox] find the position of slices with the maximal signal in mm."

GetSliceData::usage =  
"GetSliceData[data, offsets] gets the slices from the data defined by offsets which are obtained by GetSlicePosisions.
GetSliceData[data, offsets, vox] gets the slices from the data defined by offsets which are obtained by GetSlicePosisions in mm.
The offsets can also be provided manually which is {{AX,..},{COR,..},{SAG,..}}."

MakeSliceImages::usage =  
"MakeSliceImages[imgData] generates images from the imgData which is obtained form GetSliceData.
MakeSliceImages[imgData, vox] generates images from the imgData which is obtained form GetSliceData, vox is used for the correct aspect ratio of the images.
MakeSliceImages[imgData, {labData, labels}] generates images from the imgData which is obtained form GetSliceData with an overlay of the segmentations in labData, which can also be obtained using GetSliceData on the segmentations.
labels should be the label numbers used in the original segmentation (to allow correct scaling between slices).
MakeSliceImages[imgData, {labData, labels},vox] generates images from the imgData which is obtained form GetSliceData with an overlay of the segmentations in labData, which can also be obtained using GetSliceData on the segmentations, vox is used for the correct aspect ratio of the images."

LegendImage::usage =
"LegendImage[colf, w, lab] generates a legend image for the color function colf with a width of w and labels lab."


PlotContour::usage = 
"PlotContour[data, vox] creates a contour of the data. 
The data can be 3D or 4D, when its 4D each contour is given a random color."

PlotSegmentations::usage = 
"PlotSegmentations[seg, vox] crates a contour of each of the segmentations in seg. Uses PlotContour.
PlotSegmentations[seg, bone, vox] same but also generates an extra contour with the bones in gray."

Link3DGraphic::usage =
"Link3DGraphic[3Dgraphics] creates a 3D graphic with a linked view options between all 3D graphics that have been linked."

ShowLink::usage =
"ShowLink[] shows the linked view options between all 3D graphics that have been linked."

GenerateRotationFrames::usage =
"GenerateRotationFrames[3Dgraphics, nFrames] generates nFrames of the 3D graphics rotating around the z-axis."

PlotCorrection::usage = 
"PlotCorrection[w] plots deformation vectors w {w1,w2..} generated by Registration2D and Registration3D for multiple datasets or registration steps."

ListSpherePlot::usage =
"ListSpherePlot[points] plots 3D points as spheres."

GradientPlot::usage = 
"GradientPlot[bvec, bval] plots the given bvec with position of the gradients scaled according to the bval."

PlotDuty::usage = 
"PlotDuty[{grad, bval, ord}, mode] plot the gradient dutycycle."

PlotMoments::usage = 
"PlotMoments[{G(t),..}, te, t] plots the moments generated by CalculateMoments."

PlotIVIM::usage = 
"PlotIVIM[vals, data, bvals] plots the results of the IVIM fits from IVIMCalc or BayesianIVIMFit2 or Baye."

PlotSequence::usage = 
"PlotSequence[seq,var] where seq is the output from GradSeq."


LoessPlot::usage =
"LoessPlot[data] plots the data with a loess fit."

ColorFAPlot::usage = 
"ColorFAPlot[tenor] create a color coded FA map from the tensor for l1, l2 and l3."


(* ::Subsection::Closed:: *)
(*Options*)


ContourColor::usage = 
"ContourColor is an option for PlotContour. It specifies the contour color and can be a single color or an array with the same dimensions as the data."

ContourOpacity::usage = 
"ContourOpacity is an option for PlotContour and PlotSegmentations. It specifies the opacity of the contour."

ContourSpecularity::usage =
"ContourSpecularity is an option for PlotContour. It specifies the specularity of the contour."

ContourColorRange::usage = 
"ContourColorRange is an option for PlotContour. If the ContourColor is an array this values gives the plot range."

ContourScaling::usage = 
"ContourScaling is an option for PlotCountour. The value can be \"World\" or \"Voxel\", if the value is \"Wold\" the segmentation is in mm else in voxel coordinates."

ContourSmoothRadius::usage = 
"ContourSmoothRadius is and option for PlotContour. It defines the smoothing radius with an integer, None or 0 does not smooth."

ContourResolution::usage = 
"ContourResolution is an option for PlotContour. It defines the mesh resolution used, can be a singel number or a list of 3 numbers."

RandomizeColor::usage = 
"RandomizeColor is an option for PlotSegmentations. If True the colors are randomly assigened to each segmentation."


MakeCheckPlot::usage = 
"MakeCheckPlot is an option for GetSlicePositions and if set true gives a plot of the slices locations."

DropSlices::usage = 
"DropSlices is an option for GetSlicePositions and specifies how many slices from the beginning and and should be ignored."

PeakNumber::usage = 
"PeakNumber is an option of GetSlicePostitions and specifies how many slices per direction need to be found."

ImageLegend::usage = 
"ImageLegend is an option for MakeSliceImages, if set true a barlegend is added to the image."

ImageOrientation::usage = 
"ImageOrientation is an option for MakeSliceImages. Can be Automatic, \"Vertical\" or \"Horizontal\"."

MaskOpacity::usage =
"MaskOpacity is an option for MakeSliceImages. It specifies the opacity of the mask."


Bandwidth::usage =
"Bandwidth is an option for LoessPlot. It specifies the bandwidth of the loess fit. Its a number between 0 and 1 and specifies which % of the data to include for the local regression."

PredictionInterval::usage =
"PredictionInterval is an option for LoessPlot. It specifies the prediction interval of the loess fit. If True it uses the prediction confidence bands if False it uses the standard error of the local mean."

FitKernel::usage =
"FitKernel is an option for LoessPlot. It specifies the kernel used for the loess fit. Can be \"Triangular\" or \"Gaussian\"."


PlotSpace::usage = 
"PlotSpace is an option for GradientPlot can be \"bspace\" or \"qspace\"."

PlotColor::usage = 
"PlotColor is an option for GradientPlot can be any color or gradient color name."

NormalizeIVIM::usage = 
"NormalizeIVIM is an option for IVIMplot. If True the signal at b=0 is 1."

SphereSize::usage = 
"SphereSize is an option for GradientPlot and ListSpherePlor. Sets the size of the spheres thar represent the gradients."

SphereColor::usage = 
"SphereColor ListSpherePlor. Default value is Automatic, If a color is given this color will be used for all spheres."

PositiveZ::usage = 
"PositiveZ is an options for GradientPlot. If True all Gradients are displayed with a positive z direction."


(* ::Subsection::Closed:: *)
(*Error Messages*)


PlotData::data = "Error: Data must be a 2D, 3D or 4D numeric array."

PlotData::size = "Datasets must have the same number of slices. dataset1: `1` slices, dataset2: `2` slices. (Image dimensions may vary)."

PlotData::set = 
"Error: Not two valied datasest, posibilities:
- 2D and 2D
- 3D and 3D
- 4D and 4D
- 2D and 4D
- 2D and 4D
- 3D and 4D"

PlotData3D::data = "Data should be a 3D or 4D dataset."

PlotDefGrid::dir = "direction must be \"COL\" or \"ROW\", unknown direction: `1`."


(* ::Section:: *)
(*Functions*)


Begin["`Private`"]


(* ::Subsection:: *)
(*General Plot Functions and definitions*)


(* ::Subsubsection::Closed:: *)
(*Definitions*)


$plotOptions = {
	Axes -> False, Frame -> {{True, False}, {True, False}}, PlotHighlighting -> None, 
	FrameStyle -> Directive[Thick, Black], LabelStyle -> Directive[Black, Bold, 14]
};

(*plot menu options*)
sizes    = {200,300,400,500,750,1000,1500,2000,2500,3000};
psizes   = {100,200,300,400,500,600,700,800,900,1000};
files    = {".pdf",".jpg",".gif",".tif",".png"};
colfuncs = {"Normal","Reverse","Symmetric","Reverse Symmetric"};
labStyle = Directive[Bold,FontFamily->"Helvetica",14,Black];
ncol     = 512;


(*3D color rules and settings*)
colors3D = {Automatic -> "Automatic", "XRay", "HighRange", 
	"LowRange","WhiteBlackOpacity", "SunsetColorsOpacity", "RainbowOpacity"};
views = Thread[2*{{0.65, -1.2, 1}, {1, 0, 0}, {-1, 0, 0}, {0, 1, 0}, {0, -1, 0}, {0, 0, 1}, {0, 0, -1}} -> {"Start", "Right", "Left", "Front", "Back", "Top", "Bottom"}];


(*default gradient color functions*)
colorNames = {"GrayTones", "Rainbow", "DarkRainbow", "ThermometerColors", "SunsetColors", 
	"TemperatureMap", "LightTemperatureMap", "GrayYellowTones", "CherryTones", "SolarColors",
	"BlueGreenYellow", "AvocadoColors", "SouthwestColors",
	(*scientific color maps*)
	"Batlow", "Navia", "Bilbao", "Bamako", "Devon", "Lapaz", "Lajolla", "Lipari", "Turku", "Davos", "Managua", "Vik", "Roma", "RomaO", "VikO"
};


(*custom color functions and generate image of custom color*)
custColors = {
	"RedToWhite" -> (Blend[{RGBColor[1, 1, 1], RGBColor[.7, 0, 0]}, 1 - #]&),
	"BlackToWhite" -> (Blend[{RGBColor[1, 1, 1], RGBColor[0, 0, 0]}, 1 - #]&),
	"Flow" -> (Blend[{White, Blend[{Blue, Cyan}], Blue, Black, Red, Orange, White}, #]&),
	"Fire" -> (Blend[{Black, Blue, Purple, Red, Orange, Yellow, White}, #] &),
	"NIH" -> (Blend[{Black, Purple, Blue, Green, Yellow, Orange, Red, Darker@Darker@Red}, #] &),
	"Cardiac" -> (Blend[{Darker@Green, Cyan, Blue, Purple, Red, Yellow, Darker@Green}, #] &),
	"GEcol" -> (Blend[{Black, RGBColor[0, .22, .22], RGBColor[0, .45, .45], RGBColor[.4, .0, .9], RGBColor[.75, .25, .5], Orange, RGBColor[1, .7, .35],  White}, #] &)
};


(*generate color list and functions*)
colorFunctions = Join[# -> ColorData[#] & /@ colorNames, custColors];
	
colors = Sort@Join[
	# -> Show[ColorData[#, "Image"], ImageSize -> 100] & /@ colorNames,
	#[[1]] -> CustCol[#[[2]]] & /@ custColors
];
colors = #[[1]] -> Tooltip[#[[2]], #[[1]]] & /@ colors;

CustCol[colf_] := Graphics[Raster[{Range[100]/100.}, {{0, 0}, {1, 1}}, ColorFunction -> colf], 
	AspectRatio -> 1/8, ContentSelectable -> False, ImageSize -> 100, PlotRange -> {{0, 1}, {0, 1}}]


(* ::Subsubsection::Closed:: *)
(*ToByte*)


ToByte = Compile[{{data, _Real, 0}, {range, _Real, 1}},(data - range[[1]])/(range[[2]] - range[[1]]), RuntimeAttributes -> {Listable}, RuntimeOptions -> "Speed"];


(* ::Subsubsection::Closed:: *)
(*Clip and lookup*)


ColSel[func_, cfunc_] := With[{
	fun = Switch[func, 
		"Normal", #1&, 
		"Reverse", 1 - #1&,
		"Symmetric", Abs[2 #1 - 1]&, 
		"Reverse Symmetric", Abs[Abs[2 #1 - 1] - 1] &
	],
	cfun = cfunc /. colorFunctions
	}, cfun[fun[#]]&
]


(*generate all the color lookup tables*)
ClearAll[ColorLookup]
ColorLookup[___] = ConstantArray[Col2List[Darker[Red]], ncol];
With[{ran = Range[0, 1., 1./(ncol - 1)]},
	Table[ColorLookup[j, i] = Col2List[ColSel[j, i][#] & /@ ran], {j, colfuncs}, {i, colorFunctions[[All, 1]]}]
];

(*color lookup function, presersing clipping and transparency. It converts integers to color values*)
(*returs the color function*)
LookUpTable[{lstyle_, color_}, {minclip_, maxclip_}] := With[{
		(*generate color lookup table with correct clipping colors for min and max,add opacity for Image function*)
		collist = Join[{Col2List[minclip]},(ColorLookup[lstyle, color]),{Col2List[maxclip]}]
	}, 
	Function[{x}, Which[NumberQ[x] || VectorQ[x], collist[[x]], MatrixQ[x], collist[[#]] & /@ x]]
]


Attributes[Col2List] = {Listable};

Col2List[RGBColor[c___]] := Round[(256 - 1) PadRight[List[c], 4, 1.]]
Col2List[c_] := Col2List[RGBColor[c]]


(*converts numbers to integers for color lookup*)
(*ColorRound = ncol + 2 - Ramp[(ncol + 1) - Ramp[Round[(ncol - 1) Rescale[#1, #2]] + 1]] &*)
ColorRound = With[{
		greater = UnitStep[#2[[2]] - #1], 
		lower = UnitStep[#1 - #2[[1]]],
		scale = Round[Rescale[#1, #2, {2, ncol + 1}]]
	}, (1 - lower) + lower greater scale + (ncol + 2) (1 - greater)] &

(* ::Subsubsection::Closed:: *)
(*ManPannel*)


ManPannel[name_, cont_, depl_:True]:= Module[{controls = DeleteCases[cont, Null]},
	OpenerView[{Style[name, Bold, Medium],
		Grid[If[ArrayDepth[controls] == 1, {controls}, controls],
			Alignment -> {{Right, Left}, Center}, ItemSize -> {{13, 30}}]
	}, depl]
]


(* ::Subsubsection::Closed:: *)
(*Label Legend plot*)


LabLeg[im_, {fnts_,legs_}, label_, {legend_, color_, {min_,max_}}] := Block[{lab, bar},	
	(*generate label if needed*)
	lab = If[StringQ[label], Style[label, labStyle, TextAlignment -> Center, FontSize -> fnts]];

	(*generate legend if needed*)
	bar = If[legend,
		BarLegend[{(ColSel @@ color)[(# - min)/(max - min)] &, {min, max}}, 
			LabelStyle -> Directive[Bold, FontFamily -> "Helvetica", fnts, Black],
			LegendMarkerSize -> legs, LegendLayout -> "Column"]
	];

	(*make the image grid*)
	Grid[Which[
		StringQ[label] && legend, {{lab, ""}, {im, bar}},
		legend, {{im, bar}},
		StringQ[label], {{lab}, {im}},
		True, {{im}}
	],Spacings->{2,2}]
]


(* ::Subsubsection::Closed:: *)
(*Legend plot*)


Labeli[im_,fnts_,label_]:=Block[{lab},
	(*generate label if needed*)
	If[StringQ[label], 
		lab = Style[label, labStyle, TextAlignment -> Center, FontSize -> fnts];
		Column[{lab,im}, Alignment->Center, Spacings->2],	
		im
	]
]


(* ::Subsubsection::Closed:: *)
(*LabelFunc*)


LabelFunc[label_,{x_:Null,y_:Null}]:=Block[{labout},
labout=If[x===Null&&y===Null,
	If[!StringQ[label],"",label],
	If[y===Null,
		If[label==" "||label==""||!StringQ[label],If[label==" "," ",""],label<>" - "]<>"Slice "<>ToString[x],
		If[label==" "||label==""||!StringQ[label],If[label==" "," ",""],label<>" - "]<>"Slice "<>ToString[x]<>"-"<>ToString[y]
		]
	];
	If[labout==="",None,labout]
]


(* ::Subsubsection::Closed:: *)
(*LabelJoin*)


LabelJoin[label_]:=StringJoin[Riffle[DeleteCases[label[[{3, 1, 2}]]/. " " -> None, None], "\n"]] /. "" -> None


(* ::Subsubsection::Closed:: *)
(*PlotSize*)


PlotSize[data_, ps_, aspect_] := Block[{dsize,ratio},
	dsize = Dimensions[data]*aspect;
	ratio = N[Divide @@ dsize];
	{If[ratio>1, ps/ratio, ps], ratio}
]


(* ::Subsubsection::Closed:: *)
(*PlotSize*)


LabSize[size_,ratio_]:= { Max[12, Min[{25, Round[Max[{size, ratio size}]/15]}]], .95 ratio size }


(* ::Subsubsection::Closed:: *)
(*PlotRangeVals*)


PlotRangeVals[scale_, data_, {min_, max_}] := Block[{mindat, maxdat},
	{mindat, maxdat} = If[scale, N@Quantile[Flatten[data], {0.005, 0.995}], {min, max}];
	(*only use valid scale which is max>min*)
	If[mindat >= maxdat, {mindat, mindat + 0.001}, {mindat, maxdat}]
];


(* ::Subsubsection::Closed:: *)
(*ClipColor*)


ClipColor[{clipMin_, clipMax_}, {minCol_, maxCol_}, {lstyle_, color_}] := {
	Switch[clipMin, "Auto", ColSel[lstyle, color][0], "Custom", minCol, "Transparent", Transparent],
	Switch[clipMax, "Auto", ColSel[lstyle, color][1], "Custom", maxCol, "Transparent", Transparent]
};


(* ::Subsubsection::Closed:: *)
(*MakeImage*)


MakeImage[data_, color_, ccolor_, ran_] := Image[
	NumericArray[LookUpTable[color, ccolor][ColorRound[data, ran]], "UnsignedInteger8"], 
	"Byte", ColorSpace -> "RGB"
]


(* ::Subsubsection::Closed:: *)
(*PlotTicks*)


PlotTicks[dimy_, dimx_] := Block[{tkx, tky},
	tkx = Table[tx, {tx, 0, dimx, Which[dimx < 10, 1, dimx < 50, 5, True, Ceiling[dimx/10, 10]]}];
	tky = Table[{ty, dimy - ty}, {ty, dimy, 0, -Which[dimx < 10, 1, dimx < 50, 5, True, Ceiling[dimx/10, 10]]}];
	{{tky, tky}, {tkx, tkx}}
];


(* ::Subsubsection::Closed:: *)
(*JoinResc*)


JoinResc[data1_,data2_]:=
Module[{dim1,dim2},
	dim1=Dimensions[data1];
	dim2=Dimensions[data2];
	If[dim1==dim2,
		{data1,data2},
		If[Max[dim1]<Max[dim2],
			{RescaleImg[data1,dim2],data2},
			{data1,RescaleImg[data2,dim1]}
			]
		]
	]


RescaleImg[data_, dim_] := Block[{type},
	type = If[ArrayQ[data, _, IntegerQ], "Bit16","Real32"];
	ImageData[ImageResize[Image[data, type], Reverse[dim], Resampling -> "Gaussian"], type]
]


(* ::Subsubsection::Closed:: *)
(*DataString*)


DataString[dim_]:=ReleaseHold[{
	Hold["one image with a dimension of "<>ToString[dim[[1]]]<>"x"<>ToString[dim[[2]]]<>" voxels"],
	Hold[ToString[dim[[1]]]<>" slices with a dimensions of "<>ToString[dim[[2]]]<>"x"<>ToString[dim[[3]]]<>" voxels"],
	Hold[ToString[dim[[1]]]<>"x"<>ToString[dim[[2]]]<>" slices with a dimensions of "<>ToString[dim[[3]]]<>"x"<>ToString[dim[[4]]]<>" voxels"]
}[[Length[dim]-1]]]


(* ::Subsection:: *)
(*Export Functions*)


(* ::Subsubsection::Closed:: *)
(*MultiFileSave*)


MultiFileSave[plot_,label_,range_,type_,size_]:=
Module[{input,lab},
	input=SystemDialogInput["Directory", Directory[]];
	If[input===$Canceled,Return[Print["Export multiple files was canceled!"]]];

	Switch[Length[range],
		2,(* one 3D datasest *)
		Table[
			lab=ReleaseHold[label]/. None->"";
			pl=ReleaseHold[plot];
			SaveImage[pl,input<>lab<>type,FileType->type,ImageSize -> size];
			,{xs,range[[1]],range[[2]]}];,
		4,(* one 4D datasest *)
		Table[
			lab=ReleaseHold[label]/. None->"";
			pl=ReleaseHold[plot];
			SaveImage[pl,input<>lab<>type,FileType->type,ImageSize -> size];
			,{xs,range[[1]],range[[2]]},{ys,range[[3]],range[[4]]}];
		];

	Print["Multiple fiels were saved to: "<>input<>" as "<>type<>" files."];
]


(* ::Subsubsection::Closed:: *)
(*MovieSave*)


MovieSave[plot_,dur_,loop_,size_,range_]:=
Module[{input,movie},
	input=SystemDialogInput["FileSave", Directory[] <> $PathnameSeparator<>"*.gif"];
	If[input===$Canceled,Return[Print["Export movie was canceled!"]]];

	movie=Flatten[Switch[Length[range],
		2,(* one 3D datasest *)
		Table[Rasterize[ReleaseHold[plot],RasterSize->size],{xs,range[[1]],range[[2]]}],
		4,(* one 4D datasest *)
		Table[Rasterize[ReleaseHold[plot],RasterSize->size],{xs,range[[1]],range[[2]]},{ys,range[[3]],range[[4]]}]
		]];
	Export[input,movie,"DisplayDurations"->dur,"AnimationRepetitions"->loop,RasterSize->size, ImageResolution->150];
	Print["Movie was saved to: "<>input];
	]


(* ::Subsection:: *)
(*Plot Functions*)


(* ::Subsubsection::Closed:: *)
(*Ploti*)


Ploti[data_, ran_, label_, ps_, color_, legend_, frame_, ccolor_, aspect_] := Block[
	{size, ratio, tks, im},

	(*get range and sizes*)
	{size, ratio} = PlotSize[data, ps, aspect];
	tks = PlotTicks@@Dimensions[data];
	(*make the image*)
	im = MakeImage[data, color, ccolor, ran];
	(*Apply labes and styling*)
	LabLeg[
		Show[im, ImageSize -> size, AspectRatio -> ratio, Frame -> frame, FrameTicks -> tks], 
		LabSize[size,ratio], label, {legend, color, ran}]
]


(* ::Subsubsection::Closed:: *)
(*Plot2i*)


Plot2i[data_, minmax_, label_, ps_, color_, legend_, frame_, join_, ccolor_, aspect_, leg_]:=Block[
	{plot,fnts,legs},

	Switch[join[[1]],
		1,(*Normal side by side*)
		{fnts, legs} = Min/@Transpose[LabSize@@PlotSize[#, ps, aspect]&/@data];
		plot={
			Ploti[data[[1]], minmax[[1]], label[[1]], ps, color[[1]], legend, frame, ccolor[[1]], aspect],
			Ploti[data[[2]], minmax[[2]], label[[2]], ps, color[[2]], legend, frame, ccolor[[2]], aspect]
			};
		Labeli[Grid[{plot},Spacings->3], fnts, label[[3]]]
		,
		2(*CheckboardPlot*),
		CheckPlot[data, minmax, label, ps, color, frame, join[[2]], join[[3]], ccolor, aspect],
		3(*Opacity overlay plot*),
		OpacityPlot[data, minmax, label, ps, color, legend, frame, join[[3]], join[[4]], ccolor, aspect, leg],
		4(*Difference Plot*),
		DifferencePlot[data, minmax, label, ps, color, legend, frame, join[[3]], join[[5]], ccolor, aspect]
	]
]


(* ::Subsubsection::Closed:: *)
(*CheckPlot*)


CheckPlot[data_, ran_, label_, ps_, color_, frame_, size_, flip_, ccolor_, aspect_]:= Block[
	{a, b, pdata, pdatb, psize, ratio, ima, imb, im, check, tks},

	{a,b}=If[flip,{2,1},{1,2}];
	{pdata,pdatb}=JoinResc[data[[a]],data[[b]]];

	{psize,ratio}=PlotSize[pdata, ps,aspect];
	tks = PlotTicks@@Dimensions[pdata];

	ima = MakeImage[pdata, color[[a]], ccolor[[a]], ran[[a]]];
	imb = MakeImage[pdatb, color[[b]], ccolor[[b]], ran[[b]]];
	check = CheckBoard[Dimensions[pdata], size];

	(*make the image*)
	im = ImageCompose[ima,SetAlphaChannel[imb, check AlphaChannel[imb]]];
	(*add label and legend*)
	LabLeg[
		Show[im, ImageSize -> psize, AspectRatio -> ratio, Frame -> frame, FrameTicks -> tks], 
		LabSize[psize,ratio], LabelJoin[label], {False, color[[a]], ran[[a]]}
	]
]


(* ::Subsubsection::Closed:: *)
(*CheckBoard*)


CheckBoard[dim_, check_] := Image[Table[If[
	(OddQ[Ceiling[(i - 0.5 dim[[1]])/check]] && OddQ[Ceiling[(j - 0.5 dim[[2]])/check]]) ||
	(EvenQ[Ceiling[(i - 0.5 dim[[1]])/check]] && EvenQ[Ceiling[(j - 0.5 dim[[2]])/check]])
	, 1., 0.
], {i, 1, dim[[1]], 1}, {j, 1, dim[[2]]}]]


(* ::Subsubsection::Closed:: *)
(*OpacityPlot*)


OpacityPlot[data_, ran_, label_, ps_, color_, legend_, frame_, flip_, op_, ccolor_, aspect_, leg_]:=Block[
	{a, b, pdata, pdatb, psize, ratio, ima, imb, im, lc, lr, tks},

	{a,b}=If[flip,{2,1},{1,2}];
	{pdata,pdatb} = JoinResc[data[[a]],data[[b]]];

	{psize,ratio} = PlotSize[pdata, ps,aspect];
	tks = PlotTicks@@Dimensions[pdata];

	{rana, ranb} = ran;

	ima = MakeImage[pdata, color[[a]], ccolor[[a]], ran[[a]]];
	imb = MakeImage[pdatb, color[[b]], ccolor[[b]], ran[[b]]];

	(*make the image*)
	im = ImageCompose[ima,SetAlphaChannel[imb, op AlphaChannel[imb]]];
	(*add label and legend*)
	{lc,lr} = If[leg == 1, {color[[b]],ran[[b]]}, {color[[a]],ran[[a]]}];
	LabLeg[
		Show[im, ImageSize -> psize, AspectRatio -> ratio, Frame -> frame, FrameTicks -> tks], 
		LabSize[psize, ratio], LabelJoin[label], {legend, lc, lr}
	]
]


(* ::Subsubsection::Closed:: *)
(*DifferencePlot*)


DifferencePlot[data_,minmax_,label_,ps_,color_,legend_,frame_,flip_,range_,ccolor_,aspect_]:=Block[
	{pdat,a,b,min1,max1,min2,max2},

	{a,b} = If[flip,{2,1},{1,2}];
	{min1,max1} = minmax[[a,1;;2]];
	{min2,max2} = minmax[[b,1;;2]];

	pdat=(Subtract@@(JoinResc[data[[a]],data[[b]]]));

	(*make plot*)
	Ploti[pdat, {-1,1}range, LabelJoin[label], ps, color[[a]], legend, frame, ccolor[[a]], aspect]
]


(* ::Subsection:: *)
(*check and rewrite*)


(* ::Subsubsection::Closed:: *)
(*PlotDefi*)


PlotDefi[data_,shift_,{dim_,dir_},{min_,max_},lab_,ps_,color_,clip_,{gs_,gf_,ncol_,dcol_,lcol_,acol_},{def_,norm_,defl_,arr_,pl_}]:=
Module[{normGrid,deffGrid,pos,dcor,ncor,points,lines,arrows,head,plot},

	normGrid=Table[{j-0.5,-(i-dim[[2]])+0.5},{i,1,dim[[2]],gs},{j,1,dim[[3]],gs}];

	deffGrid=Table[
		If[dir=="ROW",{j-shift[[i,j]]-0.5,-(i-dim[[2]])+0.25},
		If[dir=="COL",{j-0.5,-(i-shift[[i,j]]-dim[[2]])+0.25}]]
		,{i,1,dim[[2]],gs},{j,1,dim[[3]],gs}];

	pos=Ceiling[DeleteCases[Flatten[Table[If[shift[[i,j]]==0.,{i,j},Null],{i,1,dim[[2]],gs},{j,1,dim[[3]],gs}],1],Null]/gs];

	dcor=Flatten[Delete[deffGrid,pos],1];
	ncor=Flatten[Delete[normGrid,pos],1];

	points=
	If[def&&norm,Graphics[{{PointSize[gf[[2]]],ncol,Point[ncor]},{PointSize[gf[[2]]],dcol,Point[dcor]}}],
		If[def,Graphics[{PointSize[gf[[2]]],dcol,Point[dcor]}],
			If[norm,Graphics[{PointSize[gf[[2]]],ncol,Point[ncor]}],
				Graphics[]
				]
			]
		];

	lines=If[defl,
		If[dir=="COL",Graphics[{Thickness[gf[[1]]],lcol,Map[BSplineCurve[#]&,deffGrid]}],
			If[dir=="ROW",Graphics[{Thickness[gf[[1]]],lcol,Map[BSplineCurve[#]&,Transpose[deffGrid]]}]]
			],
		Graphics[]
		];

	arrows=If[arr,
		head=Graphics[Line[{{-1/2,1/4},{0,0},{-1/2,-1/4}}]];
		Graphics[{Thickness[gf[[1]]],acol,Arrowheads[{{0.008,Automatic,head}}],Arrow[#]&/@ Transpose[{dcor,ncor}]}],
		Graphics[]
		];

	plot=If[pl,
		Ploti[data, {min, max}, None, ps, {1, color}, False, False, clip, {1, 1}],Graphics[]
		];

	Show[plot,lines,points,arrows,ImageSize->ps,PlotLabel->Style[lab,Bold,FontFamily->"Arial",FontSize->Round[ps/20]]]
	]


(* ::Subsubsection::Closed:: *)
(*MultiFileSaveDef*)


MultiFileSaveDef[data_,shift_,range_,type_,size_,settings_]:=
Module[{input,dim,dir,min,max,label,ps,color,gs,gf,ncol,dcol,lcol,acol,def,norm,defl,arr,pl,lab,exp,name},
	input=SystemDialogInput["Directory",Directory[]];
	If[input===$Canceled,Print["Export multiple files was canceled!"],	
		{dim,dir}=settings[[1]];
		{min,max}=settings[[2]];
		label=settings[[3]];
		ps=settings[[4]];
		color=settings[[5]];
		{gs,gf,ncol,dcol,lcol,acol}=settings[[6]];
		{def,norm,defl,arr,pl}=settings[[7]];

		Table[
			lab=If[!StringQ[label],"",label<>" - "]<>"Slice - "<>ToString[x];
			exp=PlotDefi[data[[x]],shift[[x]],{dim,dir},{min,max},lab,ps,color,{gs,gf,ncol,dcol,lcol,acol},{def,norm,defl,arr,pl}];
			name=input<>lab<>type;
			Export[name,exp,ImageSize->size];
			,{x,range[[1]],range[[2]]}
			];
		Print["Multiple fiels were saved to: "<>input<>" as "<>type<>" files."];
		]
	]


(* ::Subsubsection::Closed:: *)
(*MovieSaveDef*)


MovieSaveDef[data_,shift_,dur_,loop_,size_,range_,settings_]:=
Module[{movie,input,dim,dir,min,max,label,ps,color,gs,gf,ncol,dcol,lcol,acol,def,norm,defl,arr,pl,lab},
	input=SystemDialogInput["FileSave", Directory[] <> $PathnameSeparator <>"*.gif"];
	If[input===$Canceled,Print["Export multiple files was canceled!"],
		{dim,dir}=settings[[1]];
		{min,max}=settings[[2]];
		label=settings[[3]];
		ps=settings[[4]];
		color=settings[[5]];
		{gs,gf,ncol,dcol,lcol,acol}=settings[[6]];
		{def,norm,defl,arr,pl}=settings[[7]];

		movie=Flatten[Table[
			lab=If[!StringQ[label],"",label<>" - "]<>"Slice - "<>ToString[x];
			PlotDefi[data[[x]],shift[[x]],{dim,dir},{min,max},lab,ps,color,{gs,gf,ncol,dcol,lcol,acol},{def,norm,defl,arr,pl}]
			,{x,range[[1]],range[[2]]}
			]];

		Export[input,movie,"DisplayDurations"->dur,"AnimationRepetitions"->loop,ImageSize->size];
		Print["Movi was saved to: "<>input];
		]
	]


(* ::Subsection:: *)
(*Plot Data*)


(* ::Subsubsection::Closed:: *)
(*General*)


Options[PlotData]={PlotRange->"Auto",ColorFunction->"BlackToWhite"};

SyntaxInformation[PlotData] = {"ArgumentsPattern" -> {_, _., _., OptionsPattern[]}};


(* ::Subsubsection::Closed:: *)
(*PlotData 1 dataset*)


PlotData[dat_?ArrayQ,vox:{_?NumberQ, _?NumberQ, _?NumberQ}:{1,1,1},OptionsPattern[]]:= Module[{
		data,dim,n,control,str,exp,clipMin, clipMax,reverse,start1,end1,start2,end2,dur,loop,tab1,tab2,depth,
		x,xp,yp,min,max,minclip,maxclip,label,ps,color,lstyle,legend,fileType,size,pannel,aspect,or,rangex,rangey,frame,
		mind,maxd,plab,plot,pdata,cfs,lab,pcol,ccol, ran
	},

	NotebookClose[plotwindow];

	(*Check if data is numeric array, if not exit*)
	data = ToPackedArray[N[Normal[dat]]];
	If[!ArrayQ[data, _, RealValuedNumericQ],Return[Message[PlotData::data]]];

	(*See what kind of data: 2D,3D or 4D (n=1,2,3). If not one of those exit*)
	If[(depth = ArrayDepth[data])>4, Return[Message[PlotData::set]], n = depth-1];

	(*Determine data dimensions en make string displaying data dimensions*)
	dim = Dimensions[data];
	str = "Displaying "<>DataString[dim];

	(*Initialize slice ranges and data range*)
	rangex = dim[[1]];
	rangey = dim[[2]];

	(*Define the initial plot range*)
	{mind,maxd} = If[ListQ[OptionValue[PlotRange]] && Length[OptionValue[PlotRange]]==2, OptionValue[PlotRange], MinMax[data]];
	If[mind === maxd, maxd = mind + 0.01];

	pcol = If[MemberQ[colorFunctions[[All,1]],OptionValue[ColorFunction]], OptionValue[ColorFunction] , "BlackToWhite"];

	(*Define the tabs of the control pannel*)
	(*T1: first tabs, plotting controls*)
	tab1 = Column[{
		(*Slice selction controls, depends on data dimensions*)
		{"",
		ManPannel["Slice Selection",{
			{Dynamic["Slice (1-"<>ToString[rangex]<>")"],Control@{{x,Round[rangex/2],""},1,Dynamic[rangex],1, Appearance -> "Labeled"}},
			{"Orientation",Control@{{or,1,""},{1->"Transversal",2->"Sagittal",3->"Coronal"}}},
			{"Reverse Slice Order",Control@{{reverse,False,""},{True,False}}}
		}],
		ManPannel["Slice Selection",{
			{Dynamic["Slice 1 (1-"<>ToString[rangex]<>")"],Control@{{x,Round[rangex/2],""},1,Dynamic[rangex],1, Appearance -> "Labeled"}},
			{"Slice 2 (1-"<>ToString[rangey]<>")",Control@{{yp,1,""},1,rangey,1, Appearance -> "Labeled"}},
			{"Orientation",Control@{{or,1,""},{1->"Transversal",2->"Sagittal",3->"Coronal"}}},
			{"Reverse Slice Order",Control@{{reverse,False,""},{True,False}}}
			}]
		}[[n]]
		,(*Plot range controls*)
		ManPannel["Plot Range",{
			{"Auto Scaling", Control@{{cfs,False,""},{True -> "On", False -> "Off"}}},
			{"Min value",Control@{{min,mind,""},mind,max-(maxd-mind)/250,(maxd-mind)/250, Appearance -> "Labeled"}},
			{"Max value",Control@{{max,maxd,""},min+(maxd-min)/250,maxd,(maxd-mind)/250, Appearance -> "Labeled"}},
			{"Min Clipping", Row[{
				Control@{{clipMin, "Custom", ""}, {"Auto", "Transparent", "Custom"->"Custom: "}}," ",
				Control@{{minclip, Black, ""},  
				Button[
					Dynamic[Graphics[{minclip, Rectangle[]}, ImageSize -> {20, 20}]],
					new = SystemDialogInput["Color", #];
					minclip = If[new === $Canceled, minclip, new]
					, Background -> White, Method -> "Queued", FrameMargins -> 0, Appearance -> "Frameless"
				]&
				(*ColorSetter[#, ImageMargins->-5, ImageSize->{50, 50}]&*)}
			}]},
			{"Max Clipping", Row[{
				Control@{{clipMax, "Auto", ""}, {"Auto", "Transparent", "Custom"->"Custom: "}}," ",
				Control@{{maxclip, White, "" },  
				Button[
					Dynamic[Graphics[{maxclip, Rectangle[]}, ImageSize -> {20, 20}]],
					new = SystemDialogInput["Color", #];
					maxclip = If[new === $Canceled, maxclip, new]
					, Background -> White, Method -> "Queued", FrameMargins -> 0, Appearance -> "Frameless"
				]&
				(*ColorSetter[#, ImageMargins->-5, ImageSize->{50, 50}]&*)}
			}]}
		}]
		,(*Plot style controls*)
		ManPannel["Plot Style",{
			{"Plot Title",Control@{{label,"",""},InputField[#,String]&}},
			{"Plot Size",Control@{{ps,300,""},psizes,ControlType->PopupMenu}},
			{"Color function",Control@{{color,pcol,""},colors,ControlType->PopupMenu}},
			{"Color style",Control@{{lstyle,"Normal",""},colfuncs}},
			{"Layout",Row@{
				"  Legend:",Control@{{legend, False, ""}, {True, False}},
				"  Frame:",Control@{{frame, False, ""}, {True, False}},
				"  Label:",Control@{{lab, False, ""}, {True, False}}}}
		}]
	}];

	(*T2: second tab, exporting controls*)
	tab2 = Column[{
		(*Export parameters controls*)
		ManPannel["Export plot",{
			{"File Type",Control@{{fileType,".jpg",""},files}},
			{"Export Size",Control@{{size,400,""},sizes,ControlType->PopupMenu}},
			{"Export",Button["Save Plot", SaveImage[Dynamic[exp], FileType->fileType, ImageSize -> size],Method->"Queued",ImageSize->150]}
		}]
		,(*Multiple image export controls, depends on data dimensions 2D-off, 3D-on 2 sliders, 4D-on 4 sliders*)
		{"",
		ManPannel["Export multiple plots as files",{
			{"Start slice",Control@{{start1,1,""},1,Dynamic[end1],1, Appearance -> "Labeled"}},
			{"End slice",Control@{{end1,Length[data],""},Dynamic[start1],Dynamic[rangex],1, Appearance -> "Labeled"}},
			{"Export Files",
				Button["Save Plots",MultiFileSave[Hold[plot[xs,ys,xs]],Hold[plab[xs,ys,True]],{start1,end1},fileType,size],
				Method->"Queued",ImageSize->150]}
		}],
		ManPannel["Export multiple plots as files",{
			{"Start slice 1",Control@{{start1,1,""},1,Dynamic[end1],1, Appearance -> "Labeled"}},
			{"End slice 1",Control@{{end1,1,""},Dynamic[start1],Dynamic[rangex],1, Appearance -> "Labeled"}},
			{"Start slice 2",Control@{{start2,1,""},1,Dynamic[end2],1, Appearance -> "Labeled"}},
			{"End slice 2",Control@{{end2,Length[data[[1]]],""},Dynamic[start2],Length[data[[1]]],1, Appearance -> "Labeled"}},
			{"Export Files",
				Button["Save Plots",MultiFileSave[Hold[plot[xs,ys,xs]],Hold[plab[xs,ys,True]],{start1,end1,start2,end2},fileType,size],
				Method->"Queued",ImageSize->150]}
			}]
		}[[n]]
		,(*Animated gif export controls, depends on data dimensions 2D-off, 3D/4D-on*)
		{"",
		ManPannel["Export multiple plots as animated gif",{
			{"Display Duration (s)",Control@{{dur,.5,""},0.1,2,0.1, Appearance -> "Labeled"}},
			{"Animation Repetitions",Control@{{loop,Infinity,""},{Infinity,1,2,3,4,5},ControlType->PopupMenu}},
			{"Export Movie",
				Button["Save Movie",MovieSave[Hold[plot[xs,ys,xs]],dur,loop,size,{start1,end1,start2,end2}[[1;;2(n-1)]]],
				Method->"Queued",ImageSize->150]}
			}]
		}[[Unitize[n-1]+1]](*outputt 0 or 1 thus showing menu or not*)
	}];

	(*Build the control pannel, allows for easy addition of more tabs*)
	control = {str,Delimiter,
		{{pannel,1,""},{1->"Plotting options",2->"Exporting options"}},Delimiter
		,PaneSelector[{1->tab1,2->tab2},Dynamic[pannel]]};

	(*Deploy plot window*)
	pan = Manipulate[
		If[!ListQ[data],Return[];];

		(*updata slice range for 3D and 4D plots when switching between axial and sagital*)
		rangex={dim[[1]],dim[[n]],dim[[n+1]]}[[or]];

		(*reverse slices if needed and constrain ranges*)
		x=If[NumericQ[x],Clip[x,{1,rangex}],1];
		xp=If[reverse,(-x+rangex)+1,x];
		yp=If[NumericQ[yp],Clip[yp,{1,rangey}],1];

		(*determine the aspect ration based on the voxelsize and dimensions*)
		aspect=Drop[vox,{or}];

		(*based on the data dimensions or how the data is showed determine how the data selection looks*)
		pdata={
			data&,
			{data[[#1]]&,Reverse[data[[All,#1]]]&,Reverse[data[[All,All,#1]]]&}[[or]],
			{data[[#1,#2]]&,Reverse[data[[All,#2,#1]]]&,Reverse[data[[All,#2,All,#1]]]&}[[or]]
		}[[n]];

		(*Make plot label*)
		plab=If[#3,
			LabelFunc[label,{{},{#1},{#1,#2}}[[n]]],
			LabelFunc[label,{}]
		]&;

		(*fix the plot range*)
		ran = PlotRangeVals[cfs, pdata[xp, yp], {min, max}];

		(*make the clipping colors*)
		ccol = ClipColor[{clipMin, clipMax}, {minclip, maxclip}, {lstyle, color}];	

		(*create Plot, is on hold so it can be used for exporting multiple files and movie*)
		plot = Ploti[
			pdata[#1, #2],		(*the data*)
			ran,				(*the plot range*)
			plab[#3 ,#2, lab],	(*the plot label*)
			ps,					(*the plot size*)
			{lstyle, color},	(*style (1-4),colorfunction*)
			legend,				(*show plot legend*)
			frame,				(*show the frame*)
			ccol,				(*the plot clip color*)
			aspect				(*the aspect ratio*)
		]&;

		(*insert data in plot and show*)
		(*Make sure that the x an y slice selection indices cant exceed the data dimensions*)
		exp=plot[xp,yp,x]

		,##(*Insertion of control pannel*),
		(*Manipulate function options*)
		ControlPlacement->Right,
		Initialization:>{or=1,reverse=False,legend=False},
		Deployed->False, 
		SynchronousInitialization -> False
		]&@@control;

		NotebookClose[plotwindow];
		plotwindow=CreateWindow[DialogNotebook[{CancelButton["Close", Clear[data]; DialogReturn[]], pan}, 
			WindowSize -> All, WindowTitle -> "Plot data window"]];
	];


(* ::Subsubsection::Closed:: *)
(*PlotData 2 datasets*)


PlotData[dat1_?ArrayQ, dat2_?ArrayQ,vox:{_?NumberQ, _?NumberQ, _?NumberQ}:{1,1,1},OptionsPattern[]]:=
Module[{data1=N[dat1],data2=N[dat2],label,label1,label2,str,n,rangex,rangey,tab1,tab2,ccol,
		x,xp,yp,min1,max1,min2,max2,mind1,maxd1,mind2,maxd2,reverse,or,plabs,plab,plot,aspect,cfs1,cfs2,
		minclip1,maxclip1,minclip2,maxclip2,clipMax1,clipMin1,clipMax2,clipMin2,ps,legend,color1,color2,lstyle1,lstyle2,control,
		pannel,pdata1,pdata2,flip,overlay,checksize,opac,diffr,fileType,size,leftright,lab,mpdim,leg, ran,
		start1,end1,start2,end2,dur,loop,exp,dim1,dim2,prange,frame,adep1,adep2,maxabs,pcol,pcol1,pcol2
	},

	NotebookClose[plotwindow];

	(*Check if data is numeric array, if not exit*)
	data1 = ToPackedArray[N@Normal@dat1];
	data2 = ToPackedArray[N@Normal@dat2];
	If[(! ArrayQ[data1, _, RealValuedNumericQ]) || (! ArrayQ[data2, _, RealValuedNumericQ]),Return[Message[PlotData::data]]];

	(*See what kind of data: 2D,3D or 4D (n=1,2,3). If not one of those exit*)
	(*Determine data dimensions en make string displaying data dimensions*)
	adep1=ArrayDepth[data1];
	adep2=ArrayDepth[data2];
	dim1=Dimensions[data1];
	dim2=Dimensions[data2];

	mpdim=Max[Join[Take[dim1,-2],Take[dim2,-2]]];

	If[!(2<=adep1<=4 || 2<=adep2<=4), Return[Message[PlotData::set]]];
	If[(!(adep1==2 || adep2==2)),
		If[((adep1==3 || adep2==3) && dim1[[1]]!=dim2[[1]]) || (adep1==adep2==4 && dim1[[{1,2}]]!=dim2[[{1,2}]]),
			Return[Message[PlotData::size,dim1,dim2]]
		]
	];
	str="Displaying 2 dataset:\nLeft: "<>DataString[dim1]<>"\nRight: "<>DataString[dim2];
	n=Max[{adep1,adep2}]-1;
	leftright=1;

	(*determine the slider range for slice slection*)
	rangex=If[ArrayQ[data1,2],Length[data2],Length[data1]];
	rangey=If[ArrayQ[data1,4],Length[data1[[1]]],Length[data2[[1]]]];

	(*Rescale data between 0 and 1*)
	prange=OptionValue[PlotRange];

	{mind1,maxd1,mind2,maxd2}=If[ListQ[OptionValue[PlotRange]] && (Dimensions[prange] == {2} || Dimensions[prange] == {2,2}),
		If[Dimensions[prange]=={2},Flatten[{prange,prange}],If[Dimensions[prange]=={2,2},Flatten[prange]]],
		{Min[data1],Max[data1],Min[data2],Max[data2]}
		];
	If[mind1===maxd1,maxd1=mind1+0.01];
	If[mind2===maxd2,maxd2=mind2+0.01];

	maxabs=Max[Abs[{mind1,maxd1,mind2,maxd2}]];

	pcol = OptionValue[ColorFunction];
	If[Length[OptionValue[ColorFunction]]==2 && MemberQ[colorFunctions[[All,1]],pcol[[1]]] && MemberQ[colorFunctions[[All,1]],pcol[[2]]],
		{pcol1,pcol2} = OptionValue[ColorFunction],
		pcol1 = pcol2 = If[MemberQ[colorFunctions[[All,1]],pcol], pcol, "BlackToWhite"]
	];

	(*Define the different tabs of the control pannel*)
	(*first tabs, plotting controls*)
	tab1 = Column[{
		{"",
		ManPannel["Slice Selection",{
			{"Slice",Control@{{x,Round[rangex/2],""},1,Dynamic[rangex],1, Appearance -> "Labeled"}},
			{"Reverse Slice Order", Control@{{reverse, False, ""}, {True, False}}},
			{##} & @@ If[dim1 == dim2, {"Orientation",Control@{{or, 1, ""}, {1->"Transversal",2->"Sagittal",3->"Coronal"}}},or=1; Null]
			}],
		ManPannel["Slice Selection",{
			{"Slice 1",Control@{{x,Round[rangex/2],""},1,Dynamic[rangex],1, Appearance -> "Labeled"}},
			{"Slice 2",Control@{{yp,1,""},1,rangey,1, Appearance -> "Labeled"}},
			{"Reverse Slice Order", Control@{{reverse, False, ""}, {True, False}}},
			{##} & @@ If[(Take[dim1, -2] == Take[dim2, -2])&&(Length[dim1]>=3)&&(Length[dim2]>=3), {"Orientation",Control@{{or, 1, ""}, 
				{1->"Transversal",2->"Sagittal",3->"Coronal"}}}, or=1;Null]
			}]
			}[[n]]
		,
		ManPannel["Plot Range",{
			{"Data set",Control@{{leftright,1,""},{1->"Left",2->"Right"}}},
			{Style[Dynamic[{"Left dataset","Right dataset"}[[leftright]]],Bold],""},
			{"Auto Scaling",PaneSelector[{
				1->Control@{{cfs1,False,""},{True -> "On", False -> "Off"}},
				2->Control@{{cfs2,False,""},{True -> "On", False -> "Off"}}
			},Dynamic[leftright]]},
			{"Min value",PaneSelector[{
				1->Control@{{min1,mind1,""},mind1,max1-(maxd1-mind1)/250,(maxd1-mind1)/250, Appearance -> "Labeled"},
				2->Control@{{min2,mind2,""},mind2,max2-(maxd2-mind1)/250,(maxd2-mind1)/250, Appearance -> "Labeled"}
			},Dynamic[leftright]]},
			{"Max value",PaneSelector[{
				1->Control@{{max1,maxd1,""},(maxd1-mind1)/250+ min1,maxd1,(maxd1-mind1)/250, Appearance -> "Labeled"},
				2->Control@{{max2,maxd2,""},(maxd2-mind2)/250+ min2,maxd2,(maxd2-mind2)/250, Appearance -> "Labeled"}
			},Dynamic[leftright]]},

			{"Min Clipping", PaneSelector[{
				1->Row[{
					Control@{{clipMin1,"Custom",""}, {"Auto", "Transparent", "Custom"->"Custom: "}}," ",
					Control@{{minclip1, Black, ""}, 
					Button[
					Dynamic[Graphics[{minclip1, Rectangle[]}, ImageSize -> {20, 20}]],
					new = SystemDialogInput["Color", #];
					minclip1 = If[new === $Canceled, minclip1, new]
					, Background -> White, Method -> "Queued", FrameMargins -> 0, Appearance -> "Frameless"]&
						(*ColorSetter[#, ImageMargins->-5, ImageSize->{50, 50}]&*)}
				}],
				2->Row[{
					Control@{{clipMin2,"Custom",""}, {"Auto", "Transparent", "Custom"->"Custom: "}}," ",
					Control@{{minclip2, Black, ""},  
					Button[
					Dynamic[Graphics[{minclip2, Rectangle[]}, ImageSize -> {20, 20}]],
					new = SystemDialogInput["Color", #];
					minclip2 = If[new === $Canceled, minclip2, new]
					, Background -> White, Method -> "Queued", FrameMargins -> 0, Appearance -> "Frameless"]&
							(*ColorSetter[#, ImageMargins->-5, ImageSize->{50, 50}]&*)}
				}]
			},Dynamic[leftright]]},
			{"Max Clipping", PaneSelector[{
				1->Row[{
					Control@{{clipMax1,"Custom",""}, {"Auto", "Transparent", "Custom"->"Custom: "}}," ",
					Control@{{maxclip1, White, "" },  
				Button[
				Dynamic[Graphics[{maxclip1, Rectangle[]}, ImageSize -> {20, 20}]],
				new = SystemDialogInput["Color", #];
				maxclip1 = If[new === $Canceled, maxclip1, new]
				, Background -> White, Method -> "Queued", FrameMargins -> 0, Appearance -> "Frameless"]&
						(*ColorSetter[#, ImageMargins->-5, ImageSize->{50, 50}]&*)}
				}],
				2->Row[{
					Control@{{clipMax2,"Custom",""}, {"Auto", "Transparent", "Custom"->"Custom: "}}," ",
					Control@{{maxclip2, White, "" },  
				Button[
				Dynamic[Graphics[{maxclip2, Rectangle[]}, ImageSize -> {20, 20}]],
				new = SystemDialogInput["Color", #];
				maxclip2 = If[new === $Canceled, maxclip2, new]
				, Background -> White, Method -> "Queued", FrameMargins -> 0, Appearance -> "Frameless"]&
						(*ColorSetter[#, ImageMargins->-5, ImageSize->{50, 50}]&*)}
				}]
			},Dynamic[leftright]]}
		}, False],
		ManPannel["Plot Style",{
			{"Plot Title",Control@{{label,"",""},InputField[#,String]&}},
			{"Plot Size",Control@{{ps,300,""},psizes,ControlType->PopupMenu}},
			{"Layout",Row@{
				"  Legend:",Control@{{legend,False,""},{True,False}},
				"  Frame:",Control@{{frame,False,""},{True,False}},
				"  Label:",Control@{{lab,True,""},{True,False}}}},
			{"Data set",Control@{{leftright,1,""},{1->"Left",2->"Right"}}},
			{Style[Dynamic[{"Left dataset","Right dataset"}[[leftright]]],Bold],""},
			{"PlotTitle",PaneSelector[{
				1->Control@{{label1,"",""},InputField[#,String]&},
				2->Control@{{label2,"",""},InputField[#,String]&}},Dynamic[leftright]]},
			{"Color function",PaneSelector[{
				1->Control@{{color1,pcol1,""},colors,ControlType->PopupMenu},
				2->Control@{{color2,pcol2,""},colors,ControlType->PopupMenu}},Dynamic[leftright]]},
			{"Color style",PaneSelector[{
				1->Control@{{lstyle1,"Normal",""},colfuncs},
				2->Control@{{lstyle2,"Normal",""},colfuncs}},Dynamic[leftright]]}
			},True],
		ManPannel["Overlay/Checkboard Plot Options",{
			{"Merge Plots",Control@{{overlay,1,""},{1->"None",2->"Checkboard",3->"Overlay",4->"Difference"}}},
			{"Flip",Control@{{flip,False,""},{True,False}}},
			{"Legend",Control@{{leg,1,""},{1->"First","Second"}}},
			{
				PaneSelector[{1 -> Null, 2 -> "Check Size (pix)",3 -> "Overlay Opacity", 4 -> "Difference plot range"},Dynamic[overlay]],
				PaneSelector[{
					1 -> Null,
					2 -> Control@{{checksize, Ceiling[0.1*mpdim], ""}, 1, Ceiling[.5*mpdim], 1},
					3 -> Control@{{opac, 0.4, ""}, 0, 1},
					4 -> Control@{{diffr, .5*maxabs, ""}, Dynamic[0.00001*maxabs], Dynamic[2*maxabs] /. 0. -> 1., Dynamic[(1.5*maxabs /. 0. -> 1.)/1000]}
				}, Dynamic[overlay]]
			}},False]}];

	(*second tab, exporting controls*)
	tab2 = Column[{
		ManPannel["Export plot",{
			{"File Type",Control@{{fileType,".jpg",""},files}},
			{"Export Size",Control@{{size,400,""},sizes,ControlType->PopupMenu}},
			{"Export",Button["Save Plot",SaveImage[Dynamic[exp],FileType->fileType,ImageSize -> size],Method->"Queued",ImageSize->150]}
			}]
		,
		{"",
			ManPannel["Export multiple plots as files",{
				{"Start slice",Control@{{start1,1,""},1,Dynamic[end1],1, Appearance -> "Labeled"}},
				{"End slice",Control@{{end1,rangex,""},Dynamic[start1],rangex,1, Appearance -> "Labeled"}},
				{"Export Files",Button["Save Plots",MultiFileSave[Hold[plot[xs,ys,xs]],Hold[plab[xs,ys,True]],{start1,end1},fileType,size],
					Method->"Queued",ImageSize->150]}
				}],
			ManPannel["Export multiple plots as files",{
				{"Start slice 1",Control@{{start1,1,""},1,Dynamic[end1],1, Appearance -> "Labeled"}},
				{"End slice 1",Control@{{end1,rangex,""},Dynamic[start1],rangex,1, Appearance -> "Labeled"}},
				{"Start slice 2",Control@{{start2,1,""},1,Dynamic[end2],1, Appearance -> "Labeled"}},
				{"End slice 2",Control@{{end2,rangey,""},Dynamic[start2],rangey,1, Appearance -> "Labeled"}},
				{"Export Files",Button["Save Plots",MultiFileSave[Hold[plot[xs,ys,xs]],Hold[plab[xs,ys,True]],{start1,end1,start2,end2},fileType,size],
					Method->"Queued",ImageSize->150]}
				}]
			}[[n]],
		{"",
			ManPannel["Export multiple plots as animated gif",{
				{"Display Duration (s)",Control@{{dur,.5,""},0.1,2,0.1, Appearance -> "Labeled"}},
				{"Animation Repetitions",Control@{{loop,Infinity,""},{Infinity,1,2,3,4,5},ControlType->PopupMenu}},
				{"Export Movie",Button["Save Movie",MovieSave[Hold[plot[xs,ys,xs]],dur,loop,size,{start1,end1,start2,end2}[[1;;2(n-1)]]], Method->"Queued",ImageSize->150]}
				}]
			}[[Unitize[n-1]+1]]
		}];

	(*Build the control pannel, allows for easy addition of more tabs*)
	control={
		str,
		Delimiter,
		{{pannel,1,""},{1->"Plotting options",2->"Exporting options"}},
		Delimiter,
		PaneSelector[{1->tab1,2->tab2}, Dynamic[pannel]]
	};

	(*Deploy plot window*)
	pan = Manipulate[
		If[!ListQ[data1]||!ListQ[data2],Return[]];

		(*updata slice range for 3D and 4D plots when switching between axial and sagital*)
		If[(Take[dim1,-2] == Take[dim2,-2] && ArrayDepth[data1] >= 3 && ArrayDepth[data2] >= 3),
			rangex={dim1[[1]],Take[dim1,{-2}][[1]],Take[dim1,{-1}][[1]]}[[or]]
		];

		(*reverse slices if needed*)
		x=If[NumericQ[x],Clip[x,{1,rangex}],1];
		xp=If[reverse,(-x+rangex)+1,x];
		yp=If[NumericQ[yp],Clip[yp,{1,rangey}],1];

		(*determine the aspect ration based on the voxelsize and dimensions*)
		aspect=Drop[vox,{or}];

		(*based on the data dimensions or how the data is showed determine how the data selection looks*)
		pdata1={
			data1&,
			{data1[[#1]]&,Reverse[data1[[All,#1]]]&,Reverse[data1[[All,All,#1]]]&}[[or]],
			{data1[[#1,#2]]&,Reverse[data1[[All,#2,#1]]]&,Reverse[data1[[All,#2,All,#1]]]&}[[or]]
			}[[ArrayDepth[data1]-1]];		

		pdata2={data2&,
			{data2[[#1]]&,Reverse[data2[[All,#1]]]&,Reverse[data2[[All,All,#1]]]&}[[or]],
			{data2[[#1,#2]]&,Reverse[data2[[All,#2,#1]]]&,Reverse[data2[[All,#2,All,#1]]]&}[[or]]
			}[[ArrayDepth[data2]-1]];

		(*Make plot label*)
		plabs={{},{#1},{#1,#2}}[[#3-1]]&;
		plab=If[adep1 == adep2,
			(*if both are no label set bot to zero*)
			If[label1!=""||label2!="", {label1,label2} = {label1,label2} /. ""->" "];
			{
				If[label1==="",None,label1],
				If[label2==="",None,label2],
				If[#3,LabelFunc[label,plabs[#1,#2, adep1]],LabelFunc[label,{}]]
			}
			,
			If[label1!=""||label2!="",{label1,label2}={label1,label2} /. ""->" "];
			{
				If[#3,LabelFunc[label1,plabs[#1,#2, adep1]],LabelFunc[label1,{}]],
				If[#3,LabelFunc[label2,plabs[#1,#2, adep2]],LabelFunc[label2,{}]],
				If[label==="",None,label]
			}
			]&;

		(*get the plot ranges*)
		ran = {
			PlotRangeVals[cfs1, pdata1[xp, yp], {min1,max1}],
			PlotRangeVals[cfs2, pdata2[xp, yp], {min2,max2}]
		};

		(*get the clip colors*)
		ccol = {
			ClipColor[{clipMin1, clipMax1}, {minclip1, maxclip1}, {lstyle1, color1}],
			ClipColor[{clipMin2, clipMax2}, {minclip2, maxclip2}, {lstyle2, color2}]
		};

		plot = Plot2i[
			{pdata1[#1,#2],pdata2[#1,#2]},			(*the data*)
			ran,									(*the plot range*)
			plab[#3,#2,lab],						(*the plot label*)
			ps,										(*the plot size*)
			{{lstyle1,color1},{lstyle2,color2}},	(*style (1-4),colorfunction*)
			legend,									(*show plot legend*)
			frame,									(*show the frame*)
			{overlay,checksize,flip,opac,diffr},	(*the overlay options*)
			ccol,									(*the plot clip color*)
			aspect,									(*the aspect ratio*)
			leg										(*chose the legend bar*)
			]&;

		(* Create and show plot*)
		exp=plot[xp,yp,x]

		,##,
		Initialization:>{or=1,reverse=False,legend=False,leftright->1},
		ControlPlacement->Right,
		(*Deployed->True,*) 
		SynchronousInitialization -> False
		]&@@control;

		NotebookClose[plotwindow];
		plotwindow=CreateWindow[DialogNotebook[{CancelButton["Close", Clear[data1,data2];DialogReturn[]], pan}, 
			WindowSize -> All, WindowTitle -> "Plot data window"]];
	];


(* ::Subsection::Closed:: *)
(*Plot Data 3D*)


SyntaxInformation[PlotData3D] = {"ArgumentsPattern" -> {_, _.}};

PlotData3D[dat_?ArrayQ, v:{_?NumberQ, _?NumberQ, _?NumberQ}:{1,1,1}] := Module[{},
DynamicModule[{data, vox, dep},
	NotebookClose[plotwindow];

	(*get data to dynamic*)
	data = ToPackedArray[N[Normal[dat]]];
	If[!ArrayQ[data, _, RealValuedNumericQ], Return[Message[PlotData::data]]];
	If[(dep = ArrayDepth[data])>4, Return[Message[PlotData::set]], n = dep-1];
	vox = v;

	(*start the manipulation*)
	pan = Manipulate[

		(*first part is data management, pdat is the data to be plotted*)
		t1 = (
			(*determine scaling and dimensions*)
			{sets, size1} = If[trans, dimd[[{2, 1}]], dimd[[{1, 2}]]];
			dim = {size1, size2, size3};
			size = Reverse[vox*dim];
			ratio = size/Max[size];

			(*correctly clip the slice numbers and mirror slices if needed*)
			set = If[NumericQ[set], Clip[set, {1, sets}], 1];
			slice = If[NumericQ[slice], Clip[slice, {1, size1}], 1];
			column = If[NumericQ[column], Clip[column, {1, size2}], 1];
			row = If[NumericQ[row], Clip[row, {1, size3}], 1];

			(*reverse dimenion index for correct data selection*)
			{slicep, columnp, rowp} = {size1 - slice + 1, size2 - column + 1, row};

			(*determine to draw lines and adjust pot scaling for all pannels*)
			scal = If[show != 4, scale, 0.6 scale];

			(*rescale 3D values for 3D image and select correct dataset*)
			dats = If[depth == 4, If[trans, data[[set]], data[[All, set]]], data];
			pdat = If[reverse, dats, Reverse[dats]];

			(*Check which 3D view to use*)
			If[MemberQ[views[[All, 1]], vp], vv = {0, 0, 1}; va = 25. Degree];
		) // AbsoluteTiming // First;

		(*get datarange and clip colors*)
		t2 = (
			(*get the plotrange*)
			ran = PlotRangeVals[cfs, pdat, {min, max}];
			(*make the clipping colors*)
			ccol = ClipColor[{clipMin, clipMax}, {minclip, maxclip}, {lstyle, color}];
		) // AbsoluteTiming // First;

		(*create the lices for the pannel all view*)
		t3 = (
			{linax, lincor, linsag} = If[show == 4 && lines,{
				Graphics[{Thickness[Large], Red, Line[{{row, 0}, {row, size2 + 1}} - 0.5], Green, Line[{{0, column}, {size3 + 1, column}} - 0.5]}],
				Graphics[{Thickness[Large], Red, Line[{{row, 0}, {row, size1 + 1}} - 0.5], Blue,  Line[{{0, slice}, {size3 + 1, slice}} - 0.5]}],
				Graphics[{Thickness[Large], Green, Line[{{column, 0}, {column, size1 + 1}} - 0.5], Blue, Line[{{0, slice}, {size2 + 1, slice}} - 0.5]}]
				},
				{Graphics[], Graphics[], Graphics[]}
			];
		) // AbsoluteTiming // First;

		(*create the axial coronal and sagital images*)
		t4 = (
			If[MemberQ[If[planez, {1, 4, 5, 7}, {1, 4}], show],
				imax = MakeImage[pdat[[slicep]], {lstyle, color}, ccol, ran];
				plax = Show[imax, linax, ImageSize -> scal {ratio[[1]], ratio[[2]]}, AspectRatio -> Full];
			];
			If[MemberQ[If[planey, {2, 4, 5, 7}, {2, 4}], show],
				imcor = MakeImage[pdat[[All, columnp]], {lstyle, color}, ccol, ran];
				plcor = Show[imcor, lincor, ImageSize -> scal {ratio[[1]], ratio[[3]]}, AspectRatio -> Full];
			];
			If[MemberQ[If[planex, {3, 4, 5, 7}, {3, 4}], show],
				imsag =  MakeImage[Reverse[pdat[[All, All, rowp]],2], {lstyle, color}, ccol, ran];
				plsag = Show[imsag, linsag, ImageSize -> scal {ratio[[2]], ratio[[3]]}, AspectRatio -> Full];
			];
		) // AbsoluteTiming // First;

		(*create the pannel all view with event handles to click and select*)
		t5 = (
			If[show == 4, 
				imall = Grid[{{
					EventHandler[plax, {"MouseDown" :> ({row, column} = Abs[Round[MousePosition["Graphics"]] - {-1, -1}])}]
					},{
					EventHandler[plcor, {"MouseDown" :> ({row, slice} = Abs[Round[MousePosition["Graphics"]] - {-1, 1}])}],
					EventHandler[plsag, {"MouseDown" :> ({column, slice} = (Abs[Round[MousePosition["Graphics"]] - {-1, 1}]))}]
				}},	Background -> White, Spacings -> {0, 0}, Frame -> All, FrameStyle -> Directive[{Thickness[6], White}]]
			];
		) // AbsoluteTiming // First;

		(*create the 3d slice view*)
		t6 = (
			If[show == 5 || show == 7,
				sel = DeleteCases[{If[planez, 1], If[planey, 2], If[planex, 3]}, Null];
				slices3D = If[sel == {},
					{},
					{
						Opacity[{opz, opy, opx}[[#]]],
						Texture[{imax, imcor, imsag}[[#]]],
						Polygon[{
							{{1, 1, slice}, {size3, 1, slice}, {size3, size2, slice}, {1, size2, slice}},
							{{1, column, 1}, {size3, column, 1}, {size3, column, size1}, {1, column, size1}},
							{{row, 1, 1}, {row, size2, 1}, {row, size2, size1}, {row, 1, size1}}}[[#]],
						VertexTextureCoordinates -> {{0.025, 0.025}, {0.975, 0.025}, {0.975, 0.975}, {0.025, 0.975}}]
					} & /@ sel
				];

				plsl3D = Show[Graphics3D[{EdgeForm[None], slices3D},
					BoxRatios -> ratio, ImageSize -> scale, RotationAction -> "Clip", SphericalRegion -> True, 
					Background -> back, Lighting -> "Neutral", ViewPoint -> Dynamic[vp], ViewVertical -> Dynamic[vv],  ViewAngle -> Dynamic[va],
					Boxed -> box, Axes -> axes, AxesStyle -> Thread[List[{Red, Green, Blue}, Thick]]
				], PlotRange -> {{-1, size3 + 1}, {-1, size2 + 1}, {-1, size1 + 1}}, PerformanceGoal -> "Quality"]
			];
		) // AbsoluteTiming // First;

		(*Create the 3D image using Image3D*)
		t7 = (
			If[show == 6 || show == 7,
				plim3D = Image3D[ToByte[pdat, ran], ColorFunction -> col3D, Method -> {"SampleLayers" -> 100}, 
					BoxRatios -> ratio, ImageSize -> scale, SphericalRegion -> True,  ViewPoint -> Dynamic[vp], ViewVertical -> Dynamic[vv],  ViewAngle -> Dynamic[va],
					Background -> back, Boxed -> box, Axes -> axes, AxesStyle -> Thread[List[{Red, Green, Blue}, Thick]]
				]
			];
		) // AbsoluteTiming // First;

		(*If the Hybrid 3D slice and image3D veiuw is selected join the two images*)
		If[show == 7,
			merge = Show[Graphics3D[{EdgeForm[None], slices3D}], plim3D,
				BoxRatios -> ratio, ImageSize -> scale, RotationAction -> "Clip", SphericalRegion -> True, 
				Background -> back, Lighting -> "Neutral", ViewPoint -> Dynamic[vp], ViewVertical -> Dynamic[vv], ViewAngle -> Dynamic[va],
				Boxed -> box, Axes -> axes, AxesStyle -> Thread[List[{Red, Green, Blue}, Thick]],
				PlotRange -> {{-1, size3 + 1}, {-1, size2 + 1}, {-1, size1 + 1}}, PerformanceGoal -> "Quality"
			]
		];

		(*select the correct plot*)
		Column[{
			(*{t1,t2,t3,t4,t5,t6,t7},*)
			Switch[show, 1, plax, 2, plcor, 3, plsag, 4, imall, 5, plsl3D, 6, plim3D, 7, merge]
		}]

		(*start control pannel*)
		,
		(*--------------clean from here---------------------*)
		Row[{str}],
		Delimiter,
		(*The menu that selects what to show*)
		{{show, 4, "Plot Mode"}, {1 -> "Axial", 2 -> "Coronal", 3 -> "Sagittal", 4 -> "All Planes", 5 -> "Planes 3D", 6 -> "Volume 3D", 7 -> "Planes + 3D"}},
		(*slice selection menu and *)
		Delimiter,
		Column[{
			ManPannel["Slice Selection", {
				{Dynamic["Axial (1-" <> ToString[size1] <> ")"], Control@{{slice, Round[size1/2], ""}, 1, size1, 1}},
				{Dynamic[ "Coronal (1-" <> ToString[size2] <> ")"], Control@{{column, Round[size2/2], ""}, 1, size2, 1}},
				{Dynamic["Sagittal (1-" <> ToString[size3] <> ")"], Control@{{row, Round[size3/2], ""}, 1, size3, 1}},
				{"Data order", Row[{
					Control@{{trans, False, ""}, {True, False}},"  Transpose 4D   ", 
					Control@{{reverse, False, ""}, {True, False}}, "  Reverse slices"
				}]},
				{Dynamic["Set (4D)  (1-" <> ToString[sets] <> ")"], Control@{{set, 1, ""}, 1, Dynamic[sets], 1}}, 
				{"Clip 3D", Row[{Control@{{clip3D, False, ""}, {True, False}}, "  Clip   ", CheckboxBar[Dynamic[flip], {1 -> "Flip LR", 2 -> "Flip AP",3 -> "Flip FH"}]}]} 
			}]
		}],
		Delimiter,
		Column[{
			ManPannel["Plot Range", {
				{"Auto Scaling", Control@{{cfs, False, ""}, {True -> "On", False -> "Off"}}},
				{"Min value", Control@{{min, mind, ""}, mind, Dynamic[0.9 max]}},
				{"Max value", Control@{{max, maxd, ""}, Dynamic[1.1 min], maxd}},
				{"Min Clipping", Row[{
					Control@{{clipMin,"Custom",""}, {"Auto", "Transparent", "Custom"->"Custom: "}}," ",
					Control@{{minclip, Black, ""}, ColorSlider[#, ImageSize -> {20, 20}, AppearanceElements->"Swatch"] &}
				}]},
					{"Max Clipping", Row[{
					Control@{{clipMax,"Custom",""}, {"Auto", "Transparent", "Custom"->"Custom: "}}," ",
					Control@{{maxclip, White, "" }, ColorSlider[#, ImageSize -> {20, 20}, AppearanceElements->"Swatch"] &}
				}]}
			}]
		}],
		Delimiter,
		(*menu for plot style*)
		Column[{
			ManPannel["Plot Style", {
				{"Plot Title", Control@{{label, "", ""}, InputField[#, String] &}},
				{"Plot Size", Control@{{scale, 500, "" }, psizes}},
				{"Color function", Control@{{color, "BlackToWhite", ""}, colors, ControlType -> PopupMenu}},
				{"Color style", Control@{{lstyle, "Normal", ""}, colfuncs}},
				{"Layout", Row[{
					"  Show box:", Control@{{box, True, ""}, {True, False}},
					"  Show axis:", Control@{{axes, True, ""}, {True, False}},
					"  Show lines:", Control@{{lines, True, ""}, {True, False}}
				}]},
				{"BackGround", Control@{{back, Gray, ""}, ColorSlider[#, ImageSize -> {Automatic, 20}] &}}
			}]
		}],
		(* menu for 3D plot options*)
		Delimiter,
		Column[{
			ManPannel["3D options", {
				{ "Colorfunction 3D", Control@{{col3D, "WhiteBlackOpacity", ""}, colors3D}},
				{"Viewpoint", Control@{{vp, 3.5 {0.384, 0.709, 0.591}, ""}, views, ControlType -> SetterBar}},
				{"Show Planes", Row[{
					"Axial:  ", Control@{{planez, True, ""}, {True, False}},
					"  Coronal:  ", Control@{{planey, True, ""}, {True, False}},
					"  Sagittal:  ", Control@{{planex, True, ""}, {True, False}}
				}]},
				{"Opacity Axial", Control@{{opz, 1, ""}, 0, 1, 0.1}},
				{"Opacity Coronal", Control@{{opy, 1, ""}, 0, 1, 0.1}},
				{"Opacity Sagittal", Control@{{opx, 1, ""}, 0, 1, 0.1}}
			}, False]
		}],

		(*Hidden parameters*)
		(*for controls*)
		{slice, ControlType -> None}, {column, ControlType -> None}, {row, ControlType -> None}, 
		{trans, ControlType -> None}, {reverse, ControlType -> None}, {set, ControlType -> None}, 
		{clip, ControlType -> None}, {flip, ControlType -> None},

		{{cfs, False}, ControlType -> None}, {min, ControlType -> None}, {max, ControlType -> None}, {ran, ControlType -> None}, 
		{{minclip, RGBColor[{0, 0, 0, 1}]}, ControlType -> None}, {{maxclip, RGBColor[{255, 255, 255}]}, ControlType -> None}, 
		{{transp, False}, ControlType -> None}, {col3D, ControlType -> None},

		{label, ControlType -> None}, {scale, ControlType -> None}, {color, ControlType -> None}, {lstyle, ControlType -> None},
		{{box, True}, ControlType -> None}, {{axes, True}, ControlType -> None}, {{lines, True}, ControlType -> None}, {{back, Gray}, ControlType -> None},

		{{planez, True}, ControlType -> None}, {{planey, True}, ControlType -> None}, {{planex, True}, ControlType -> None},
		{{opz, 1}, ControlType -> None}, {{opy, 1}, ControlType -> None}, {{opx, 1}, ControlType -> None},

		(*3d volume view*)
		{{vp, 2{0.65, -1.2, 1}, "ViewPoint"}, Dynamic[vp] &, ControlType -> None},
		{{vv, {0, 0, 1}, "ViewVertical"}, Dynamic[vv] &, ControlType -> None},
		{{va, 25. Degree, "ViewAngle"}, Dynamic[va] &, ControlType -> None},

		(*for calculations*)
		{mind, ControlType -> None}, {maxd, ControlType -> None}, {depth, ControlType -> None},
		{dimd, ControlType -> None}, {sets, ControlType -> None}, {size1, ControlType -> None}, 
		{size2, ControlType -> None}, {size3, ControlType -> None}, {slicep, ControlType -> None}, 
		{columnp, ControlType -> None}, {rowp, ControlType -> None},

		{dim, ControlType -> None}, {size, ControlType -> None}, {scal, ControlType -> None}, {ratio, ControlType -> None},

		{dats, ControlType -> None}, {pdat, ControlType -> None},

		{linax, ControlType -> None}, {lincor, ControlType -> None}, {linsag, ControlType -> None},
		{plax, ControlType -> None}, {plcor, ControlType -> None}, {plsag, ControlType -> None},
		{imax, ControlType -> None}, {imcor, ControlType -> None}, {imsag, ControlType -> None}, {imall, ControlType -> None},
		{sel, ControlType -> None}, {slices3D, ControlType -> None}, {plsl3D, ControlType -> None}, {plim3D, ControlType -> None},

		(*initialization*)
		Initialization :> {
			{mind, maxd} = {min, max} = MinMax[data],
			depth = ArrayDepth[data], 
			dimd = If[ArrayDepth[data] != 4, Prepend[Dimensions@data, 1], Dimensions@Transpose[data]], 
			{sets, size1, size2, size3} = dimd,
			{slice, column, row} = Round[{size1, size2, size3}/2],
			str = "Displaying " <> DataString[dimd]
		},

		ContentSize -> 1.15 {scale, scale},
		Alignment -> {Center, Center},
		ControlPlacement -> Right,
		ContinuousAction -> True,
		AppearanceElements -> None,
		AutorunSequencing -> {1},
		SynchronousInitialization -> False
	];

	NotebookClose[plotwindow];
	plotwindow = CreateWindow[DialogNotebook[{CancelButton["Close", Clear[data]; DialogReturn[]], pan}, 
		WindowSize -> All, WindowTitle -> "Plot data window"]];
]];


(* ::Subsection::Closed:: *)
(*Plot Deformed Grid*)


PlotDefGrid[dat_?ArrayQ,phase_?ArrayQ,shiftpar_?ListQ]:=
Module[{dim,exp,data,shift,dir,label,settings,z,min,max,ps,color,maxclip,fileType,size,depth,n,str,
	minclip,transclip,gs,gf,ncol,dcol,lcol,acol,def,norm,defl,arr,pl,tab1,tab2,pannel,control,mind,maxd},
	data=N[dat];
	dim=Dimensions[data];
	shift=N[phase]*shiftpar[[1]];
	dir=shiftpar[[2]];

	(*Check if data is numeric array, if not exit*)
	data=dat//N;
	If[!ArrayQ[data,_,NumericQ],Return[Message[PlotData::data]]];

	(*See what kind of data: 2D,3D or 4D (n=1,2,3). If not one of those exit*)
	depth=ArrayDepth[data];
	If[depth>4, Return[Message[PlotData::set]]];
	n=depth-1;

	(*Determine data dimensions en make string displaying data dimensions*)
	dim=Dimensions[data];
	str="Displaying "<>DataString[dim];

	(*Initialize slice ranges and data range*)
	rangex = dim[[1]];
	rangey = dim[[2]];

	(*Rescale data between 0 and 1*)
	{mind,maxd}=If[ListQ[OptionValue[PlotRange]] && Length[OptionValue[PlotRange]]==2,OptionValue[PlotRange],{Min[data],Max[data]}];
	If[mind==maxd,maxd=mind+0.01];
	(*data=(##[data,{mind,maxd}])&@@{{ToByte2,ToByte3,ToByte4}[[n]]};*)

	tab1=Column[{
		ManPannel["Slice Selection",{
			{"Slice (1-"<>ToString[dim[[1]]]<>")",Control@{{z,Round[dim[[1]]/2],""},1,dim[[1]],1}}
			}]
		,
		ManPannel["Plot Range",{
			{"Show background image",Control@{{pl,True,""},{True,False}}},
			{"Min value",Control@{{min,mind,""},mind,max-0.0001,(max-mind)/100, Appearance -> "Labeled"}},
			{"Max value",Control@{{max,maxd,""},min+0.0001,maxd,(maxd-min)/100, Appearance -> "Labeled"}},
			{"Min Clipping",Control@{{minclip,Black,""},ColorSlider[#,ImageSize->{Automatic,15}]&}},
			{"Max Clipping",Control@{{maxclip,White,""},ColorSlider[#,ImageSize->{Automatic,15}]&}},
			{"Transparent Clipping",Control@{{transclip,False,""},{True,False}}}
			}]
		,
		ManPannel["Plot Options",{
			{"Grid spacing",Control@{{gs,3,""},1,10,1}},
			{"Grid size",Control@{{gf,{0.003,Medium},""},{{0.001,Tiny}->"Thin",{0.003,Medium}->"Normal",{0.005,Large}->"Thick"}}},
			{"Plot Size",Control@{{ps,400,""},psizes,ControlType->PopupMenu}},
			{"Color function",Control@{{color,"BlackToWhite",""},colors,ControlType->PopupMenu}},
			{"Plot Title",Control@{{label,"",""},InputField[#,String]&}}
			}]
		,
		ManPannel["Grid Options",{
			{"Normal grid",Control@{{norm,False,""},{True,False}}},
			{"Normal grid color",Control@{{ncol,Blue,""},ColorSlider[#,ImageSize->{Automatic,15}]&}},
			{"Deformed grid",Control@{{def,False,""},{True,False}}},
			{"Deformed grid color",Control@{{dcol,Red,""},ColorSlider[#,ImageSize->{Automatic,15}]&}},
			{"Deformation gridlines",Control@{{defl,True,""},{True,False}}},
			{"Grid color",Control@{{lcol,Green,""},ColorSlider[#,ImageSize->{Automatic,15}]&}},
			{"Deformation arrows",Control@{{arr,False,""},{True,False}}},
			{"Arrow color",Control@{{acol,Black,""},ColorSlider[#,ImageSize->{Automatic,15}]&}}
			}]
		}];

	tab2=Column[{
		ManPannel["Export plot",{
			{"File Type",Control@{{fileType,".jpg",""},files}},
			{"Export Size",Control@{{size,400,""},sizes,ControlType->PopupMenu}},
			{"Export",Button["Save Plot",SaveImage[Dynamic[exp],FileType->fileType,ImageSize -> size],Method->"Queued",ImageSize->150]}
			}]
		}];

	control={{{pannel,1,""},{1->"Plotting options",2->"Exporting options"}},Delimiter,PaneSelector[{1->tab1,2->tab2},Dynamic[pannel]]};

	Manipulate[
		If[!ListQ[data],Return[]];

		settings={{dim,dir},{min,max},label,ps,color,{gs,gf,ncol,dcol,lcol,acol},{def,norm,defl,arr,pl}};
		exp=PlotDefi[data[[z]],shift[[z]],{dim,dir},{mind,maxd,min,max},LabelFunc[label,{z}],ps,color,If[transclip,Transparent,{minclip,maxclip}],{gs,gf,ncol,dcol,lcol,acol},{def,norm,defl,arr,pl}]
		,##,
		(*Manipulate function options*)
		ControlPlacement->Right,
		Deployed->True
		]&@@control
	]


(* ::Subsection:: *)
(*MakeSliceImages*)


(* ::Subsubsection::Closed:: *)
(*LegendImage*)


SyntaxInformation[LegendImage] = {"ArgumentsPattern" -> {_, _, _}};

LegendImage[colf_, w_, lab_] := Block[{rast, lc, mc, rc},
	rast = Raster[{Range[256]/256.}, {{0, 0}, {1, 1}}, ColorFunction -> colf];
	{lc, mc, rc} = If[ColorDistance[ColorData[colf][#], White] > ColorDistance[ColorData[colf][#], Black], 
		White, Black] & /@ {0, 0.5, 1};

	ImagePad[Rasterize[Graphics[{rast,
		Inset[Style[lab[[1]], lc, Bold, 20], {0.05, 0.5}],
		Inset[Style[lab[[2]], rc, Bold, 20], {0.95, 0.5}],
		Inset[Style[lab[[3]], mc, Bold, 20], {0.5, 0.5}]}
		, AspectRatio -> 40/w, ContentSelectable -> False, ImageSize -> {w - 40, 40}
		, PlotRange -> {{0, 1}, {0, 1}}], RasterSize -> {w - 40, 40}
	], 20, White]
]


(* ::Subsubsection::Closed:: *)
(*MakeSliceImages*)


Options[MakeSliceImages]={
	PlotRange -> Automatic, 
	ColorFunction -> "GrayTones", 
	ClippingStyle -> Automatic,
	ImageLegend -> False,
	ImageOrientation -> Automatic,
	ImageSize -> 300,
	MaskOpacity -> 0.6
};

SyntaxInformation[MakeSliceImages]={"ArgumentsPattern"->{_,_.,_.,OptionsPattern[]}};

MakeSliceImages[selData_, opts:OptionsPattern[]]:=MakeSliceImages[selData, {1,1,1}, opts]

MakeSliceImages[selData_, {selMask_, vals_?ListQ}, opts:OptionsPattern[]]:=MakeSliceImages[selData, {selMask,vals}, {1,1,1}, opts]

MakeSliceImages[selData_, vox:{_, _, _}, opts:OptionsPattern[]]:=MakeSliceImages[selData, {0, {}}, vox, opts]

MakeSliceImages[selData_, {selMask_, vals_?ListQ}, vox:{_,_,_}, OptionsPattern[]]:=Block[{
	colo, pdat, ran, ratio, datf, size, colF, mdat, rule, bar, pl1, pl2, 
	dim, dim1, dim2, d1, d2, pl ,ml, sz, n, imSize, clip
	},

	colo = OptionValue[ColorFunction];
	{colo, cols} = If[StringQ[colo], {colo, "DarkRainbow"}, colo];
	colF = If[MemberQ[colorFunctions[[All,1]], colo], colo, "GrayTones"]/.colorFunctions;
	SeedRandom[1234];
	rule = N@Thread[vals -> RandomSample@Rescale[Range[0,Length@vals]][[2;;]]];

	clip = OptionValue[ClippingStyle];
	clip = If[clip===Automatic, colF/@{0, 1}, If[ColorQ[clip], {clip, colF[1]}, clip]];

	Table[
		(*get the data*)
		pdat = N@selData[[n]];
		mdat = N@If[selMask =!= 0, N[selMask[[n]]] /. rule, 0 pdat];

		(*find the range*)
		datf = DeleteCases[Flatten[pdat][[;;;;10]], 0.];
		ran = If[OptionValue[PlotRange] === Automatic, If[datf==={}, {0, 1}, {0, Quantile[datf, .99]}], OptionValue[PlotRange]];

		size = vox[[{{2,3}, {1,2}, {1,3}}[[n]]]];
		bar = BarLegend[{colF/@Range[0, 1, .01], ran}, LabelStyle->Directive[{Black, Bold, 12}]];

		imSize = OptionValue[ImageSize];

		(*loop over the slices, 1 axial, 2 cor, 3 sag*)
		MapThread[(
			dim = {dim1, dim2} =  Dimensions[#1];
			{d1, d2} = (dim size);
			ratio = N[Divide@@(dim size)];

			{pl, ml, ratio, sz} = Switch[OptionValue[ImageOrientation],
				"Horizontal", 
				If[d2 <= d1, {Reverse@Transpose@#1, Reverse@Transpose@#2, 1/ratio, {imSize, Automatic}}, {#1, #2, ratio, {imSize, Automatic}}], 
				"Vertical", 
				If[d1 <= d2, {Reverse@Transpose@#1, Reverse@Transpose@#2, 1/ratio, {Automatic,imSize}}, {#1 ,#2 ,ratio, {Automatic, imSize}}],
				_,
				If[d1 <= d2, {#1, #2, ratio, {imSize, Automatic}}, {#1, #2, ratio, {Automatic, imSize}}] 
			];

			pl1 = ArrayPlot[pl, AspectRatio->ratio, Frame->False, ImageSize->sz, PlotRangePadding->1, 
				PlotRange->ran, ColorFunction->colF, ClippingStyle->clip];
			pl2 = ArrayPlot[ml, ColorFunction->(Directive[{Opacity[OptionValue[MaskOpacity]], ColorData[cols][#]}]&), 
				ColorFunctionScaling->False, ColorRules->{0.->Transparent}];
			If[OptionValue[ImageLegend], Legended[Show[pl1, pl2], bar], Show[pl1, pl2]]
		)&, {pdat, mdat}]
	,{n, 1, 3}]
]


(* ::Subsubsection::Closed:: *)
(*GetSliceData*)


SyntaxInformation[GetSliceData]={"ArgumentsPattern"->{_,_,_.}};

GetSliceData[data_,offsets_]:=GetSliceData[data,offsets,{1,1,1}]

GetSliceData[data_,offsets_,vox_]:=Block[{off},
	off=Round[offsets/vox];
	{data[[off[[1]]]],
	Reverse/@Transpose@data[[All,off[[2]]]],
	Reverse/@Transpose[data[[All,All,off[[3]]]],{2,3,1}]
	}
]


(* ::Subsubsection::Closed:: *)
(*GetSlicePosision*)


Options[GetSlicePositions]={ MakeCheckPlot->False, DropSlices->{1,1,1}, PeakNumber->{1,1,2}};

SyntaxInformation[GetSlicePositions]={"ArgumentsPattern"->{_,_.,OptionsPattern[]}};

GetSlicePositions[data_, opts:OptionsPattern[]]:=GetSlicePositions[data, {1,1,1},opts]

GetSlicePositions[data_,vox_,OptionsPattern[]]:=Block[{
	dat,peaks,len,fil,ran,pers,min,max,result,num,s1,s2,s3,mid,mn,tot},
	(*get the max intensity slice*)
	pers={{2,3},{1,3},{1,2}};
	{s1,s2,s3}=OptionValue[DropSlices];

	(*find slice positions*)
	result=(
		(*get the range and max number of locations*)
		ran=OptionValue[DropSlices][[#]];
		num=OptionValue[PeakNumber][[#]];

		(*remove slices if needed*)
		dat=Switch[#,
			1,data[[All,s2;;-s2,s3;;-s3]],
			2,data[[s1;;-s1,All,s3;;-s3]],
			3,data[[s1;;-s1,s2;;-s2,All]]
		];

		(*get the data profile*)
		(*dat=MeanNoZero@Flatten[dat,pers[[#,1;;2]]];*)

		mn = MeanNoZero@Flatten[dat, pers[[#,1;;2]]];
		tot = Total@Flatten[dat, pers[[#,1;;2]]];
		dat = Rescale[mn] + 0.5 Rescale[tot];

		(*constrain and filter data*)
		len = Length[dat];
		dat[[;;ran]] = 0;
		dat[[-ran;;]] = 0;
		fil = Clip[len/50., {2, Infinity}];
		dat = Rescale@GaussianFilter[dat, fil];

		(*find the peak locations and select the ones above treshhold*)
		peaks = FindPeaks[dat, fil];
		peaks = Select[peaks, #[[2]]>0.5&];

		(*select peaks closes to center*)
		mid = {len,1}/2.;
		num=Min[{Length[peaks],num}];
		Join[{dat, peaks, mid},If[num===0,
				{{},{}},
				peaks=Nearest[peaks,mid,num];
				{peaks,peaks[[All,1]]}
			]
		]
	)&/@{1,2,3};

	(*make chekc plot if needed*)
	If[OptionValue[MakeCheckPlot],Print[Row[Show[
		ListLinePlot[#[[1]],PlotStyle->Black],ListPlot[#[[2]],PlotStyle->Directive[{PointSize[Large],Red}]],
		ListPlot[#[[4]],PlotStyle->Directive[{PointSize[Large],Green}]],
		ListPlot[{#[[3]]},PlotStyle->Directive[{PointSize[Large],Blue}]]
	,Axes->True,ImageSize->200
	]&/@result]]];

	(*give te location in mm*)
	vox result[[All,-1]]
]


(* ::Subsection::Closed:: *)
(*PlotContour*)


Options[PlotContour] = {
	ContourColor -> Gray,
	ContourOpacity -> 0.5,
	ContourSpecularity -> 50,
	ContourColorRange -> Automatic,
	ColorFunction -> "SunsetColors",
	ContourSmoothRadius -> None,
	ContourScaling -> "World",
	ContourResolution -> Automatic
};

SyntaxInformation[PlotContour] = {"ArgumentsPattern" -> {_, _., OptionsPattern[]}};

PlotContour[dati_, opts:OptionsPattern[]]:=PlotContour[dati, {1,1,1}, opts]

PlotContour[dati_, vox_, opts:OptionsPattern[]] := Block[{
		data, smooth, color, opac, dim , pad, col, style, crp, spec,
		ran, coldat, colfunc, scale, range, reso, cdim, cfunc
	},

	If[ArrayDepth[dati]===4,
		SeedRandom[12345];
		Show[PlotContour[#[[1]], vox, ContourColor->#[[2]], opts]&/@ Transpose[{Transpose[dati], RandomColor[Length@First@dati]}]]
		,
		{smooth, reso, scale, color, opac, spec} = OptionValue[{ContourSmoothRadius, ContourResolution, ContourScaling, 
			ContourColor, ContourOpacity, ContourSpecularity}];

		If[smooth === None, smooth = 0];

		If[N[Max[dati]] === 0., 
			Graphics3D[],

			dim = Dimensions@dati;
			pad = 2 (smooth + 1);

			{data, crp} = AutoCropData[Unitize@dati, CropPadding->0];
			data = ArrayPad[data, pad];

			If[IntegerQ[smooth], If[smooth>0, data = GaussianFilter[data, smooth]]];
			data = SparseArray[data];

			col = If[ColorQ[color], color, If[color==="Random", RandomColor[], GrayLevel[1.]]];
			style = Directive[{Opacity[opac], col, Specularity[Lighter@col, spec]}];

			colfunc = If[!ArrayQ[color],
				Automatic,
				ran = OptionValue[ContourColorRange];
				cfunc = OptionValue[ColorFunction];
				ran = If[ran === Automatic,
					Quantile[DeleteCases[N@Flatten[color], 0.], {0.02, 0.98}],
					ran];
				coldat = Clip[Rescale[color, ran], {0, 1}];
				cdim = Dimensions[coldat];
				style = Directive[{Opacity[opac], Specularity[Red, 0]}];
				Function[{z, y, x},
					ColorData[cfunc][coldat[[
						Clip[Round[x/vox[[1]] + 0.5], {1, cdim[[1]]}],
						Clip[Round[y/vox[[2]] + 0.5], {1, cdim[[2]]}], 
						Clip[Round[z/vox[[3]] + 0.5], {1, cdim[[3]]}]
					]]]
				]
			];

			reso = Which[reso===Automatic, 2 vox, IntegerQ[reso], reso vox, VectorQ[reso], reso, True, 2 vox];
			reso = Reverse@Round[vox Dimensions[data] / reso];

			scale = Switch[scale, "World", Reverse[vox], _, {1,1,1}];

			range = Reverse[Partition[crp, 2]] + {{-pad-1, pad}, {-pad-1, pad}, {-pad-1, pad}};
			dim = Reverse[dim];

			ListContourPlot3D[data,
				Contours -> {0.5}, Lighting -> "ThreePoint",
				Mesh -> False, BoundaryStyle -> None, Axes -> True, 
				SphericalRegion -> True,ColorFunctionScaling -> False, 

				ColorFunction -> colfunc, 
				ContourStyle -> style, 

				MaxPlotPoints -> reso,
				ImageSize -> 300,
				DataRange -> scale range,
				BoxRatios -> scale dim,
				PlotRange -> Thread[{0, scale dim}]
			]
		]
	]
]


(* ::Subsection::Closed:: *)
(*Link3DGraphic*)


viewPoint = {1.3, -2.4, 2.0};
viewVertical = {0., 0., 1.};
viewAngle = 20. Degree;
viewCenter = {0.5, 0.5, 0.5};

Link3DGraphic[graphics_]:=Show[graphics, SphericalRegion -> True, 
	ViewPoint -> Dynamic[viewPoint],
	ViewVertical -> Dynamic[viewVertical],
	ViewAngle -> Dynamic[viewAngle],
	ViewCenter -> Dynamic[viewCenter]
]


ShowLink[]:=Dynamic[Grid[{
	{"ViewPoint: ", Round[viewPoint,.01]}, 
	{"ViewVertical: ", Round[viewVertical,.01]}, 
	{"ViewAngle: ", Round[viewAngle/Degree,.01]}, 
	{"ViewCenter: ", Round[viewCenter,.01]}}, Alignment -> Left]]

(* ::Subsection::Closed:: *)
(*GenerateRotationFrames*)


Options[GenerateRotationFrames] = {
	ImageSize -> 500
};

GenerateRotationFrames[gr3D_, nFrames_, OptionsPattern[]] := Module[{initVp},
	If[ListQ[gr3D],
		opt = Thread[{ViewPoint, ViewVertical, ViewAngle, ViewCenter} -> ({ViewPoint, ViewVertical, ViewAngle, ViewCenter} /. AbsoluteOptions@First@gr3D)];
		ImageAssemble/@Thread[GenerateRotationFrames[Show[#, opt],nFrames]&/@gr3D]
		,
		opt = Thread[{ViewPoint, ViewVertical, ViewAngle, ViewCenter} -> ({ViewPoint, ViewVertical, ViewAngle, ViewCenter} /. AbsoluteOptions@gr3D)];
		(*{pt, cent} = ViewVector /. AbsoluteOptions[gr3D, ViewVector];*)
		gr = Show[gr3D, opt];
		{pt, cent} = ViewVector /. AbsoluteOptions[gr, ViewVector];
		pt = ViewPoint/. AbsoluteOptions[gr, ViewPoint];
		Table[Rasterize[Show[gr,(*Graphics3D[InfiniteLine[{0,0,0}, {0,0,1}]]*) ViewPoint -> RotationTransform[(2 Pi/nFrames) i, {0, 0, 1}, {0,0,0}][pt](*, cent}*)],ImageSize -> OptionValue[ImageSize]], {i, 0, nFrames - 1}]
	]
];


(* ::Subsection::Closed:: *)
(*PlotSegmentations*)


Options[PlotSegmentations] = {
	ImageSize -> 400, 
	ContourOpacity -> 0.6,
	ContourSpecularity -> 200,
	ColorFunction -> "RomaO", 
	ContourSmoothRadius -> 2,
	RandomizeColor -> True,
	ContourResolution -> Automatic
};


SyntaxInformation[PlotSegmentations] = {"ArgumentsPattern" -> {_, _, _., OptionsPattern[]}};

PlotSegmentations[seg_, vox_, opts : OptionsPattern[]] := PlotSegmentations[seg, None, vox, opts]

PlotSegmentations[segI_, boneI_, vox_, opts : OptionsPattern[]] := Block[{
		seg, bone,
		smooth, size, plotb, segM, nSeg, rSeg, cols, plotm, ranCol, op, res, spec
	},
	{smooth, cols, size, ranCol, op, res, spec} = OptionValue[{ContourSmoothRadius, ColorFunction, ImageSize, 
		RandomizeColor, ContourOpacity, ContourResolution, ContourSpecularity}];

	{seg, bone} = If[IntegerQ[boneI],
		{SelectSegmentations[segI, Range[1, boneI]], SelectSegmentations[segI, Range[boneI+1, Max[segI]]]},
		{segI, boneI}
	];

	plotb = Which[
		ArrayQ[bone],
		PlotContour[If[ArrayDepth[bone]===3, Unitize@bone, Unitize@Total@Transpose@bone], vox, 
			ContourColor -> Lighter@Gray, ContourOpacity -> 1, ContourSmoothRadius -> smooth, 
			ContourResolution -> res
		],
		True, Graphics3D[]
	];

	plotm = If[N[Max[seg]] === 0., 
		Graphics3D[],

		segM = If[ArrayDepth[seg]===3, First@SplitSegmentations[seg], seg];
		nSeg = Length@First@segM;
		rSeg = Range[nSeg];

		If[ColorQ[cols],
			cols = ConstantArray[cols, nSeg];,
			cols = Reverse[ColorData[OptionValue[ColorFunction]] /@ Rescale[rSeg]];
			If[ranCol, SeedRandom[1234]; cols = cols[[RandomSample[rSeg]]]];
		];

		Show[Table[PlotContour[segM[[All, i]], vox, ContourColor -> cols[[i]], ContourOpacity -> op, 
			ContourSpecularity -> spec, ContourSmoothRadius -> smooth, 
			ContourResolution -> res], {i, 1, nSeg}]]
	];

	Show[plotm, plotb, ViewPoint -> Front, ImageSize -> size, Boxed -> False, Axes -> False, SphericalRegion -> True]
]


(* ::Subsection:: *)
(*General Plot Functions*)


(* ::Subsubsection::Closed:: *)
(*PlotCorrection*)


SyntaxInformation[PlotCorrection] = {"ArgumentsPattern" -> {_}};

PlotCorrection[w_]:=Module[{sel},
	Switch[
		Dimensions[w][[2]],
		6,
		GraphicsGrid[Partition[MapThread[
		ListPlot[#1,PlotRange->Full,Joined->True,PlotLabel->Style[#2,Bold],AspectRatio->.5,PlotStyle->Thick]&,
		{
			(({1,1,1,1,1,1}*Transpose[w])+{0,0,0,0,0,0})[[#]]&/@{1,2;;3,4;;5,6},
			{"Rotation [Degree]","Translation [mm]","Scale","Scew "},
			{{-3,3},{-4,4},{.95,1.05},{-.05,.05}}
			}],2],ImageSize->600]
		,
		12,
		sel=If[Mean[w][[7;;12]]==={1.,1.,1.,0.,0.,0.},2,4];

		Grid[Partition[MapThread[
			ListLinePlot[#1, PlotLabel -> Style[#2, Bold], PlotLegends -> #3,
				PlotRange -> {{1,Length[#1[[1]]]},Full},AxesOrigin->{1,Mean[#4]}, AspectRatio -> .5, PlotStyle -> (Directive[{Thick,#}]&/@{Red,Green,Blue}),
				AxesStyle->Directive[{Thick,Black}],LabelStyle->Directive[{Bold,Black,FontFamily->"Helvetica"}],
				ImageSize -> 400, AxesOrigin -> #5
			] &, {
				({1, 1, 1, 1}*Partition[Transpose[w], 3]) + {0, 0, 0, 0},
				{"Rotation [Degree]", "Translation [mm]", "Scale", "Scew "},
				{{"Coronal axis (roll)", "Sagittal axis (pitch)","Axial axis (yaw)"},
				{"Coronal direction", "Sagittal direction", "Axial direction"},
				{"Coronal direction", "Sagittal direction", "Axial direction"},
				{"Coronal direction", "Sagittal direction", "Axial direction"}},
				{{-3, 3}, {-4, 4}, {.95, 1.05}, {-.05, .05}},
				{{0, 0}, {0, 0}, {0, 1}, {0, 0}}
			}[[All,;;sel]]
		], 2]]
	]
]


(* ::Subsubsection::Closed:: *)
(*ListSpherePlot*)


Options[ListSpherePlot] = {SphereSize->2, SphereColor->Automatic}

SyntaxInformation[ListSpherePlot] = {"ArgumentsPattern" -> {_, OptionsPattern[]}};  

ListSpherePlot[ptsi_, OptionsPattern[]] := Module[{cols, graphics, pt, pc, ran, len,coli,size},
	coli = OptionValue[SphereColor];
	size = OptionValue[SphereSize];

	len = Length[ptsi];
	ran = RandomSampleFix[len];
	cols = If[coli === Automatic,
		(ColorData[1] /@ N[Range[1, len]])[[ran]],
		ConstantArray[coli, len]
	];

	graphics = MapThread[(
		pt = #1; pc = #2;
		If[ArrayDepth[pt] == 1,
			{pc, Sphere[pt, size]},
			{pc, Sphere[#, size]} & /@ pt
		]
	) &, {ptsi, cols}];
	Graphics3D[Flatten[graphics], Lighting -> "Neutral"]
]

RandomSampleFix[len_] := RandomSampleFix[len] = RandomSample[Range[len]];


(* ::Subsubsection::Closed:: *)
(*PlotDuty*)


SyntaxInformation[PlotDuty] = {"ArgumentsPattern" -> {{_,_,_},_.}};

PlotDuty[{grad_, bval_, ord_}, mode_:True] := Module[{grads, order, testgr, mn, ran},
	grads = Abs[grad*Sqrt[bval]];
	grads = If[NumberQ[bval], grads, Flatten[grads, 1]];
	grads = (grads - Min[grads])/(Max[grads] - Min[grads]);
	ran = MinMax[grads];
	order = If[! mode, Range[Length[grads]], ord];
	testgr = Mean[Transpose[Partition[#, 10, 1]]] & /@ Transpose[grads[[order]]];
	mn = Max /@ Transpose@testgr;
	Show[
		ListLinePlot[testgr, 
			PlotLabel -> "Average Gradient Load", 
			AxesStyle -> Directive[{Thick, Black}],
			LabelStyle -> Directive[{Black, Bold, 12, FontFamily -> "Helvetica"}],
			Ticks -> {Automatic, {{0.1, "Min G"}, {.55, "Avrg. G"}, {1, "Max G"}}}, 
			PlotRange -> {0, 1},
			GridLines -> {None, {00.1, 0.55, 
			1, {Max@mn, Directive[Red, Thick]}}}
		],
		ListLinePlot[mn, PlotStyle -> Directive[Black, Dashed, Thick]]
	]
]


(* ::Subsubsection::Closed:: *)
(*GradientPlot*)


Options[GradientPlot] = {PlotSpace -> "bspace", PlotColor -> "Auto", SphereSize -> 0.05 , PositiveZ -> False};

SyntaxInformation[GradientPlot] = {"ArgumentsPattern" -> {_, _., OptionsPattern[]}};

(*GradientPlot[bmat_,opts:OptionsPattern[]]:=Block[{vec,val},
	{val,vec}=BmatrixInv[bmat];
	GradientPlot[vec,val,opts]]*)

GradientPlot[veci_, val_, OptionsPattern[]] := Block[{pts, range, norm, mnorm, cnorm, col, pcol, vec}, 

	vec = If[OptionValue[PositiveZ],
		SignNoZero[#[[3]]]#&/@veci,
		veci
	];

	pts = Switch[OptionValue[PlotSpace], 
		"bspace", vec val, 
		"qspace", vec Sqrt[val]
	];
	norm = Norm /@ pts;
	mnorm = Max[Abs[pts]];
	cnorm = norm/(1.25 Max[norm]);

	range = ConstantArray[{-1.1, 1.1} mnorm, 3];
	col = OptionValue[PlotColor];

	pcol = If[MemberQ[ColorData["Gradients"], col],
		ColorData[col],
		If[ColorQ[col],
			col &,
			ColorData["SunsetColors"]
		]
	];

	Graphics3D[MapThread[
		{pcol[#2], Sphere[#1, OptionValue[SphereSize] mnorm]} &,
		{pts, cnorm}], ImageSize -> 400, BoxStyle -> Thick, 
		SphericalRegion -> True, Lighting -> "Neutral", BoxRatios -> 1, 
		PlotRange -> range]
]


(* ::Subsubsection::Closed:: *)
(*PlotMoments*)


SyntaxInformation[PlotMoments] = {"ArgumentsPattern" -> {_, _, _}};

PlotMoments[fmom_, te_, t_] := Module[{plab, rlab, cols, alabs, grnr, fun, max, len, sc, lens
},

plab = {"Gx", "Gy", "Gz"};
rlab = {"Gradients", "Zeroth order moment", "First order moment", "Second order moment", "Third order moment"};
cols = {Black, Red, Purple, Blue, Green};
alabs = {
"mT \!\(\*SuperscriptBox[\(m\), \(-1\)]\)",
"mT \!\(\*SuperscriptBox[\(m\), \(-1\)]\) \!\(\*SuperscriptBox[\(ms\), \(-1\)]\)",
"mT \!\(\*SuperscriptBox[\(m\), \(-1\)]\) \!\(\*SuperscriptBox[\(ms\), \(-2\)]\)",
"mT \!\(\*SuperscriptBox[\(m\), \(-1\)]\) \!\(\*SuperscriptBox[\(ms\), \(-3\)]\)",
"mT \!\(\*SuperscriptBox[\(m\), \(-1\)]\) \!\(\*SuperscriptBox[\(ms\), \(-4\)]\)"
};

plots = MapIndexed[(
grnr = #2[[1]];
Column[
Prepend[MapIndexed[(
fun = #1;
max = Max[Abs[Table[fun, {t, 0, te, .25}]]];
len = IntegerLength[Round[max]] - 1;

If[len <= 1,
sc = 1;
lens = "";
,
sc = 10^len;
lens = ToString[Superscript[10, len], StandardForm];
];

Plot[fun/sc, {t, -.1 te, 1.5 te}, 
PlotRange -> {{0, te}, 1.1 {-max, max}/sc}, 
Exclusions -> None,
AspectRatio -> .15, ImageSize -> 800, 
PlotStyle -> Directive[{cols[[grnr]], Thick}],
AxesLabel -> {"ms", lens <> " " <> alabs[[grnr]]}, 
PlotLabel -> plab[[#2[[1]]]], 
LabelStyle -> Directive[Black, Bold, FontFamily -> "Arial"]]
) &, #1],
Style[rlab[[grnr]], Directive[Black, Bold, FontFamily -> "Arial"]]],
Alignment -> Center]
) &, fmom];

Manipulate[
pl=plots[[(n+1)]],

{{n,0,"Moment"}, 0, Length[plots]-1, 1},
Button["Save Image",SaveImage[pl], Method -> "Queued"]
]
]


(* ::Subsubsection::Closed:: *)
(*PlotIVIM*)


Options[PlotIVIM] = {Method -> "", PlotColor -> {Red, Green, Blue, Black}, NormalizeIVIM->"Fit",PlotRange->"Auto",ImageSize->400}

SyntaxInformation[PlotIVIM] = {"ArgumentsPattern" -> {_, _, _, OptionsPattern[]}};

PlotIVIM[val_, data_, bvals_, OptionsPattern[]] := 
Module[{pdat, pdatL, rule, stdash, stsol, lstyle, pl, vals = val, 
func, cols, s0, f1, dc, pdc1, f2,f3, pdc2, bm,plr},
DynamicModule[{plot},
cols = OptionValue[PlotColor];
cols = If[Length[cols] != 4, {Red,Darker@ Green, Blue, Black}, cols];

If[OptionValue[NormalizeIVIM]==="Fit",
pdatL = {bvals, Log[data/vals[[1]]]} // Transpose;
pdat = {bvals, data/vals[[1]]} // Transpose;
vals[[1]] = 1;
,
pdatL = {bvals, Log[data/data[[1]]]} // Transpose;
pdat = {bvals, data/data[[1]]} // Transpose;
vals[[1]] = vals[[1]]/data[[1]];
];

stdash = Directive[{Thick, #, Dashed}] &;
stsol = Directive[{Thick, #}] &;
lstyle = Directive[Black, Bold, If[OptionValue[ImageSize]<=200,Small,Medium], FontFamily -> "Helvetica"];

Switch[Length[vals],
2,
func = s0(f3*Exp[-bm*dc]);
rule = Flatten@Append[Thread[{s0, dc} -> vals], {f2 -> 0,f1->0}];,
4,
func = s0(f3*Exp[-bm*dc] + f1*Exp[-bm*pdc1]);
rule = Append[Thread[{s0, f1, dc, pdc1} -> vals], f2 -> 0];,
6,
func = s0(f3*Exp[-bm*dc] + f1*Exp[-bm*pdc1] + f2*Exp[-bm*pdc2]);
rule = Thread[{s0, f1, f2, dc, pdc1, pdc2} -> vals];,
_,
Return[Message[PlotIVIM::vals]]];

plr=If[OptionValue[PlotRange]==="Auto",{1.2 Min[pdatL[[All,2]]], 0.1},OptionValue[PlotRange]];

pl = Plot[#6 /. {f1 -> #1, f2 -> #2, f3->#3} /. rule, {bm, -0.1, #5}, 
PlotStyle -> ({stdash[#4[[1]]], stsol[#4[[1]]]}[[#4[[2]]]]), 
PlotRange -> ({{0, 1.1}, plr }[[#7]]), 
LabelStyle -> lstyle, Frame -> {{True, False}, {True, False}}, 
FrameStyle -> Thick, ImageSize -> OptionValue[ImageSize], 
FrameLabel -> {"b-value [\!\(\*SuperscriptBox[\(mm\), \(2\)]\)/s]", {"Signal", "Log[Signal]"}[[#7]]}] &;

plot = GraphicsRow[{
Show[
pl[f1, f2, 1-f1-f2, {cols[[4]], 2}, #, func, 1],
pl[1-f2, 0, 0, {cols[[1]], 1}, #, func, 1],
pl[0, 1, 0, {cols[[2]], 1}, #, func, 1],
pl[0, 0,  1-f1-f2, {cols[[3]], 1}, #, func, 1],
ListPlot[pdat, PlotStyle -> {cols[[4]], PointSize[0.02]}]
],
Show[
pl[f1, f2, 1-f1-f2, {cols[[4]], 2}, #, Log[func], 2],
pl[1-f2, 0, 0, {cols[[1]], 1}, #, Log[func], 2],
pl[0, 1, 0, {cols[[2]], 1}, #, Log[func], 2],
pl[0, 0, 1-f1-f2, {cols[[3]], 1}, #, Log[func], 2],
ListPlot[pdatL, PlotStyle -> {cols[[4]], PointSize[0.02]}]
]
}] &;

If[OptionValue[Method] === "Dynamic",
Manipulate[plot[bran],{{bran, 1.1 Max[bvals], "Plot Range"}, 10, 1.5 Max[bvals], 10},SaveDefinitions -> True],
plot[Max[bvals]]
]
]
]


(* ::Subsubsection::Closed:: *)
(*PlotSequence*)


SyntaxInformation[PlotSequence] = {"ArgumentsPattern" -> {_, _}};

PlotSequence[(*{seq_,hw_,te_}*)inp_, t_] := DynamicModule[{
hw1, Gx, Gy, Gz, seq2, len, pdat, seq, te, start, stop, x, clip, plots
},

{len, pdat} = If[Dimensions[inp] === {3}, {1, {inp}}, {Length[inp], inp}];
te = Last@First@pdat;
hw1 = Piecewise[{{1, t <= te}, {0, t > te}}];
seq = {PiecewiseExpand[#[[1]]], PiecewiseExpand[hw1 #[[1]]]} & /@ pdat;

plots = Map[(
seq2 = #;
Plot[seq2[[#]],
{t, -0.5 te, 1.5 te}, PlotRange -> {-100, 100}, 
PlotStyle -> {Thick, Black}, Exclusions -> None,
AspectRatio -> .15, ImageSize -> 1000, 
PlotPoints -> Round[te/.25],
Axes -> False, Frame -> True, 
FrameTicks -> {{None, None}, {Range[0, 150, 10], None}},
PlotLabel -> {"Gx", "Gy", "Gz"}[[#]], 
LabelStyle -> {FontFamily -> "Helvetica", Bold},
GridLines -> {{{0, Directive[Red, Thick]}, {te/2, 
Directive[Red, Thick]}, {te, 
Directive[Red, Thick]}}, {0}}] & /@ Range[3]
) &, seq, {2}];

Manipulate[

Column[(Show[plots[[x, clip, #]], PlotRange -> ({{start, stop}, {{-Gx, Gx}, {-Gy, Gy}, {-Gz, Gz}}[[#]]})]) & /@ Range[3]],

{{x, 1, "Sequence"}, 1, len, 1, Appearance -> "Labeled"},
{{clip, 1, "Clip the te"}, {1 -> "False", 2 -> "True"}},

{{Gx, 90, "Gx"}, 5, 100, 10, Appearance -> "Labeled"},
{{Gy, 90, "Gy"}, 5, 100, 10, Appearance -> "Labeled"},
{{Gz, 90, "Gz"}, 5, 100, 10, Appearance -> "Labeled"},

{{start, Round[-0.07 te], "Time start"}, Round[-0.07 te], Round[.5 te], Appearance -> "Labeled"},
{{stop, Round[1.15 te], "Time end"}, Round[0.5 te], Round[1.20 te], Appearance -> "Labeled"}
]
]


(* ::Subsection::Closed:: *)
(*ColorFAPlot*)


SyntaxInformation[ColorFAPlot] = {"ArgumentsPattern" -> {_}};  

ColorFAPlot[tens_] := DynamicModule[{FA, eig, eigv, mid, eigFA, mask},
	mask = Mask[Mean@tens[[1;;3]], 0.00001, MaskSmoothing->False];

	{eig, eigv} = EigensysCalc[tens, PerformanceGoal -> "Quality"];

	FA = Clip[2 FACalc[eig], {0,1}];
	eigv = mask Abs[eigv];

	Manipulate[
		im = Image[all[[i, j, All, All, sel, {3,2,1}]], ColorSpace -> "RGB", ImageSize->size],

		{{j, Round[Length[all[[1]]]/2], "slice"}, 1, Length[all[[1]]], 1},
		{{i, 2, "method"}, {1 -> "raw", 2 -> "FA"}},
		{{sel, 1(*, 2, 3*), "eigenvectors"}, {1 -> "first", 2 -> "second", 3 -> "third"}, ControlType -> SetterBar},
		{{size, 400, "image size"}, {200, 300, 400, 600, 1000}},
		Button["save image", SaveImage[im], Method -> "Queued"],

		{all, ControlType -> None},
		Initialization :> (all = {eigv, FA eigv}; j = Round[Length[all[[1]]]/2])
	]
]


(* ::Subsection::Closed:: *)
(*LoessPlot*)


(* ::Subsubsection::Closed:: *)
(*LoessPlot*)


Options[LoessPlot] = {
	Bandwidth -> Scaled[0.25],
	FitOrder -> 2,
	FitKernel -> "Tricube",
	ConfidenceLevel -> 0.95,
	MaxPlotPoints -> 25,
	PlotStyle -> {},
	PlotRange -> All,
	PredictionInterval -> True,
	PerformanceGoal -> "Speed"
};

LoessPlot[data_, opts : OptionsPattern[]] := Block[{
		bw, deg, ker, confLevel, pred, pPoints, perf, xMin, xMax,
		xGrid, n, max, yFit, error, predError, boot , sel, z
	},

	{bw, deg, ker, z, pred, pPoints, perf} = OptionValue[{Bandwidth, FitOrder, FitKernel, ConfidenceLevel,
		PredictionInterval, MaxPlotPoints, PerformanceGoal}];
	ker = ker /. {"Gaussian" -> 1, _ -> 2};
	z = InverseCDF[NormalDistribution[], 1 - (1 - z)/2];

	{xMin, xMax} = MinMax[data[[All, 1]]];
	xGrid = Subdivide[xMin, xMax, pPoints];
	bw = If[Head[bw] === Scaled, bw[[1]] (xMax - xMin), bw];

	n = Length[data];
	max = Switch[perf, "Speed", 1500, "Quality", 5000];
	boot = Min[{10, Ceiling[n / max]}];
	sel = Min[{n, max}];

	{yFit, error, predError} = Median@Table[
			Transpose[LoessFitC[data[[RandomSample[Range[n], sel]]], xGrid, bw, deg, ker]]
		, {i, boot}] //. {0. -> Missing[]};

	z = If[pred, z predError, z error];
	Show[
		ListLinePlot[
		{Transpose[{xGrid, yFit - z}], Transpose[{xGrid, yFit + z}]}, 
		PlotStyle -> {Directive[Dashed, Gray], Directive[Dashed, Gray]}, 
		Filling -> {1 -> {2}}, FillingStyle -> {LightBlue, Opacity[0.5]}, 
		Evaluate@Join[FilterRules[{opts}, Options[ListLinePlot]], {}], 
		PlotHighlighting -> None],
		ListLinePlot[Transpose[{xGrid, yFit}], 
		Evaluate@Join[FilterRules[{opts}, Options[ListLinePlot]], {}], 
		PlotStyle -> Directive[Thick], PlotHighlighting -> None]
	]
];


(* ::Subsubsection::Closed:: *)
(*LoessFitC*)


LoessFitC = Block[{wMatd}, Compile[{{data, _Real, 2}, {x0, _Real, 0}, {bw, _Real, 0}, {deg, _Integer, 0}, {ker, _Integer, 0}}, Block[{
		xdist, wVec, pick, xdat, ydat, xdatFit, xVec,
		wMat, wMati, yhat, fit, residuals, df, sigma, obs, error, pred
	},

	xdist = Abs[data[[All, 1]] - x0]/bw;
	wVec = Switch[ker, 
		1(*"Gaussian"*), Exp[-2 xdist^2], 
		_(*Tricube*), If[# <= 1, (1 - #^3)^3, 0] & /@ xdist
	];
	pick = UnitStep[wVec - 0.1];

	If[Total[pick] < 3, {0., 0., 0.},
		
		(*condens data for faster calculation*)
		{xdat, ydat} = Transpose@Pick[data, pick, 1];
		xdatFit = Transpose[Table[(xdat + $MachineEpsilon)^i, {i, 0, deg}]];
		xVec = (x0 + $MachineEpsilon)^Range[0., deg];
		wVec = Pick[wVec, pick, 1];

		(*calculate the matrixes needed*)
		wMatd = DiagonalMatrix[wVec, TargetStructure -> "Dense"];
		wMat = Transpose[xdatFit] . wMatd;
		wMati = PseudoInverse[wMat . xdatFit];
		
		(*perform the Loess regression*)
		fit = wMati . wMat . ydat;
		yhat = xVec . fit;
		
		(*calculate the residuals*)
		residuals = ydat - xdatFit . fit;
		df = Total[wVec] - (deg + 1);
		sigma = If[df > 0, (residuals^2 . wVec)/df, 0];

		(*the plus one is to show prediction band instead of confidance band*)
		obs = sigma (xVec . wMati . xVec);
		{error, pred} = {Sqrt[obs], Sqrt[obs + sigma]};
		{yhat, error, pred}
	]
], {{wMatd, _Real, 2}}, RuntimeAttributes -> {Listable}, RuntimeOptions -> "Speed"]];


(* ::Subsubsection::Closed:: *)
(*LoessFit*)


(* ::Section:: *)
(*End Package*)


End[]

EndPackage[]
