(* ::Package:: *)

(* ::Title:: *)
(*QMRITools ElastixTools*)


(* ::Subtitle:: *)
(*Written by: Martijn Froeling, PhD*)
(*m.froeling@gmail.com*)


(* ::Section:: *)
(*Begin Package*)


BeginPackage["QMRITools`ElastixTools`", Join[{"Developer`"}, Complement[QMRITools`$Contexts, {"QMRITools`ElastixTools`"}]]];


(* ::Section:: *)
(*Usage Notes*)


(* ::Subsection::Closed:: *)
(*Functions*)


ClearQMRIToolsTemp::usage =
"ClearQMRIToolsTemp[] clears the temporary directory used by QMRITools for registration."

RegisterData::usage =
"RegisterData[data] registers the data series. If data is 3D it performs multiple 2D registration, if data is 4D it performs multipe 3D registration.
The input data can be in the forms: data, {data, vox}, {data, mask} or {data, mask, vox}.

RegisterData[target, moving] registers the moving data to the target data. target can be 2D or 3D. moving can be the same of one dimension higher than the target.
The inputs target and moving can be in the forms: data, {data, vox}, {data, mask} or {data, mask, vox}.

Output is the registered data with the dimensions of the moving data. 
If OutputTransformation is True it also outputs the translation, rotation scale and skew of all images or volumes.

RegisterData[] is based on DOI: 10.1109/TMI.2009.2035616 and 10.3389/fninf.2013.00050."

RegisterDataSplit::usage = 
"RegisterDataSplit[target, moving] is identical to RegisterData data however left and right side of the data are registered seperately.

Splitting the data is done using the function CutData and merged wit Stich data.
Output is the registered data."


TransformData::usage = 
"TransformData[{data,vox}] deforms the data according to the last output of register data.
The directory should be the TempDirectory were the registration is stored. DeleteTempDirectory should be False."

ReadTransformParameters::usage = 
"ReadTransformParameters[directory] reads the transformation parameters generated by RegisterData. The directory should be the TempDirectory were the registration is stored. DeleteTempDirectory should be False.

Output is the affine transformation vector per volume."


RegisterDataTransform::usage = 
"RegisterDataTransform[target, moving, {moving2nd, vox}] performs the registration exactly as RegisterData. target and moving are the inputs for Registerdata, which can be {data,mask,vox}.
After the registeration is done the moving2nd data is deformed according to the output of the registrtion of moving.

moving2nd can have the same dimensions of moving or one dimension higher (e.g. 3D and 3D or 3D and 4D). 

Output is {registered moving, deformed moving2nd}."

RegisterDataTransformSplit::usage = 
"RegisterDataTransformSplit[target, moving, {moving2nd, vox}] is idenditcal to RegisterDataTransform with the same functionality as RegisterDataSplit.
This means the data is split in two using the function CutData and merged wit Stich data.

Output is {registered moving, deformed moving2nd}."


RegisterDiffusionData::usage =
"RegisterDiffusionData[{dtidata, vox}] registers a diffusion dataset. dtidata should be 4D {slice, diff, x, y}. vox is the voxelsize of the data.
RegisterDiffusionData[{dtidata, dtimask, vox}] registers the data series using the given voxel size only using data within the mask.
RegisterDiffusionData[{dtidata ,vox}, {anatdata, voxa}] registers a diffusion dataset. The diffusion data is also registered to the anatdata.
RegisterDiffusionData[{dtidata, dtimask, vox}, {anatdata, voxa}] registers the data series using the given voxel size only using data within the mask.
RegisterDiffusionData[{dtidata,vox}, {anatdata, anatmask, voxa}] registers the data series using the given voxel size only using data within the mask.
RegisterDiffusionData[{dtidata, dtimask, vox}, {anatdata, anatmask, voxa}] registers the data series using the given voxel size only using data within the mask.

Output is the registered dtidata and, if anatdata is given, the registered dtidata in anatomical space. If OutputTransformation is True it also outputs the translation, rotation scale and skew of all images or volumes."

RegisterDiffusionDataSplit::usage = 
"RegisterDiffusionDataSplit[dtidata, vox] is identical to Register diffusion data however left and right side of the data are registered seperately.
RegisterDiffusionDataSplit[{dtidata, vox}, {anatdata, voxa}] is identical to Register diffusion data however left and right side of the data are registered seperately.
RegisterDiffusionDataSplit[{dtidata, dtimask, vox}, {anatdata, anatmask, voxa}] is identical to Register diffusion data however left and right side of the data are registered seperately.

Splitting the data is done using the function CutData and merged wit Stich data.
Output is the registered data."


RegisterTensorData::usage =
"RegisterTensorData[target, moving] registers the moving tensor to the target tensor. After registration the tensor is reorientated apropriately. 
The inputs target and moving can be in the forms: tensor, {tensor, vox}, {tensor, mask} or {tensor, mask, vox}.
RegisterTensorData[target, moving, tensor] registers the moving data to the target data and applies the deformation to the tensor. 
The inputs target and moving can be in the form: data, {data, vox}, {data, mask} or {data, mask, vox}.
The input tensor can be in the form: tensor or {tensor, vox}.

only \"rigid\", \"affine\" and \"bspline\" can be used as MetReg."


RegisterCardiacData::usage =
"RegisterCardiacData[data] registers the data using a 2D algorithm. data can be 3D or 4D.
RegisterCardiacData[{data,vox}] registers the data series using the given voxel size.
RegisterCardiacData[{data,mask}] registers the data series only using data within the mask.
RegisterCardiacData[{data,mask,vox}] registers the data series using the given voxel size only using data within the mask.

Output is the registered data."


(* ::Subsection::Closed:: *)
(*Options*)


Iterations::usage =
"Iterations is an options for RegisterData, RegisterDiffusionData, and RegisterDataTransform. 
It specifies the number of iterations used by the registration functions."

Resolutions::usage =
"Resolutions is an options for RegisterData, RegisterDiffusionData, and RegisterDataTransform. 
It specifies the number of scale space resolutions used by the registration functions."

HistogramBins::usage =
"HistogramBins is an options for RegisterData, RegisterDiffusionData, and RegisterDataTransform. 
It specifies the number of bins of the joined histogram used by the registration functions."

NumberSamples::usage =
"NumberSamples is an options for RegisterData, RegisterDiffusionData, and RegisterDataTransform. 
It specifies the number of random samples that are taken each iteration used by the registration functions."

OutputImage::usage =
"OutputImage is an options for RegisterData, RegisterDiffusionData, and RegisterDataTransform. 
It specifies if the result image should be writen in the TempDirectory as nii file."

InterpolationOrderReg::usage =
"InterpolationOrderReg is an options for RegisterData, RegisterDiffusionData, and RegisterDataTransform. 
It specifies the interpolation order used in the registration functions."

MethodReg::usage = 
"MethodReg is an options for RegisterData, RegisterDiffusionData, RegisterCardiacData and RegisterDataTransform. 
It specifies which registration method to use. 
Methods can be be \"translation\", \"rigid\", \"affine\", \"bspline\", \"rigidDTI\", \"affineDTI\", \"PCAtranslation\", \"PCArigid\", \"PCAaffine\", or \"PCAbspline\"."

BsplineSpacing::usage =
"BsplineSpacing is an options for RegisterData, RegisterDiffusionData, RegisterCardiacData and RegisterDataTransform. 
It specifies the spacing of the bsplines if the method is \"bspline\"."

TempDirectory::usage = 
"TempDirectory is an options for RegisterData, RegisterDiffusionData, RegisterCardiacData and RegisterDataTransform. 
It specifies the temporary directory used to perform and output the registration."

DeleteTempDirectory::usage =
"DeleteTempDirectory an options for RegisterData, RegisterDiffusionData, RegisterCardiacData and RegisterDataTransform. 
It specifies if the temp directory should be deleted after the registration is finisched."

PrintTempDirectory::usage = 
"PrintTempDirectory is an options for RegisterData, RegisterDiffusionData, RegisterCardiacData and RegisterDataTransform. 
It specifies if the location of the temp directory should be displayed."

RegistrationTarget::usage = 
"RegistrationTarget is an option for RegisterDiffusionData and RegisterCardiacData. Specifies which target to uses for registration if using \"rigid\", \"affine\" or \"bspline\" as MethodReg.
If the MethodReg is \"PCA\" based it does not need a target and this options does nothing. 
Values can be \"First\", \"Mean\" or \"Median\"."

BsplineDirections::usage = 
"BsplineDirections is an option for RegisterData ad RegisterDiffusionData. 
It gives the direction in which the bsplines are allowed to move when registering diffusion data to anatomical space."

AffineDirections::usage = 
"AffineDirections is an option for RegisterData ad RegisterDiffusionData. 
It gives the directions in which data can be moved when registering diffusion data to anatomical space."

OutputTransformation::usage =
"OutputTransformation is an option for RegisterData ad RegisterDiffusionData.
It specifies if the transformation paramters (translation, rotation, scale and skew) should be given as output in the registration functions."

IterationsA::usage = 
"IterationsA is an option for RegisterDiffusionData. 
It specifies the number of iterations used when registering diffusion data to anatomical space."

ResolutionsA::usage =
"ResolutionsA is an option for RegisterDiffusionData.
It specifies the number of scale space resolutions used when registering diffusion data to anatomical space."

HistogramBinsA::usage =
"HistogramBinsA is an option for RegisterDiffusionData.
It specifies the number of bins of the joined histogram used when registering diffusion data to anatomical space."

NumberSamplesA::usage =
"NumberSamplesA is an option for RegisterDiffusionData.
It specifies the number of random samples that are taken each iteration when registering diffusion data to anatomical space."

InterpolationOrderRegA::usage =
"InterpolationOrderRegA is an option for RegisterDiffusionData.
It specifies the interpolation order used in the registration functions when registering diffusion data to anatomical space."

MethodRegA::usage =
"MethodRegA is an option for RegisterDiffusionData.
It specifies which registration method to use when registering diffusion data to anatomical space. Methods can be be \"rigid\",\"affine\" or \"bspline\"."

ShowMetric::usage=
"ShowMetric is an option for RegisterData. If set to True it will print a plot of the Metric."

UseGPU::usage = 
"UseGPU is an option for RegisterData. The value is {bool, gpu} where bool is True or False, and gpu is the gpu ID which is an integer or Automatic."

PCAComponents::usage = 
"PCAComponents is an option for RegisterData. It specifies how many PCA components are used if method is set to \"PCA\"."

FindTransform::usage = 
"FindTransform is an option for TransformData and RegisterTransformData. It specifies where to find the transformfile."

SplitMethod::usage = 
"SplitMethod is an option for RegisterDataSplit and RegisterDataTransformSplit. values can be \"mean\", \"moving\", \"target\"."

TransformMethod::usage = 
"TransformMethod is an option for RegisterDataSplit and RegisterDataTransformSplit. values can be \"Data\", \"Mask\", \"Segmentation\". 
If set to \"Mask\" a binary mask is expected as the second moving input.
If set to \"Segmentation\" a multi label segmentation is expected as the second moving input.
Uses SplitSegmentations internally then."

(* ::Subsection::Closed:: *)
(*Error Messages*)


RegisterData::inp="Invalid input for registration function." 

RegisterData::vol="The `1`D datasets should have 2 or more volumes, it has `2` volumes."

RegisterData::dim="Datasets should both be 2D or 3D, or 2D and 3D, or 3D and 4D, current datasets are `1`D and `2`D."

RegisterData::dims="Dataset should be 3D or 4D, current dataset is `1`D."

RegisterData::vox="voxel size should be {z,x,y} and numeric, current sizes are `1` and `2`."

RegisterData::voxs="voxel size should be {z,x,y} and numeric, current size is `1`."

RegisterData::met="MethodReg should be \"translation\", \"rigid\", \"affine\", \"bspline\", \"rigidDTI\", \"affineDTI\", 
\"PCAtranslation\", \"PCArigid\", \"PCAaffine\", or \"PCAbspline\", \"rigidMulti\", \"affineMulti\", 
\"bsplineMulti\", current method is `1`."

RegisterData::metc="If the MethodReg is \"PCAxx\" no target can be given. If the method is \"xxxMulti\" a target should be given."

RegisterData::cyc="If any MethodReg is \"PCAxx\" all should be \"PCAxx\"."

RegisterData::mult="If any MethodReg is \"xxxMulti\" all should be \"xxxMulti\"."

RegisterData::mask="The mask dimensions `1` should be equal to the data dimensions `2`."

RegisterData::dir="Temporary directory not created."

RegisterData::elastix="Elastix not found, check if QMRITools is installed in the $BaseDirectory or $UserBaseDirectory."

RegisterData::par="`1` should be a number or a list of numbers with length `2`."

RegisterData::fatal="Fatal error encountered."


(* ::Section:: *)
(*Functions*)

Begin["`Private`"]


debugElastix[x___] := If[$debugElastix, Print[x]];


(* ::Subsection::Closed:: *)
(*Definitions*)


operatingSystem = $OperatingSystem;


(* ::Subsection:: *)
(*Support Functions*)


(* ::Subsubsection::Closed:: *)
(*ClearQMRIToolsTemp*)


SyntaxInformation[ClearQMRIToolsTemp] = {"ArgumentsPattern"->{}};

ClearQMRIToolsTemp[] := DeleteDirectory[FileNames["*QMRIToolsReg*", $TemporaryDirectory], DeleteContents -> True]


(* ::Subsubsection::Closed:: *)
(*ParString*)


ParString[{iterations_, resolutions_, bins_, samples_, intOrder_}, {type_, output_}, {{dtar_, n_}, grid_, derscB_, derscA_, eig_}, {openCL_, gpu_}]:=Block[
	{pca, mul},
	pca = (type === "PCAtranslation" || type === "PCArigid" || type === "PCAaffine" || type==="PCAbspline");
	mul = (type === "rigidMulti" || type === "affineMulti" || type === "bsplineMulti");

"// ***************************************************************
// ** "<>type<>" **

// ** Generated using QMRITools by M.Froeling **

// ** fixed general settings **
// ***************************************************************
(FixedInternalImagePixelType \"float\")
(MovingInternalImagePixelType \"float\")
(UseDirectionCosines \"true\")

(DefaultPixelValue 0)
(WriteTransformParametersEachIteration \"false\")
(ResultImageFormat \"nii.gz\")
(ResultImagePixelType \"float\")

(ErodeMask \"false\")
(ErodeMovingMask \"false\")
(ErodeFixedMask \"false\")

(Registration "<>If[!mul, "\"MultiResolutionRegistration\"", "\"MultiMetricMultiResolutionRegistration\""]<>")

(ImageSampler "<>StringRep["\"RandomCoordinate\"",n]<>")
(CheckNumberOfSamples \"true\")
(NewSamplesEveryIteration \"true\")
(MaximumNumberOfSamplingAttempts 5)

(HowToCombineTransforms \"Compose\")

(Optimizer \"AdaptiveStochasticGradientDescent\")
(ASGDParameterEstimationMethod \"Original\")
(AutomaticParameterEstimation \"true\")
(AutomaticTransformInitialization \"true\")
(AutomaticScalesEstimation \"true\")

"<>If[openCL,
(*check to uses openCL needs custom compile of elastix*)
"(OpenCLDeviceID \""<>ToString[gpu]<>"\")
(Resampler \"OpenCLResampler\")
(OpenCLResamplerUseOpenCL \"true\")
(FixedImagePyramid "<>StringRep["\"OpenCLFixedGenericImagePyramid\"",n]<>")
(OpenCLFixedGenericImagePyramidUseOpenCL \"true\")
(MovingImagePyramid "<>StringRep["\"OpenCLMovingGenericImagePyramid\"",n]<>")
(OpenCLMovingGenericImagePyramidUseOpenCL \"true\")"
,

"(Resampler \"DefaultResampler\")
(FixedImagePyramid "<>StringRep["\"FixedGenericImagePyramid\"",n]<>")
(MovingImagePyramid "<>StringRep["\"MovingGenericImagePyramid\"",n]<>")"
]<>"
// ***************************************************************


// ** Metric settings **
// ***************************************************************
"<>Which[(*if PCA uses stack transform*)
	(*PCA based methods*)
	pca,
"(Metric \"PCAMetric2\")
(NumEigenValues "<>ToString[eig]<>")
(SubtractMean \"true\")

(Interpolator \"ReducedDimensionBSplineInterpolator\")
(ResampleInterpolator \"FinalReducedDimensionBSplineInterpolator\")",
	True,
	(*Non PCA based methods*)
"(Metric "<>StringRep["\"AdvancedMattesMutualInformation\"",n]<>")

(Interpolator "<>StringRep["\"BSplineInterpolator\"",n]<>")
(ResampleInterpolator \"FinalBSplineInterpolator\")"
]<>"
// ***************************************************************


// ** setting allowed by QMRITools **
// ***************************************************************
(WriteResultImage \""<>output<>"\")

(NumberOfResolutions "<>ToString[resolutions]<>")
"<>Which[(*if multi resolution PCA imagePyramidSchedule has to be defined*)
	pca,
	"(ImagePyramidSchedule "<>SchedulePar[resolutions, dtar]<>")",
	True,""
]<>"
(BSplineInterpolationOrder "<>ToString[Clip[intOrder,{1,3},{1,3}]]<>")
(FinalBSplineInterpolationOrder "<>ToString[intOrder]<>")

(NumberOfHistogramBins "<>ToString[bins]<>")
(MaximumNumberOfIterations "<>ToString[iterations]<>")

(NumberOfSpatialSamples "<>ToString[samples]<>")
// ***************************************************************


// ** Transform type specific settings **
// ***************************************************************
"<>Switch[type, (*switch beteen registration types*)
(*normal or multi methods*)	
"translation",
"(Transform \"TranslationTransform\")",
"rigid" | "rigidMulti",
"(Transform \"EulerTransform\")",
"affine" | "affineMulti",
"(Transform \"AffineTransform\")
(MovingImageDerivativeScales "<>DerivativePar[N@Clip[derscA], dtar]<>")",
"bspline" | "bsplineMulti",
"(Transform \"RecursiveBSplineTransform\")
(FinalGridSpacingInPhysicalUnits "<>DerivativePar[N@Round[grid], dtar]<>")
(MovingImageDerivativeScales "<>DerivativePar[N@Clip[derscB], dtar]<>")",

(*DTI methods*)
"rigidDTI",
"(Transform \"AffineDTITransform\")
(Scales -1.0 -1.0 -1.0  3.0e+38  3.0e+38  3.0e+38  3.0e+38  3.0e+38  3.0e+38 -1.0 -1.0 -1.0)",
"affineDTI",
"(Transform \"AffineDTITransform\")
(Scales -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1)
(MovingImageDerivativeScales "<>DerivativePar[N@Clip[derscA], dtar]<>")",

(*PCA methods*)
"PCAtranslation",
"(Transform \"TranslationStackTransform\")
(MovingImageDerivativeScales "<>DerivativePar[{1.,1.,1.}, dtar-1, "0.0"]<>")",
"PCArigid",
"(Transform \"EulerStackTransform\")
(MovingImageDerivativeScales "<>DerivativePar[{1.,1.,1.}, dtar-1, "0.0"]<>")",
"PCAaffine",
"(Transform \"AffineLogStackTransform\")
(MovingImageDerivativeScales "<>DerivativePar[{1.,1.,1.}, dtar-1, "0.0"]<>")",
"PCAbspline",
"(Transform \"BSplineStackTransform\")
(FinalGridSpacingInPhysicalUnits "<>DerivativePar[Round[grid], dtar-1]<>")
(MovingImageDerivativeScales "<>DerivativePar[N@Clip[derscB], dtar-1, "0.0"]<>")"
]<>"
// ***************************************************************

//****************** end of file ***************
"
]

StringRep[st_, n_] := StringJoin@Riffle[ConstantArray[st, n], " "]

ListToString[list_, add_: ""] := StringTrim[StringJoin[Riffle[ToString /@ list, " "]] <> " " <> add]

SchedulePar[res_, dtar_] := ListToString[ListToString[2.^ConstantArray[#, dtar - 1], "0.0"] & /@ Reverse[Range[res] - 1]]

DerivativePar[par_, dtar_, add_: ""] := ListToString[Reverse[par[[-dtar ;;]]], add]


(* ::Subsubsection::Closed:: *)
(*ElastixCommand*)


ElastixCommand[elas_, tempdir_, parfile_, fols_, files_, mask_]:=ElastixCommand[elas, tempdir, parfile, fols, files, mask, 1]

ElastixCommand[elas_, tempdir_, parfile_, {inpfol_, movfol_, outfol_}, {fixedi_, movingi_, out_}, {maskfi_, maskmi_}, n_]:=Block[{
		quote, cp, num, maskf, maskm, command, resout, finout, output, elastix, outfile,
		inpfold, outfold, movfold, parfiles, copy, maskfFile, maskmFile, elastixFol, fixedFile, moveFile
	},

	(*operating specific settings *)
	quote = Switch[operatingSystem,"Windows","\"",_,"'"];
	cp = Switch[operatingSystem,"Windows","@ copy ",_,"cp "];

	elastix = quote<>elas<>quote;
	elastixFol = DirectoryName[elas, 2];

	elastix = Switch[operatingSystem, 
		"Windows", 
		"@ "<>elastix,
		"MacOSX", 
		"export PATH="<>elastixFol<>"bin:$PATH\nexport DYLD_LIBRARY_PATH="<>elastixFol<>"lib:$DYLD_LIBRARY_PATH\n"<>elastix,
		"Unix",
		"export PATH="<>elastixFol<>"bin:$PATH\nexport LD_LIBRARY_PATH="<>elastixFol<>"lib:$LD_LIBRARY_PATH\n"<>elastix
	];

	(*in and output folders*)
	inpfold = FileNameJoin[{tempdir, inpfol}];
	movfold = FileNameJoin[{tempdir, movfol}];
	outfold = FileNameJoin[{tempdir, outfol}];
	outfile = FileNameJoin[{outfold, out}];

	(*moving and fixed files*)
	fixedFile = MakeElasFiles["-f", fixedi, inpfold, quote, n];
	moveFile = MakeElasFiles["-m", movingi, movfold, quote, n];

	(*maskfiles*)	
	maskf = If[FileExtension[maskfi] == "nii", maskfi<>".gz", maskfi];
	maskm = If[FileExtension[maskmi] == "nii", maskmi<>".gz", maskmi];
	maskfFile=If[maskf==="", "", " -fMask "<>quote<>FileNameJoin[{tempdir,maskf}]<>quote];
	maskmFile=If[maskm==="", "", " -mMask "<>quote<>FileNameJoin[{tempdir,maskm}]<>quote];

	(*par file string*)
	parfiles = StringJoin[" -p "<>quote<>FileNameJoin[{tempdir,#}]<>quote &/@parfile];

	(*output*)
	outfold = " -out "<>quote<>outfold<>quote;
	output = " > "<>quote<>FileNameJoin[{movfold,"output.txt"}]<>quote;

	(*copy string*)
	copy = If[out=="", 
		"", 
		(*how many par files*)
		num=ToString[Length[parfile]-1];
		resout = quote<>FileNameJoin[{tempdir,outfol,"result."<>num<>".nii.gz"}]<>quote;
		finout = quote<>FileNameJoin[{tempdir,outfol,out}]<>quote;
		cp<>resout<>" "<>finout
	];

	command = elastix<>fixedFile<>moveFile<>outfold<>maskfFile<>maskmFile<>parfiles<>output<>" \n"<>copy<>" \n"<>"exit \n";

	{command, outfile}	
]


MakeElasFiles[pre_,filei_, fol_, q_, n_]:=Block[{fixed, index, file},
	StringJoin[(
		index = StringPadInteger["-",#];
		file = If[n===1, filei, filei[index]];
		fixed = If[FileExtension[file] == "nii", file<>".gz", file];
		" "<>pre<>If[n===1, "", ToString[#-1]]<>" "<>q<>FileNameJoin[{fol, fixed}]<>q
	)&/@Range[n]]
]


(* ::Subsubsection::Closed:: *)
(*TransformixCommand*)


TransformixCommand[tempDir_, ind_] := Block[{
	trans, quote, cp, transformix, transFol, transfile, movfile, output, outfold, volDirs, copy
	},

	trans = GetAssetLocation["Transformix"];

	(*operating specific settings *)
	quote = Switch[operatingSystem,"Windows","\"",_,"'"];
	cp = Switch[operatingSystem,"Windows","@ copy ",_,"cp "];

	(*transformix command*)
	transformix = quote<>trans<>quote;
	transFol = DirectoryName[trans, 2];
	transformix = Switch[operatingSystem, 
		"Windows", 
		"@ "<>transformix,
		"MacOSX", 
		"export PATH="<>transFol<>"bin:$PATH\nexport DYLD_LIBRARY_PATH="<>transFol<>"lib:$DYLD_LIBRARY_PATH\n"<>transformix,
		"Unix",
		"export PATH="<>transFol<>"bin:$PATH\nexport LD_LIBRARY_PATH="<>transFol<>"lib:$LD_LIBRARY_PATH\n"<>transformix
	];

	(*make trans file*)
	If[ind,
		(*individual trans file*)
		(*files*)
		transfile = " -tp "<>quote<>TransfileT[tempDir]<>quote;
		movfile = " -in " <>quote<>MovfileT[tempDir]<>quote;

		(*outputs*)
		outfold = " -def all -out "<>quote<>tempDir<>quote;
		output = " > "<>quote<>FileNameJoin[{tempDir, "output.txt"}]<>quote;

		(*command*)
		transformix <> movfile <> outfold <> transfile <> output<>" \n exit \n"
		,
		(*range of trans files*)
		volDirs = FileNames["vol*", tempDir, 1];
		(
			(*files*)
			transfile = " -tp "<>quote<>TransfileF[#]<>quote;
			movfile = " -in " <>quote<>MovfileF[#]<>quote;

			(*outputs*)
			outfold = " -def all -out "<>quote<>#<>quote;
			output = " > "<>quote<>FileNameJoin[{#, "output.txt"}]<>quote;

			(*copy*)
			copy = cp<>quote<>FileNameJoin[{#, "result.nii.gz"}]<>quote<>" "<>quote<>FileNameJoin[{#, "resultA-3D.nii.gz"}]<>quote;

			(*command*)
			transformix <> movfile <> outfold <> transfile <> output<>" \n"<>copy<>" \n"
		)&/@volDirs
	]
]


MovfileF[fol_] := First[FileNames["moving*", fol]];
	
TransfileF[fol_] := Last[SortBy[FileNames["FinalTransform*", fol], FileDate[#, "Modification"] &]];

MovfileT[fol_] := First[FileNames["trans*", fol]];

TransfileT[fol_] := Last[SortBy[FileNames["TransformParameters*", DirectoryName[fol]], FileDate[#, "Modification"] &]];


(* ::Subsubsection::Closed:: *)
(*ConcatenateTransformFiles*)


ConcatenateTransformFiles[files_, outDir_] := Block[{len, filesi, tfile, f, p},
	(*import the transform files*)
	len = Range[Length[files]];
	filesi = Import[#, "Lines"] & /@ files;

	(*concatenate the transform files*)
	(
		f = filesi[[#]];
		tfile = If[# == 1, "NoInitialTransform", outDir <> $PathnameSeparator <> "FinalTransform." <> ToString[# - 2] <> ".txt"];
		p = Position[Boole[StringContainsQ[#, "InitialTransformParameterFileName"] & /@ f], 1][[1, 1]];

		f[[p]] = "(InitialTransformParameterFileName \"" <> tfile <> "\")";
		Export[outDir <> $PathnameSeparator <> "FinalTransform." <> ToString[# - 1] <> ".txt", f];
	) & /@ len;
]


(* ::Subsubsection::Closed:: *)
(*RunCommand*)


RunCommand[com_]:=(debugElastix["Command line: \n"<>com]; RunProcess[$SystemShell, "StandardOutput", com])


(* ::Subsubsection::Closed:: *)
(*RunBatfile*)


RunBatfile[tempdir_, command_]:=RunBatfile[tempdir, command, "E"]

RunBatfile[tempdir_, command_, f_]:=Block[{file, batfile, com, quote},
	debugElastix["Command line: \n"<>First[command]];

	quote = Switch[operatingSystem,"Windows","\"",_,"'"];

	(*make elastix/transformix sh/bat based on operating system*)
	file = Switch[f,"E","elastix","T","transformix"]<>"-batch."<>Switch[operatingSystem,"Windows","bat",_,"sh"];
	batfile = FileNameJoin[{tempdir, file}];
	Export[batfile,StringJoin[StringReplace[command,"exit \n"->""]],"TEXT"];
	batfile = quote<>batfile<>quote;

	(*make command*)
	com = Switch[operatingSystem,
		"Windows",batfile<>" \nexit \n",
		_,"chmod 700 "<>batfile<>"\n"<>batfile<>" \nexit \n"];

	(*perform sh/bat on system shell*)
	RunCommand[com];
]


(* ::Subsubsection::Closed:: *)
(*SplitRegInput*)


SplitRegInput[input_] := Which[
	ArrayQ[input],(*Only data*)
	{input, {1}, {1, 1, 1}},
	Length[input] == 2 && ArrayQ[input[[1]]] && (VectorQ[input[[2]]] && Length[input[[2]]] === 3),(*data and vox*)
	{input[[1]], {1}, input[[2]]},
	Length[input] == 2 && ArrayQ[input[[1]]] && (ArrayQ[input[[2]]] || input[[2]] === {1}),(*data and mask*)
	{input[[1]], input[[2]], {1, 1, 1}},
	Length[input] == 3 && ArrayQ[input[[1]]] && (ArrayQ[input[[2]]] || input[[2]] === {1}) && (VectorQ[input[[3]]] && Length[input[[3]]] === 3),(*full input*)
	input,
	True,
	$Failed
]


(* ::Subsection:: *)
(*RegisterData/Split*)


CreateTempDirectory[tdirI_] := CreateTempDirectory[tdirI, False, False]
CreateTempDirectory[tdirI_, print_] := CreateTempDirectory[tdirI, print, False]
CreateTempDirectory[tdirI_, print_, make_] := Block[{tdir, add, str},
	(*define temp directory forder name*)
	{tdir, add} = If[ListQ[tdirI], tdirI, {tdirI, ""}];
	str = RandomString[6];

	tdir = (If[StringQ[tdir], tdir, "Default"] /. {"Default" -> $TemporaryDirectory});
	tdir = If[StringContainsQ[Last[FileNameSplit[tdir]], "QMRIToolsReg"] || Last[FileNameSplit[tdir]] === "anat",
		FileNameJoin[{tdir, add}],
		FileNameJoin[{tdir, "QMRIToolsReg-" <> str, add}]
	];

	(*delete and create if needed*)
	If[make, If[DirectoryQ[tdir], DeleteDirectory[tdir, DeleteContents -> True]]; CreateDirectory[tdir]];
	tdir = If[! DirectoryQ[tdir], CreateDirectory[tdir], tdir];
	tdir = AbsoluteFileName[tdir];

	(*print if needed*)
	If[print, PrintTemporary["using as temp directory: " <> tdir]];
	$lastElastixTemp = If[add =!= "" || Last[FileNameSplit[tdir]] === "anat", DirectoryName[tdir], tdir];

	debugElastix["using as temp directory: " <> tdir];
	debugElastix["$lastElastixTemp: " <> $lastElastixTemp];

	(*return temp directory*)
	tdir
]

(* ::Subsubsection::Closed:: *)
(*RegisterData*)


Options[RegisterData] = {
	Iterations->250,
	Resolutions->1,
	HistogramBins->32,
	NumberSamples->5000,
	InterpolationOrderReg->3,
	BsplineSpacing->30,
	BsplineDirections->{1,1,1},
	AffineDirections->{1,1,1},
	MethodReg->"affine",
	OutputImage->True,
	TempDirectory->"Default",
	DeleteTempDirectory->True,
	PrintTempDirectory->True,
	OutputTransformation->False,
	UseGPU->{False, Automatic},
	PCAComponents->1,
	ShowMetric->False
};

SyntaxInformation[RegisterData] = {"ArgumentsPattern"->{_,_.,OptionsPattern[]}};


(* ::Subsubsection::Closed:: *)
(*RegisterData Series or PCA*)


(*Series or Cyclyc have no target defninition so only one input*)
RegisterData[input_, opts:OptionsPattern[]]:=RegisterData[SplitRegInput[input], opts]

(*invalid input*)
RegisterData[$Failed, opts:OptionsPattern[]]:=Return[Message[RegisterData::inp];$Failed];

(*register series of data sets, vox definition, mask definition, no target definition*)
RegisterData[
	{series_?ArrayQ, mask_?ArrayQ, vox:{_?NumberQ,_?NumberQ,_?NumberQ}}, opts:OptionsPattern[]]:=Module[{
		depthS,dim,dimm,dimL,target,moving,dataout,voxL,output,cyclyc,cyc,maskf,maskm
	},

	debugElastix["RegisterData: PCA or Series"];

	(*Check Method, Multi only possible for target and moving*)
	If[AnyTrue[OptionValue[MethodReg], (# === "rigidMulti" || # === "affineMulti" || # === "bsplineMulti") &], 
		Message[RegisterData::metc]; Return[Message[RegisterData::fatal]]];

	(*check for cyclic*)
	cyc = AnyTrue[Flatten[{OptionValue[MethodReg]}], (# === "PCAtranslation" || # === "PCArigid" || # === "PCAaffine" || # === "PCAbspline") &];
	cyclyc = AllTrue[Flatten[{OptionValue[MethodReg]}], (# === "PCAtranslation" || # === "PCArigid" || # === "PCAaffine" || # === "PCAbspline") &];
	If[cyc =!= cyclyc, Message[RegisterData::cyc]; Return[Message[RegisterData::fatal]]];


	(*get data properties*)
	depthS = ArrayDepth[series];
	dim = Dimensions[series];
	dimL = If[depthS==3, dim[[1]], dim[[2]]];
	dimm = Dimensions[mask];
	voxL = Length[vox];

	(*check dimensions*)
	(*series must be 3 of 4D*)
	If[!(depthS==3||depthS==4),Message[RegisterData::dims,depthS];Return[Message[RegisterData::fatal]]];
	(*sereis must have 2 or more volumes*)
	If[!dimL>=2,Message[RegisterData::vol,depthS,dim[[1]]];Return[Message[RegisterData::fatal]]];

	(*check voxel sizes*)
	If[voxL!=3||!(NumberQ@Total@vox),Message[RegisterData::voxs,vox];Return[Message[RegisterData::fatal]]];

	(*check mask*)
	If[mask!={1},
		If[cyclyc,
			(*cyclyc mask needs to be same dimensions as moving data*)
			If[dim!=dimm,Message[RegisterData::mask,dimm,dim];Return[Message[RegisterData::fatal]]],
			If[depthS==3,
				(*normal mask, one mask for all or one mask per volume*)
				If[!(dim[[2;;3]]==dimm||dim==dimm),Message[RegisterData::mask,dimm,dim];Return[Message[RegisterData::fatal]]],
				If[!(dim[[{1,3,4}]]==dimm||dim==dimm),Message[RegisterData::mask,dimm,dim];Return[Message[RegisterData::fatal]]]
			]
		]
	];

	
	(*check if method is cyclyc*)
	If[cyclyc,
		(*cyclyc series define moving and target voluems*)
		target = moving = series;
		(*go to registration function*)
		RegisterDatai[{target,mask,vox}, {moving,mask,vox}, "PCA", opts]
		,
		(*normal series define moving and target voluems*)
		{target, moving} = If[depthS==3, {series[[1]],series[[2;;]]}, {series[[All,1]],Transpose@series[[All,2;;]]}];
		{maskf, maskm} = If[dimm==dim, If[depthS==3, {mask[[1]],mask[[2;;]]}, {mask[[All,1]],Transpose@mask[[All,2;;]]}], {mask,mask}];
		(*go to registration function*)
		output = RegisterDatai[{target,maskf,vox}, {moving,maskm,vox}, "series", opts];
		(*prepare output*)
		If[OptionValue[OutputTransformation],
			(*output data with transformation parameters*)
			dataout = Prepend[output[[1]],target];
			{If[depthS==4,Transpose@dataout,dataout],Prepend[output[[2]],{0,0,0,0,0,0,1,1,1,0,0,0}]}
			,
			(*output dat without transformation parameters*)
			dataout = Prepend[output,target];
			If[depthS==4,Transpose@dataout,dataout]
		]
	]
]


(* ::Subsubsection::Closed:: *)
(*RegisterData Volumes or Multi*)


(*Volumes or multi do have target defninition, so two inputs*)
RegisterData[target_, moving_, opts:OptionsPattern[]]:=RegisterData[SplitRegInput[target], SplitRegInput[moving], opts]

(*invalid input*)
RegisterData[$Failed, _, opts:OptionsPattern[]]:=Return[Message[RegisterData::inp]; $Failed]
RegisterData[_ , $Failed, opts:OptionsPattern[]]:=Return[Message[RegisterData::inp]; $Failed]

(*register two data sets, mask and vox definition*)
RegisterData[
	{target_?ArrayQ, maskt_?ArrayQ, voxt:{_?NumberQ,_?NumberQ,_?NumberQ}},
	{moving_?ArrayQ, maskm_?ArrayQ, voxm:{_?NumberQ,_?NumberQ,_?NumberQ}}, opts:OptionsPattern[]]:=Module[{
		depthT, depthM, voxtL, voxmL, dimT, dimM, type, output, mul ,multi
	},

	debugElastix["RegisterData: Volumes or Multi"];

	(*Check Method, PCA only possible for series*)
	If[AnyTrue[OptionValue[MethodReg], (# === "PCAtranslation" || # === "PCArigid" || # === "PCAaffine" || # === "PCAbspline") &], 
		Message[RegisterData::metc]; Return[Message[RegisterData::fatal]]];

	(*check for cyclic*)
	mul = AnyTrue[Flatten[{OptionValue[MethodReg]}], (# === "rigidMulti" || # === "affineMulti" || # === "bsplineMulti") &];
	multi = AllTrue[Flatten[{OptionValue[MethodReg]}], (# === "rigidMulti" || # === "affineMulti" || # === "bsplineMulti") &];
	If[mul =!= multi, Message[RegisterData::mult];Return[Message[RegisterData::fatal]]];


	(*get data properties*)
	depthT = ArrayDepth[target];
	depthM = ArrayDepth[moving];
	dimT = Dimensions[target];
	dimM = Dimensions[moving];
	voxtL = Length[voxt];
	voxmL = Length[voxm];

	debugElastix[{multi, depthM, depthT, depthM == depthT + 1}];

	(*check dimensions and determine type*)
	type = Which[
		multi && depthM == depthT, "multi",
		depthT == depthM, "vol", (*2D-2D, 3D-3D*)
		(depthT == 2 || depthT == 3) && depthM == depthT + 1, "series", (*2D-3D, 3D-4D*)
		True, Message[RegisterData::dim,depthT,depthM];Return[Message[RegisterData::fatal]] (*error*)];

	debugElastix["Type for registration: "<>type];

	(*check dimensions*)
	(*target and moving must be 2D or 3D*)

	(*check voxel sies*)
	If[voxtL!=3||voxmL!=3||!(NumberQ@Total@voxt)||!(NumberQ@Total@voxm),Message[RegisterData::vox,voxt,voxm];Return[Message[RegisterData::fatal]]];

	
	(*define moving and target voluems*)
	output = RegisterDatai[
		{If[depthT==4, Transpose@target, target], maskt, voxt},
		{If[depthM==4,Transpose@moving, moving], maskm, voxm}, 
		type, opts];

	(*generate output*)
	If[OptionValue[OutputTransformation],
		{If[depthM==4, Transpose@output[[1]], output[[1]]], Prepend[output[[2]],{0,0,0,0,0,0,1,1,1,0,0,0}]},
		If[depthM==4, Transpose@output, output]
	]
]


(* ::Subsubsection::Closed:: *)
(*RegisterDatai*)


Options[RegisterDatai] = Options[RegisterData];

RegisterDatai[
	{target_?ArrayQ,voxt:{_?NumberQ,_?NumberQ,_?NumberQ}},
	{moving_?ArrayQ,voxm:{_?NumberQ,_?NumberQ,_?NumberQ}}
, type_ , opts:OptionsPattern[]]:= RegisterDatai[{target,{1},voxt},{moving,{1},voxm},type,opts]

RegisterDatai[
	{target_?ArrayQ,maskt_,voxt:{_?NumberQ,_?NumberQ,_?NumberQ}},
	{moving_?ArrayQ,voxm:{_?NumberQ,_?NumberQ,_?NumberQ}}
, type_ , opts:OptionsPattern[]]:= RegisterDatai[{target,maskt,voxt},{moving,{1},voxm},type,opts]

RegisterDatai[
	{target_?ArrayQ,voxt:{_?NumberQ,_?NumberQ,_?NumberQ}},
	{moving_?ArrayQ,maskm_,voxm:{_?NumberQ,_?NumberQ,_?NumberQ}}
, type_, opts:OptionsPattern[]]:= RegisterDatai[{target,{1},voxt},{moving,maskm,voxm},type,opts]

RegisterDatai[
	{target_?ArrayQ,maskt_?ArrayQ,voxt:{_?NumberQ,_?NumberQ,_?NumberQ}},
	{moving_?ArrayQ,maskm_?ArrayQ,voxm:{_?NumberQ,_?NumberQ,_?NumberQ}}, type_,OptionsPattern[]]:=Module[{
		tdir, tempdir, elastix, parstring, outputImg, iterations, resolutions,
		histogramBins, numberSamples, derivativeScaleA, derivativeScaleB, interpolationOrder,
		method, bsplineSpacing, data, vox, dimmov, dimtar, dimmovm, dimtarm, inpfol, movfol, outfol,
		fixedF, movingF, outF, parF, depth, index, regpars, lenMeth, command, outfile,
		fmaskF, mmaskF, w, openCL, gpu, pca, dtar, lengM
	},

	w = {{0,0,0,0,0,0,1,1,1,0,0,0}};

	(*get option values*)
	outputImg=ToLowerCase[ToString[OptionValue[OutputImage]]];

	method = OptionValue[MethodReg];
	method = If[StringQ[method], {method}, method];
	debugElastix["RegisterDatai: "<>StringJoin[Riffle[method," - "]]<>" / "<>type];

	bsplineSpacing=OptionValue[BsplineSpacing];
	bsplineSpacing=If[!ListQ[bsplineSpacing],ConstantArray[bsplineSpacing,3],bsplineSpacing];
	derivativeScaleB=OptionValue[BsplineDirections];
	derivativeScaleA=OptionValue[AffineDirections];

	openCL = OptionValue[UseGPU];
	If[ListQ[openCL], {openCL, gpu} = openCL; gpu = If[gpu===Automatic, 0, gpu];, gpu = 0;];
	If[openCL, method = method /. {"rigidDTI"->"rigid", "affineDTI"->"affine"} ];
	pca=OptionValue[PCAComponents];

	iterations=OptionValue[Iterations];
	resolutions=OptionValue[Resolutions];
	histogramBins=OptionValue[HistogramBins];
	numberSamples=OptionValue[NumberSamples];
	interpolationOrder=OptionValue[InterpolationOrderReg];
	regpars={iterations,resolutions,histogramBins,numberSamples,interpolationOrder};

	(*error sensative checks*)

	(*find the elastix program*)
	elastix = GetAssetLocation["Elastix"];
	If[elastix=="error", Message[RegisterData::elastix]; Return[Message[RegisterData::fatal]]];

	(*check registration method*)
	If[!MemberQ[{
			"translation", "rigid", "affine", "bspline", (*traditional*)
			"rigidDTI", "affineDTI", (*DTI specific*)
			"PCAtranslation", "PCArigid", "PCAaffine", "PCAbspline", (*PCA cyclyc*)
			"rigidMulti", "affineMulti", "bsplineMulti" (*multi contrast*)
		},#],
		Message[RegisterData::met,#];
		Return[Message[RegisterData::fatal],Module]
		]&/@method; 
	lenMeth = Length[method];

	tdir = CreateTempDirectory[OptionValue[TempDirectory], OptionValue[PrintTempDirectory], True];
	tempdir = tdir<>$PathnameSeparator;

	(*create parameter list*)
	regpars = If[NumberQ[#],ConstantArray[#,lenMeth],
		If[Length[#]==lenMeth, #, Message[RegisterData::par,#,lenMeth]; Return[Message[RegisterData::fatal]];
	]]&/@regpars;

	(*get all data dimensions*)
	dimmov = Dimensions[moving];
	dimtar = Dimensions[target];

	dtar = ArrayDepth[target];
	lengM = Length[moving];

	dimmovm = Dimensions[maskm];
	dimtarm = Dimensions[maskt];
	depth = Switch[type,
		"PCA", ToString[dtar-1]<>"D-t", 
		"multi", ToString[dtar-1]<>"D",
		_,ToString[dtar]<>"D"];

	(*create parameter files*)
	parF = MapThread[(
		parstring = ParString[#2, {#1, outputImg}, {If[type === "multi", {dtar-1, lengM}, {dtar, 1}], bsplineSpacing, derivativeScaleB, derivativeScaleA, pca}, {openCL, gpu}];
		parF = "parameters-"<>#1<>".txt";
		Export[tempdir<>parF,parstring];
		parF
	)&, {method, Transpose[regpars]}];


	(*perform registration which is either: "vol"|"PCA", "series" or "multi" based method  *)
	Switch[type,

		(*volume to volume registration (2D-2D, 3D-3D)*)
		(*cyclyc volume to volume registration (2Dt-2Dt, 3Dt-3Dt)*)
		"vol"|"PCA",

		(*define folders*)
		{inpfol, movfol, outfol} = {"", "", ""};

		(*Check if masks are needed*)
		{fmaskF, mmaskF} = {"", ""};
		If[dimtarm == dimtar && maskt!={1}, fmaskF="targetMask.nii"; ExportNii[maskt,voxt,tempdir<>fmaskF]];
		If[dimmovm == dimmov && maskm!={1}, mmaskF="moveMask.nii"; ExportNii[maskm,voxm,tempdir<>mmaskF]];

		(*Export target and moving data*)
		{fixedF, movingF, outF} = {"target-"<>depth<>".nii", "moving-"<>depth<>".nii", "result-"<>depth<>".nii.gz"};
		ExportNii[target, voxt, tempdir<>fixedF];
		ExportNii[moving, voxm, tempdir<>movingF];

		(*Create command and run elastix*)
		command = ElastixCommand[elastix, tempdir, parF, {inpfol, movfol, outfol}, {fixedF, movingF, outF}, {fmaskF, mmaskF}][[1]];
		RunCommand[command];

		(*Import Results*)
		{data,vox}=ImportNii[tempdir<>outfol<>outF];

		,
		(*series to volume registration (2D-3D, 3D-4D)*)
		"series", 

		(*define folders*)
		{inpfol, movfol, outfol} = {"", "", ""};		
		(*Check if masks are needed*)
		{fmaskF, mmaskF} = {"", ""};
		If[dimtarm == dimtar && maskt!={1},	fmaskF="targetMask.nii"; ExportNii[maskt, voxt, tempdir<>fmaskF]];
		(*Export target and moving data*)
		{fixedF, movingF, outF} = {"target-"<>depth<>".nii", "moving-"<>depth<>".nii", "result-"<>depth<>".nii.gz"};
		ExportNii[target, voxt, tempdir<>fixedF];

		(*export moving data, loop over series*)
		{command, outfile}=Transpose@(
		(
			index = StringPadInteger[#];
			(*define folders*)
			movfol = outfol = "vol"<>index; CreateDirectory[tempdir<>outfol];
			(*Check if masks are needed*)
			If[(dimmovm == dimmov || dimmovm == Drop[dimmov,1]) && maskm!={1}, mmaskF = movfol<>$PathnameSeparator<>"moveMask.nii"; ExportNii[If[dimmovm == dimmov, maskm[[#]], maskm], voxm, tempdir<>mmaskF]];
			(*export moving*)
			ExportNii[moving[[#]], voxm, tempdir<>movfol<>$PathnameSeparator<>movingF];

			(*create command*)
			ElastixCommand[elastix, tempdir, parF, {inpfol, movfol, outfol}, {fixedF, movingF, outF}, {fmaskF, mmaskF}]
		)&/@Range[lengM]);

		(*Create and run batch*)
		RunBatfile[tempdir, command];

		(*Import results*)
		data=(First@ImportNii[#])&/@outfile;
		If[OptionValue[OutputTransformation], w = ReadTransformParameters[tempdir]];

		,
		(*if not series or vol then PCA based method*)
		"multi", 

		(*define folders*)
		{inpfol, movfol, outfol} = {"", "", ""};

		(*Check if masks are needed*)
		{fmaskF, mmaskF} = {"", ""};
		If[Drop[dimtar, 1] == dimtarm && maskt!={1}, fmaskF="targetMask.nii"; ExportNii[maskt,voxt,tempdir<>fmaskF]];
		If[Drop[dimmov, 1] == dimmovm && maskm!={1}, mmaskF="moveMask.nii"; ExportNii[maskm,voxm,tempdir<>mmaskF]];

		(*Export target and moving data*)
		{fixedF, movingF, outF} = {"target-"<>depth<>#<>".nii"&, "moving-"<>depth<>#<>".nii"&, "result-"<>depth<>".nii.gz"};
		(
			index = StringPadInteger["-",#];
			ExportNii[target[[#]], voxt, tempdir<>fixedF[index]];
			ExportNii[moving[[#]], voxm, tempdir<>movingF[index]];
		)&/@Range[lengM];

		(*Create command and run elastix*)
		command = ElastixCommand[elastix, tempdir, parF, {inpfol, movfol, outfol}, {fixedF, movingF, outF}, {fmaskF, mmaskF}, lengM][[1]];
		RunCommand[command];

		(*perform translation on all files *)
		debugElastix["TransformData: making multi output"];
		data = TransformData[{#, voxm}, TempDirectory->DirectoryName[tdir], DeleteTempDirectory->False, PrintTempDirectory->False]&/@moving;
	];

	(*do some cleanup*)
	If[OptionValue[ShowMetric], Print[ListLinePlot[Flatten[Import[#, "Data"][[2 ;;, 2]]& /@ FileNames["IterationInfo*", tempdir]]]]];
	If[OptionValue[DeleteTempDirectory], DeleteDirectory[tempdir, DeleteContents->True]];

	(*output results*)
	data = ToPackedArray[N@Chop[Clip[data, MinMax[moving]]]];
	If[OptionValue[OutputTransformation], {data, w}, data]
]


(* ::Subsubsection::Closed:: *)
(*RegisterDataSplit*)


Options[RegisterDataSplit] = Join[Options[RegisterData],{SplitMethod->"Mean"}];

SyntaxInformation[RegisterDataSplit] = {"ArgumentsPattern" -> {_, _., OptionsPattern[]}};

RegisterDataSplit[targeti_, movingi_, opts : OptionsPattern[]] := Block[{
	reg, mov, target ,maskT, voxT, moving, maskM, voxM,
	targetl, targetr, maskTl, maskTr, cut1, movingl, movingr, maskMl, maskMr, cut2,
	regl, regr, movl, movr
	},

	(*prepare the input*)
	{target ,maskT, voxT} = SplitRegInput[targeti];
	{moving, maskM, voxM} = SplitRegInput[movingi];

	(*find the common split*)	
	{targetl, targetr, cut1} = CutData[target];
	{movingl, movingr, cut2} = CutData[moving];

	{cut1, cut2} = Switch[OptionValue[SplitMethod],
		"target", Round[{cut1, (cut1 voxT[[2]])/voxM[[2]]}],
		"moving", Round[{(cut2 voxM[[2]])/voxT[[2]], cut2}],
		"nearest", Round[First@Nearest[{cut1 Last@voxT, cut2 Last@voxM}, (Last@Dimensions[target]/2) Last[voxT]]/{Last@voxT, Last@voxM}],
		"own", Round[{cut1, cut2}],
		_, Round[Mean[{cut1 voxT[[2]], cut2 voxM[[2]]}]/{voxT[[2]], voxM[[2]]}]
	];

	(*cut data*)
	{targetl, targetr, cut1} = CutData[target,cut1];
	{movingl, movingr, cut2} = CutData[moving,cut2];
	(*cut masks*)
	{maskTl, maskTr} = If[maskT==={1}, {{1},{1}}, CutData[maskT,cut1][[;;-2]]];
	{maskMl, maskMr} = If[maskM==={1}, {{1},{1}}, CutData[maskM,cut2][[;;-2]]];

	(*register left part*)
	regl = RegisterData[{targetl, maskTl, voxT}, {movingl, maskMl, voxM},Sequence@@FilterRules[{opts}, Options[RegisterData]]];
	(*register right part*)
	regr = RegisterData[{targetr, maskTr, voxT}, {movingr, maskMr, voxM},Sequence@@FilterRules[{opts}, Options[RegisterData]]];

	StichData[regl,regr]
]


(* ::Subsection:: *)
(*TransformData*)


(* ::Subsubsection::Closed:: *)
(*TransformData*)


Options[TransformData] = {
	TempDirectory -> "Default", 
	FindTransform -> "Auto", 
	DeleteTempDirectory -> "All", 
	PrintTempDirectory->True,
	Method -> "Default"
}

SyntaxInformation[TransformData] = {"ArgumentsPattern" -> {_, OptionsPattern[]}};

TransformData[{data_, vox_}, ops:OptionsPattern[]] := Module[{tdir, dat, command, output},
	If[OptionValue[Method]=="Loop",
		(*Loop over multi dimensions when set by user*)
		dat = If[ArrayDepth[data]===4,Transpose@data, data];
		dat = TransformData[{#, vox}, Method->"Default", DeleteTempDirectory->False, ops]&/@dat;

		(*Delete temp directory*)
		Switch[OptionValue[DeleteTempDirectory],
			"All", DeleteDirectory[FileNameTake[tdir, {1, -2}],DeleteContents -> True],
			"Trans", DeleteDirectory[tdir, DeleteContents -> True],
			_, Null];

		If[ArrayDepth[data]===4,Transpose@dat, dat];
		,
		(*perform normal tranform for single volume*)
		(*define the directory*)

		(*check if transform is given*)
		tdir = If[OptionValue[TempDirectory] === "Default", $lastElastixTemp, OptionValue[TempDirectory]];
		tdir = CreateTempDirectory[{tdir, "transform"}, OptionValue[PrintTempDirectory], True];

		debugElastix["transform using as temp directory: " <> tdir];
		debugElastix["transform $lastElastixTemp: " <> $lastElastixTemp];

		(*Export and transform*)
		ExportNii[data, vox, FileNameJoin[{tdir,"trans.nii"}]];
		command = TransformixCommand[tdir, True];

		RunCommand[command];
		output = ToPackedArray[ImportNii[FileNameJoin[{tdir,"result.nii"}]][[1]]];

		(*Delete temp directory*)
		Switch[OptionValue[DeleteTempDirectory],
			"All", DeleteDirectory[FileNameTake[tdir, {1, -2}],DeleteContents -> True],
			"Trans", DeleteDirectory[tdir, DeleteContents -> True],
			_, Null];

		(*give the output*)
		ToPackedArray@N@Chop[Clip[output,MinMax[data]],10^-6]
	]
]


(* ::Subsubsection::Closed:: *)
(*ReadTransformParameters*)


SyntaxInformation[ReadTransformParameters]={"ArgumentsPattern"->{_}};

ReadTransformParameters[dir_] := Block[{files, filenum, cor, pars},
	(*get all the transform files and sort them*)
	files = FileNames["TransformParameters*", dir, 3];
	filenum = If[Length[files] == 1, {1}, ToExpression[First[StringCases[FileNameSplit[#][[-2]], DigitCharacter ..]]] & /@ files];
	files = files[[Ordering[filenum]]];

	(*read and parse the parameter file*)
	pars = (((First[#] -> ToExpression[Rest[#]]) &[StringSplit[StringTake[#, {2, -2}]]]) & /@ Select[DeleteCases[Import[#, "Lines"], ""], StringTake[#, 2] =!= "//" &]) & /@ files;

	(*extract the trans*)
	cor = Partition[#, 3][[{1, 4, 3, 2}, {3, 2, 1}]] & /@ ("TransformParameters" /. pars);
	cor[[All, 1]] = cor[[All, 1]]/Degree;
	Flatten /@ cor
]


(* ::Subsection:: *)
(*RegisterDataTransform/Split*)


(* ::Subsubsection::Closed:: *)
(*RegisterDataTransform*)


Options[RegisterDataTransform] = Append[Options[RegisterData], TransformMethod->"Data"];

SyntaxInformation[RegisterDataTransform] = {"ArgumentsPattern" -> {_, _, _, OptionsPattern[]}};

RegisterDataTransform[target_, moving_, moving2_, opts : OptionsPattern[]]:=RegisterDataTransform[target, moving, SplitRegInput[moving2], opts]

RegisterDataTransform[_, _, $Failed, opts : OptionsPattern[]]:=Return[Message[RegisterData::inp]; $Failed]

RegisterDataTransform[target_, moving_, {moving2_, _, vox_}, opts : OptionsPattern[]] := Block[{reg, mov, met, fun, lab, tdir},

	tdir= CreateTempDirectory[OptionValue[TempDirectory], OptionValue[PrintTempDirectory]];

	reg = RegisterData[target, moving, DeleteTempDirectory -> False, PrintTempDirectory -> False, TempDirectory -> tdir,
		Sequence@@FilterRules[{opts}, Options[RegisterData]]];

	met = OptionValue[TransformMethod];
	fun = Switch[met,
		"Mask"|"Segmentation", SparseArray[Round[TransformData[{#, vox}, DeleteTempDirectory -> False, PrintTempDirectory -> False, TempDirectory->tdir]]]&,
		_, TransformData[{#, vox}, DeleteTempDirectory -> False, PrintTempDirectory -> False, TempDirectory->tdir]&
	];

	mov = If[met==="Segmentation", {mov, lab} = SplitSegmentations[moving2]; mov, moving2];

	mov = Which[
		ArrayDepth[mov]==4 && ArrayDepth[reg]>=3 ,
		Transpose[fun /@ Transpose[mov]] ,
		ArrayDepth[mov]==3 && ArrayDepth[reg]==2 ,
		fun /@ mov,
		True,
		fun @ mov
	];
	If[met==="Segmentation", mov = MergeSegmentations[RemoveMaskOverlaps[mov], lab]];

	If[OptionValue[DeleteTempDirectory], DeleteDirectory[tdir, DeleteContents->True]];		

	{reg, mov}
]


(* ::Subsubsection::Closed:: *)
(*RegisterDataTransformSplit*)


Options[RegisterDataTransformSplit] = Join[Options[RegisterData],{SplitMethod->"Mean", TransformMethod->"Data"}];

SyntaxInformation[RegisterDataTransformSplit] = {"ArgumentsPattern" -> {_, _, _, OptionsPattern[]}};

RegisterDataTransformSplit[targeti_, movingi_, {moving2_, vox_}, opts : OptionsPattern[]] := Block[{reg, mov,
	target ,maskT, voxT, moving, maskM, voxM,
	targetl, targetr, maskTl, maskTr, cut1, movingl, movingr, maskMl, maskMr, cut2,
	moving2l, moving2r, tdir, regl, regr, movl, movr
	},

	(*prepare the input*)
	{target ,maskT, voxT} = SplitRegInput[targeti];
	{moving, maskM, voxM} = SplitRegInput[movingi];

	(*find the common split*)	
	{targetl, targetr, cut1} = CutData[target];
	{movingl, movingr, cut2} = CutData[moving];

	{cut1, cut2} = Switch[OptionValue[SplitMethod],
		"Target", Round[{cut1, (cut1 voxT[[2]])/voxM[[2]]}],
		"Moving", Round[{(cut2 voxM[[2]])/voxT[[2]], cut2}],
		"Nearest", Round[First@Nearest[{cut1 Last@voxT, cut2 Last@voxM}, (Last@Dimensions[target]/2) Last[voxT]]/{Last@voxT, Last@voxM}],
		"own", Round[{cut1, cut2}],
		_, Round[Mean[{cut1 voxT[[2]], cut2 voxM[[2]]}]/{voxT[[2]], voxM[[2]]}]
		];

	(*cut data*)
	{targetl, targetr, cut1} = CutData[target,cut1];
	{movingl, movingr, cut2} = CutData[moving,cut2];
	(*cut masks*)
	{maskTl, maskTr} = If[maskT === {1}, {{1}, {1}}, CutData[maskT,cut1][[;;-2]]];
	{maskMl, maskMr} = If[maskM === {1}, {{1}, {1}}, CutData[maskM,cut2][[;;-2]]];

	(*split the moving2 data*)
	{moving2l, moving2r, cut2} = CutData[moving2, cut2];

	{regl, movl} = RegisterDataTransform[{targetl, maskTl, voxT}, {movingl, maskMl, voxM}, {moving2l, vox}, Sequence@@FilterRules[{opts}, Options[RegisterDataTransform]]];

	{regr, movr} = RegisterDataTransform[{targetr, maskTr, voxT}, {movingr, maskMr, voxM}, {moving2r, vox}, Sequence@@FilterRules[{opts}, Options[RegisterDataTransform]]];

	{StichData[regl,regr], StichData[movl,movr]}
]


(* ::Subsection:: *)
(*RegisterDiffusionData/Split*)


(* ::Subsubsection::Closed:: *)
(*RegisterDiffusionData*)


Options[RegisterDiffusionData] = Join[
	Options[RegisterData] /. {{1, 1, 1} -> {0, 1, 1}, "affine" -> "affineDTI", "rigid" -> "rigidDTI"},{
	IterationsA -> 1000, 
	ResolutionsA -> 1, 
	HistogramBinsA -> 64,
	NumberSamplesA -> 20000,
	InterpolationOrderRegA -> 1,
	MethodRegA -> {"rigid", "bspline"},
	RegistrationTarget->"Fist"
}];

SyntaxInformation[RegisterDiffusionData] = {"ArgumentsPattern" -> {_, _., OptionsPattern[]}};

(*No anatomical data, goto Registerdata*)
RegisterDiffusionData[
	{dtidata_?ArrayQ, vox : {_?NumberQ, _?NumberQ, _?NumberQ}}
,opts : OptionsPattern[]] := RegisterDiffusionData[{dtidata, {1}, vox}, opts]

RegisterDiffusionData[
	{dtidata_?ArrayQ, dtimask_?ArrayQ, vox : {_?NumberQ, _?NumberQ, _?NumberQ}}
,opts:OptionsPattern[]] := Block[{met},
	debugElastix["Diffusion registration"];
	met = (OptionValue[MethodReg] /. {"affine" -> "affineDTI", "rigid" -> "rigidDTI"});
	RegisterData[{dtidata, dtimask, vox},(*OutputTransformation->True,*) 
		MethodReg-> met,
		AffineDirections -> {1, 1, 1}, FilterRules[{opts}, Options[RegisterData]]]
]

(*Anatomical data present, define two registrations*)
RegisterDiffusionData[
	{dtidata_?ArrayQ, vox : {_?NumberQ, _?NumberQ, _?NumberQ}},
	{anatdata_?ArrayQ, voxa : {_?NumberQ, _?NumberQ, _?NumberQ}}
,opts : OptionsPattern[]] := RegisterDiffusionData[{dtidata, {1}, vox}, {anatdata, {1},voxa}, opts]

RegisterDiffusionData[
	{dtidata_?ArrayQ, dtimask_?ArrayQ, vox : {_?NumberQ, _?NumberQ, _?NumberQ}},
	{anatdata_?ArrayQ, voxa : {_?NumberQ, _?NumberQ, _?NumberQ}}
,opts : OptionsPattern[]] := RegisterDiffusionData[{dtidata, dtimask, vox}, {anatdata, {1}, voxa}, opts]

RegisterDiffusionData[
	{dtidata_?ArrayQ, vox : {_?NumberQ, _?NumberQ, _?NumberQ}},
	{anatdata_?ArrayQ, anatmask_?ArrayQ, voxa : {_?NumberQ, _?NumberQ, _?NumberQ}}
,opts : OptionsPattern[]] := RegisterDiffusionData[{dtidata, {1}, vox}, {anatdata, anatmask, voxa}, opts]

RegisterDiffusionData[
	{dtidata_?ArrayQ, dtimask_?ArrayQ, vox : {_?NumberQ, _?NumberQ, _?NumberQ}},
	{anatdata_?ArrayQ, anatmask_?ArrayQ, voxa : {_?NumberQ, _?NumberQ, _?NumberQ}},opts : OptionsPattern[]] := Module[{
		dtidatar, tempDir, tempDira, volDirs, w,tFilesA, tFilesD, dtidatarA, cmd, target, movingdata, vdir
	},

	tempDir = CreateTempDirectory[OptionValue[TempDirectory], OptionValue[PrintTempDirectory], True];
	tempDira = tempDir <> $PathnameSeparator <> "anat";

	(*perform DTI registration*)
	debugElastix["Diffusion registration"];	
	dtidatar = RegisterData[{dtidata, dtimask, vox},
		TempDirectory -> tempDir, 
		DeleteTempDirectory -> False, 
		PrintTempDirectory -> False,
		OutputTransformation->OptionValue[OutputTransformation], 
		MethodReg-> (OptionValue[MethodReg] /. {"affine" -> "affineDTI", "rigid" -> "rigidDTI"}),
		(*AffineDirections -> {1, 1, 1},*)
		FilterRules[{opts} , Options[RegisterData]]
	];

	If[OptionValue[OutputTransformation], {dtidatar,w} = dtidatar];

	target = OptionValue[RegistrationTarget];
	movingdata = If[ListQ[target] && AllTrue[target, IntegerQ] && Min[target] > 0 && Max[target] <= Length[dtidatar[[1]]],
		Median /@ dtidatar[[All, DeleteDuplicates[target]]],
		Switch[target,
			"Median", Median@Transpose@dtidatar,
			"First", First@Transpose@dtidatar,
			_, Mean@Transpose@dtidatar
		]
	];

	(*perform anat registration*)
	debugElastix["Anatomy registration"];
	RegisterData[{anatdata, anatmask, voxa}, {movingdata, vox},
		TempDirectory -> tempDira, 
		DeleteTempDirectory -> False,
		Iterations -> OptionValue[IterationsA], 
		Resolutions -> OptionValue[ResolutionsA],
		HistogramBins -> OptionValue[HistogramBinsA], 
		NumberSamples -> OptionValue[NumberSamplesA],
		InterpolationOrderReg -> OptionValue[InterpolationOrderRegA],
		BsplineSpacing -> OptionValue[BsplineSpacing], 
		BsplineDirections -> OptionValue[BsplineDirections],
		AffineDirections -> OptionValue[AffineDirections],
		MethodReg -> OptionValue[MethodRegA]/. {"affine" -> "affineDTI", "rigid" -> "rigidDTI"}, 
		FilterRules[{opts}, Options[RegisterData]]
	];

	(*transform all diffusion files to anatomy*)
	debugElastix["Combine transforms"];

	(*export diffusion reg target*)
	vdir = FileNameJoin[{tempDir,"vol"<>StringPadInteger[0]}];
	CreateDirectory[vdir];
	ExportNii[dtidatar[[All,1]],vox,FileNameJoin[{vdir,"moving-3D.nii"}]];

	(*get vol folders and anat transform files*)
	volDirs = FileNames["vol*", tempDir, 1];
	tFilesA = FileNames["TransformParameters*", tempDira];

	(*create Final Transform files*)
	(
		tFilesD = FileNames["TransformParameters*", #];
		ConcatenateTransformFiles[Join[tFilesD, tFilesA], #]
	) & /@ volDirs;

	(*call transformix*)
	cmd = TransformixCommand[tempDir, False];
	PrintTemporary["Combining transformations"];
	RunBatfile[tempDir, cmd, "T"];

	(*import dti data in anat space*)
	dtidatarA = Transpose[ImportNii[#][[1]] & /@ FileNames["resultA*", tempDir, 2]];

	(*finalize by deleting temp director*)
	If[OptionValue[DeleteTempDirectory],DeleteDirectory[tempDir,DeleteContents->True]];

	(*output data*)
	If[OptionValue[OutputTransformation],
		{dtidatar, dtidatarA, w},
		{dtidatar, dtidatarA}
	]
]


(* ::Subsubsection::Closed:: *)
(*RegisterDiffusionDataSplit*)


Options[RegisterDiffusionDataSplit] := Options[RegisterDiffusionData];

SyntaxInformation[RegisterDiffusionDataSplit] = {"ArgumentsPattern" -> {_, _., OptionsPattern[]}};

RegisterDiffusionDataSplit[
	{data_, vox: {_?NumberQ, _?NumberQ, _?NumberQ}}, 
	opts : OptionsPattern[]] := Block[
		{datal, datar, cut},

	{datal, datar, cut} = CutData[data];
	datal = RegisterDiffusionData[{datal, vox}, opts];
	datar = RegisterDiffusionData[{datar, vox}, opts];
	StichData[datal, datar]
];

RegisterDiffusionDataSplit[
	{data_, mask_, vox: {_?NumberQ, _?NumberQ, _?NumberQ}}, 
	opts : OptionsPattern[]] := Block[
		{datal, datar, cut,maskr,maskl},

	{datal, datar, cut} = CutData[data];
	{maskl, maskr, cut} = CutData[mask,cut];
	datal = RegisterDiffusionData[{datal, maskl, vox}, opts];
	datar = RegisterDiffusionData[{datar, maskr, vox}, opts];
	StichData[datal, datar]
];

RegisterDiffusionDataSplit[
	{data_, vox: {_?NumberQ, _?NumberQ, _?NumberQ}}, 
	{dataa_, voxa: {_?NumberQ, _?NumberQ, _?NumberQ}}, 
	opts : OptionsPattern[]] := Block[
		{datal, datar, dataal, dataar, cut1, cut2},

	(*find cuts*)
	{datal, datar, cut1} = CutData[data];
	{dataal, dataar, cut2} = CutData[dataa];

	(*align cuts*)
	{cut1,cut2}=Round[First@Nearest[{cut1 Last@vox, cut2 Last@voxa}, Round[Last@Dimensions[data]/2] Last@vox] / {Last@vox, Last@voxa}];
	(*{cut1,cut2}=Round[Mean[{cut1 vox[[2]], cut2 voxa[[2]]}]/{vox[[2]],voxa[[2]]}];*)

	(*cut with the aligned cuts*)
	{datal, datar, cut1} = CutData[data, cut1];
	{dataal, dataar, cut2} = CutData[dataa, cut2];

	datal = RegisterDiffusionData[{datal, vox}, {dataal, voxa}, opts][[2]];
	datar = RegisterDiffusionData[{datar, vox}, {dataar, voxa}, opts][[2]];
	StichData[datal, datar]
];

RegisterDiffusionDataSplit[
	{data_, mask_, vox: {_?NumberQ, _?NumberQ, _?NumberQ}}, 
	{dataa_, voxa: {_?NumberQ, _?NumberQ, _?NumberQ}}, 
	opts : OptionsPattern[]] := Block[
		{datal, datar, dataal, dataar, maskl, maskr, cut1,cut2},

	(*find cuts*)
	{datal, datar, cut1} = CutData[data];
	{dataal, dataar, cut2} = CutData[dataa];

	(*align cuts*)
	{cut1,cut2}=Round[First@Nearest[{cut1 Last@vox, cut2 Last@voxa}, Round[Last@Dimensions[data]/2] Last@vox] / {Last@vox, Last@voxa}];
	(*{cut1,cut2}=Round[Mean[{cut1 vox[[2]], cut2 voxa[[2]]}]/{vox[[2]],voxa[[2]]}];*)

	(*cut with the aligned cuts*) 
	{datal, datar, cut1} = CutData[data,cut1];
	{maskl, maskr, cut1} = CutData[mask,cut1];
	{dataal, dataar, cut2} = CutData[dataa,cut2];

	datal = RegisterDiffusionData[{datal, maskl, vox}, {dataal, voxa}, opts][[2]];
	datar = RegisterDiffusionData[{datar, maskr, vox}, {dataar, voxa}, opts][[2]];

	StichData[datal, datar]
];

RegisterDiffusionDataSplit[
	{data_, mask_, vox: {_?NumberQ, _?NumberQ, _?NumberQ}}, 
	{dataa_, maska_, voxa: {_?NumberQ, _?NumberQ, _?NumberQ}}, 
	opts : OptionsPattern[]] := Block[
		{datal, datar, dataal, dataar, maskl, maskr, maskal, maskar,cut1,cut2},

	(*find cuts*)
	{datal, datar, cut1} = CutData[data];
	{dataal, dataar, cut2} = CutData[dataa];

	(*align cuts*)
	{cut1,cut2}=Round[First@Nearest[{cut1 Last@vox, cut2 Last@voxa}, Round[Last@Dimensions[data]/2] Last@vox] / {Last@vox, Last@voxa}];
	(*{cut1,cut2}=Round[Mean[{cut1 vox[[2]], cut2 voxa[[2]]}]/{vox[[2]],voxa[[2]]}];*)

	(*cut with the aligned cuts*) 
	{datal, datar, cut1} = CutData[data,cut1];
	{maskl, maskr, cut1} = CutData[mask,cut1];
	{dataal, dataar, cut2} = CutData[dataa,cut2];
	{maskal, maskar, cut2} = CutData[maska,cut2];

	datal = RegisterDiffusionData[{datal, maskl, vox}, {dataal, maskal, voxa}, opts][[2]];
	datar = RegisterDiffusionData[{datar, maskr, vox}, {dataar, maskar, voxa}, opts][[2]];

	StichData[datal, datar]
];


(* ::Subsection::Closed:: *)
(*RegisterTensorData*)


Options[RegisterTensorData]=Options[RegisterData];

SyntaxInformation[RegisterTensorData]={"ArgumentsPattern"->{_,_,_.,OptionsPattern[]}};

RegisterTensorData[target_,moving_,opts:OptionsPattern[]]:=RegisterTensorData[SplitRegInput[target],SplitRegInput[moving],{{1},{1},{1,1,1}},opts]

RegisterTensorData[target_,moving_,moving2_,opts:OptionsPattern[]]:=RegisterTensorData[SplitRegInput[target],SplitRegInput[moving],SplitRegInput[moving2],opts]

RegisterTensorData[$Failed, _, _, opts:OptionsPattern[]]:=Return[Message[RegisterData::inp];$Failed]
RegisterTensorData[_, $Failed, _, opts:OptionsPattern[]]:=Return[Message[RegisterData::inp];$Failed]
RegisterTensorData[_, _, $Failed, opts:OptionsPattern[]]:=Return[Message[RegisterData::inp];$Failed]

RegisterTensorData[
	{target_?ArrayQ,maskt_?ArrayQ,voxt:{_?NumberQ,_?NumberQ,_?NumberQ}},
	{moving_?ArrayQ,maskm_?ArrayQ,voxm:{_?NumberQ,_?NumberQ,_?NumberQ}},
	{moving2_?ArrayQ,_?ArrayQ,vox:{_?NumberQ,_?NumberQ,_?NumberQ}}, opts:OptionsPattern[]]:=Block[{
		trans, coor, coorM, tari, movi, met, mov2, vox2, reg, reg2, tensR,cmask, disp
	},

	trans = moving2=!={1};

	(*get coordinates*)
	coor = MakeCoordinates[Dimensions@If[trans, target, target[[1]]],voxt];
	coorM = MakeCoordinates[Dimensions@If[trans, moving2[[1]], moving[[1]]], If[trans, vox, voxm]];

	(*makte the moving and target data*)
	tari = If[trans, target, Transpose[LogTensor@target]];
	movi = If[trans, moving, Transpose[LogTensor@moving]];
	mov2 = Transpose@If[trans, Join[LogTensor@moving2, coorM], coorM];
	vox2 = If[trans, vox, voxm];

	(*perorm the registration of tens and coor*)
	met = OptionValue[MethodReg]/.If[trans,{},{"rigid"->"rigidMulti","affine"->"affineMulti","bspline"->"bsplineMulti"}];
	{reg, reg2} = RegisterDataTransform[{tari, maskt, voxt}, {movi, maskm, voxm}, {mov2, vox}, MethodReg->met, InterpolationOrderReg->1, opts];

	(*correct the tensor for deformation*)
	tensR = ExpTensor@If[trans, Transpose[reg2[[All,;;6]]], Transpose[reg]];
	coorM = If[trans, Transpose@reg2[[All,7;;]], Transpose@reg2];
	disp = MaskData[coorM-coor, Times@@((Mask[#,5])&/@coorM)];
	tensR = TransformTensor[tensR, disp, voxt];

	(*generate the output*)
	If[trans, {reg, tensR}, tensR]
]


(* ::Subsection::Closed:: *)
(*RegisterCardiacData*)


Options[RegisterCardiacData]=Join[{RegistrationTarget->"Mean"},Options[RegisterData]];

SyntaxInformation[RegisterCardiacData]={"ArgumentsPattern"->{_,OptionsPattern[]}};

(*data only*)
RegisterCardiacData[data_?ArrayQ, opts:OptionsPattern[]]:=RegisterCardiacData[{data,{1},{1,1,1}},opts]
(*data with voxel*)
RegisterCardiacData[{data_?ArrayQ, vox:{_?NumberQ,_?NumberQ,_?NumberQ}}, opts:OptionsPattern[]]:=RegisterCardiacData[{data,{1},vox},opts]
(*data with mask*)
RegisterCardiacData[{data_?ArrayQ ,mask_?ArrayQ}, opts:OptionsPattern[]]:=RegisterCardiacData[{data,mask,{1,1,1}},opts]
(*data with mask and voxel*)
RegisterCardiacData[{data_?ArrayQ, mask_?ArrayQ, vox:{_?NumberQ,_?NumberQ,_?NumberQ}}, opts:OptionsPattern[]]:=Block[
	{tdir, datar, slices, maskr, i, size, target},

	tdir = CreateTempDirectory[OptionValue[TempDirectory], OptionValue[PrintTempDirectory], True];

	(*check if data is 3D or 4D*)
	slices = Range[Length[data]];
	size = Length[data[[1]]];
	maskr = If[mask=={1}, ConstantArray[1,Dimensions[data[[All,1]]]],mask];

	target=If[OptionValue[MethodReg]==="PCAtranslation"||OptionValue[MethodReg]==="PCArigid"||OptionValue[MethodReg]==="PCAaffine"||OptionValue[MethodReg]==="PCAbspline",
		"stack",
		OptionValue[RegistrationTarget]
	];

	(*monitro over slices*)
	Monitor[
		i=0;
		datar = Switch[target,
			"Mean",
			(i++; RegisterData[{N[Mean@data[[#]]],maskr[[#]],vox},{data[[#]],maskr[[#]],vox},
				OutputTransformation->False, PrintTempDirectory->False, TempDirectory->tdir, FilterRules[{opts},Options[RegisterData]]])&/@slices,
			"Median",
			(i++; RegisterData[{N[Median@data[[#]]],maskr[[#]],vox},{data[[#]],maskr[[#]],vox},
				OutputTransformation->False, PrintTempDirectory->False, TempDirectory->tdir, FilterRules[{opts},Options[RegisterData]]])&/@slices,
			"First",
			(i++; RegisterData[{data[[#,1]],maskr[[#]],vox},{data[[#]],maskr[[#]],vox},
				OutputTransformation->False, PrintTempDirectory->False, TempDirectory->tdir, FilterRules[{opts},Options[RegisterData]]])&/@slices,
			"stack",
			(i++; RegisterData[{data[[#]],ConstantArray[maskr[[#]],size],vox},
				OutputTransformation->False, PrintTempDirectory->False, TempDirectory->tdir, FilterRules[{opts},Options[RegisterData]]])&/@slices
		]
		,ProgressIndicator[i, {0,Length[data]}]
	];

	datar
]


(* ::Section:: *)
(*End Package*)


End[]

EndPackage[]
